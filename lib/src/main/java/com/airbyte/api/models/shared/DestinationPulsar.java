/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * DestinationPulsar - The values required to configure the destination.
 */
public class DestinationPulsar {
    /**
     * Control whether automatic batching of messages is enabled for the producer.
     */
    @JsonProperty("batching_enabled")
    public Boolean batchingEnabled;
    public DestinationPulsar withBatchingEnabled(Boolean batchingEnabled) {
        this.batchingEnabled = batchingEnabled;
        return this;
    }
    
    /**
     * Maximum number of messages permitted in a batch.
     */
    @JsonProperty("batching_max_messages")
    public Long batchingMaxMessages;
    public DestinationPulsar withBatchingMaxMessages(Long batchingMaxMessages) {
        this.batchingMaxMessages = batchingMaxMessages;
        return this;
    }
    
    /**
     *  Time period in milliseconds within which the messages sent will be batched.
     */
    @JsonProperty("batching_max_publish_delay")
    public Long batchingMaxPublishDelay;
    public DestinationPulsar withBatchingMaxPublishDelay(Long batchingMaxPublishDelay) {
        this.batchingMaxPublishDelay = batchingMaxPublishDelay;
        return this;
    }
    
    /**
     * If the send operation should block when the outgoing message queue is full.
     */
    @JsonProperty("block_if_queue_full")
    public Boolean blockIfQueueFull;
    public DestinationPulsar withBlockIfQueueFull(Boolean blockIfQueueFull) {
        this.blockIfQueueFull = blockIfQueueFull;
        return this;
    }
    
    /**
     * A list of host/port pairs to use for establishing the initial connection to the Pulsar cluster.
     */
    @JsonProperty("brokers")
    public String brokers;
    public DestinationPulsar withBrokers(String brokers) {
        this.brokers = brokers;
        return this;
    }
    
    /**
     * Compression type for the producer.
     */
    @JsonProperty("compression_type")
    public DestinationPulsarCompressionTypeEnum compressionType;
    public DestinationPulsar withCompressionType(DestinationPulsarCompressionTypeEnum compressionType) {
        this.compressionType = compressionType;
        return this;
    }
    
    @JsonProperty("destinationType")
    public DestinationPulsarPulsarEnum destinationType;
    public DestinationPulsar withDestinationType(DestinationPulsarPulsarEnum destinationType) {
        this.destinationType = destinationType;
        return this;
    }
    
    /**
     * The maximum size of a queue holding pending messages.
     */
    @JsonProperty("max_pending_messages")
    public Long maxPendingMessages;
    public DestinationPulsar withMaxPendingMessages(Long maxPendingMessages) {
        this.maxPendingMessages = maxPendingMessages;
        return this;
    }
    
    /**
     * The maximum number of pending messages across partitions.
     */
    @JsonProperty("max_pending_messages_across_partitions")
    public Long maxPendingMessagesAcrossPartitions;
    public DestinationPulsar withMaxPendingMessagesAcrossPartitions(Long maxPendingMessagesAcrossPartitions) {
        this.maxPendingMessagesAcrossPartitions = maxPendingMessagesAcrossPartitions;
        return this;
    }
    
    /**
     * Name for the producer. If not filled, the system will generate a globally unique name which can be accessed with.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("producer_name")
    public String producerName;
    public DestinationPulsar withProducerName(String producerName) {
        this.producerName = producerName;
        return this;
    }
    
    /**
     * Wait synchronously until the record has been sent to Pulsar.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("producer_sync")
    public Boolean producerSync;
    public DestinationPulsar withProducerSync(Boolean producerSync) {
        this.producerSync = producerSync;
        return this;
    }
    
    /**
     * If a message is not acknowledged by a server before the send-timeout expires, an error occurs (in ms).
     */
    @JsonProperty("send_timeout_ms")
    public Long sendTimeoutMs;
    public DestinationPulsar withSendTimeoutMs(Long sendTimeoutMs) {
        this.sendTimeoutMs = sendTimeoutMs;
        return this;
    }
    
    /**
     * The administrative unit of the topic, which acts as a grouping mechanism for related topics. Most topic configuration is performed at the namespace level. Each tenant has one or multiple namespaces.
     */
    @JsonProperty("topic_namespace")
    public String topicNamespace;
    public DestinationPulsar withTopicNamespace(String topicNamespace) {
        this.topicNamespace = topicNamespace;
        return this;
    }
    
    /**
     * Topic pattern in which the records will be sent. You can use patterns like '{namespace}' and/or '{stream}' to send the message to a specific topic based on these values. Notice that the topic name will be transformed to a standard naming convention.
     */
    @JsonProperty("topic_pattern")
    public String topicPattern;
    public DestinationPulsar withTopicPattern(String topicPattern) {
        this.topicPattern = topicPattern;
        return this;
    }
    
    /**
     * The topic tenant within the instance. Tenants are essential to multi-tenancy in Pulsar, and spread across clusters.
     */
    @JsonProperty("topic_tenant")
    public String topicTenant;
    public DestinationPulsar withTopicTenant(String topicTenant) {
        this.topicTenant = topicTenant;
        return this;
    }
    
    /**
     * Topic to test if Airbyte can produce messages.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("topic_test")
    public String topicTest;
    public DestinationPulsar withTopicTest(String topicTest) {
        this.topicTest = topicTest;
        return this;
    }
    
    /**
     * It identifies type of topic. Pulsar supports two kind of topics: persistent and non-persistent. In persistent topic, all messages are durably persisted on disk (that means on multiple disks unless the broker is standalone), whereas non-persistent topic does not persist message into storage disk.
     */
    @JsonProperty("topic_type")
    public DestinationPulsarTopicTypeEnum topicType;
    public DestinationPulsar withTopicType(DestinationPulsarTopicTypeEnum topicType) {
        this.topicType = topicType;
        return this;
    }
    
    /**
     * Whether to use TLS encryption on the connection.
     */
    @JsonProperty("use_tls")
    public Boolean useTls;
    public DestinationPulsar withUseTls(Boolean useTls) {
        this.useTls = useTls;
        return this;
    }
    
    public DestinationPulsar(@JsonProperty("batching_enabled") Boolean batchingEnabled, @JsonProperty("batching_max_messages") Long batchingMaxMessages, @JsonProperty("batching_max_publish_delay") Long batchingMaxPublishDelay, @JsonProperty("block_if_queue_full") Boolean blockIfQueueFull, @JsonProperty("brokers") String brokers, @JsonProperty("compression_type") DestinationPulsarCompressionTypeEnum compressionType, @JsonProperty("destinationType") DestinationPulsarPulsarEnum destinationType, @JsonProperty("max_pending_messages") Long maxPendingMessages, @JsonProperty("max_pending_messages_across_partitions") Long maxPendingMessagesAcrossPartitions, @JsonProperty("send_timeout_ms") Long sendTimeoutMs, @JsonProperty("topic_namespace") String topicNamespace, @JsonProperty("topic_pattern") String topicPattern, @JsonProperty("topic_tenant") String topicTenant, @JsonProperty("topic_type") DestinationPulsarTopicTypeEnum topicType, @JsonProperty("use_tls") Boolean useTls) {
        this.batchingEnabled = batchingEnabled;
        this.batchingMaxMessages = batchingMaxMessages;
        this.batchingMaxPublishDelay = batchingMaxPublishDelay;
        this.blockIfQueueFull = blockIfQueueFull;
        this.brokers = brokers;
        this.compressionType = compressionType;
        this.destinationType = destinationType;
        this.maxPendingMessages = maxPendingMessages;
        this.maxPendingMessagesAcrossPartitions = maxPendingMessagesAcrossPartitions;
        this.sendTimeoutMs = sendTimeoutMs;
        this.topicNamespace = topicNamespace;
        this.topicPattern = topicPattern;
        this.topicTenant = topicTenant;
        this.topicType = topicType;
        this.useTls = useTls;
  }
}
