/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.hooks;

import java.io.InputStream;
import java.lang.reflect.Field;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import com.airbyte.api.SecuritySource;
import com.airbyte.api.utils.Constants;
import com.airbyte.api.utils.Helpers;
import com.airbyte.api.utils.HTTPClient;
import com.airbyte.api.utils.Hook.AfterError;
import com.airbyte.api.utils.Hook.AfterErrorContext;
import com.airbyte.api.utils.Hook.BeforeRequest;
import com.airbyte.api.utils.Hook.BeforeRequestContext;
import com.airbyte.api.utils.Hook.SdkInit;
import com.airbyte.api.utils.Hook.SdkInitData;
import com.airbyte.api.utils.SessionManager;
import com.airbyte.api.utils.SessionManager.HasSessionKey;
import com.airbyte.api.utils.SessionManager.Session;
import com.airbyte.api.utils.Security;
import com.airbyte.api.utils.Utils;

public final class ClientCredentialsHook implements SdkInit, BeforeRequest, AfterError {

    private final SessionManager<Credentials> sessions;

    // set by sdkInit
    private String baseUrl;
    private HTTPClient client;

    public ClientCredentialsHook() {
        this.sessions = new SessionManager<Credentials>();
    }

    @Override
    public SdkInitData sdkInit(SdkInitData data) {
        baseUrl = data.baseUrl();
        client = data.client();
        return new SdkInitData(baseUrl, client);
    }

    @Override
    public HttpRequest beforeRequest(BeforeRequestContext context, HttpRequest request) throws Exception {
        if (!context.oauthScopes().isPresent()) {
            // OAuth2 not in use (scopes must be defined, and can be an empty array)
            return request;
        }
        final Credentials credentials;
        Optional<Credentials> c = credentials(context.securitySource());
        if (c.isPresent()) {
            credentials = c.get();
        } else {
            return request;
        }
        Session<Credentials> session = sessions.getSession(credentials, context.oauthScopes(),
                scopes -> doTokenRequest(context.baseUrl(), client, credentials, scopes, Constants.HAS_CLIENT_CREDENTIALS_BASIC));
        return Helpers.copy(request) //
                // overwrites any previous value
                .setHeader("Authorization", "Bearer " + session.token().orElse("")) //
                .build();
    }

    @Override
    public HttpResponse<InputStream> afterError(AfterErrorContext context, Optional<HttpResponse<InputStream>> response,
            Optional<Exception> error) throws Exception {
        if (error.isPresent()) {
            throw error.get();
        } else if (!context.oauthScopes().isPresent()) {
            return response.get();
        }

        Optional<Credentials> credentials = credentials(context.securitySource());
        if (!credentials.isPresent()) {
            return response.get();
        }

        if (response.get().statusCode() == HttpURLConnection.HTTP_UNAUTHORIZED) {
            String sessionKey = credentials.get().sessionKey();
            sessions.remove(sessionKey);
        }
        return response.get();
    }

    private static Session<Credentials> doTokenRequest(String baseUrl, HTTPClient client, Credentials credentials,
            List<String> scopes, boolean hasClientCredentialsBasic) {
        Map<String, String> payload = new HashMap<>();
        Map<String, String> headers = new HashMap<>();

        payload.put("grant_type", "client_credentials");
        if (hasClientCredentialsBasic) {
            headers.put("Authorization", "Basic "
                + Base64.getEncoder()
                .encodeToString(String.format("%s:%s", credentials.clientId, credentials.clientSecret)
                                      .getBytes(StandardCharsets.UTF_8)));
        } else {
            payload.put("client_id", credentials.clientId);
            payload.put("client_secret", credentials.clientSecret);
        }
        if (scopes.size() > 0) {
            payload.put("scope", scopes.stream().collect(Collectors.joining(" ")));
        }
        URI tokenUri = URI.create(baseUrl).resolve(credentials.tokenUrl);
        return SessionManager.requestOAuth2Token(client, credentials, scopes, payload, headers, tokenUri);
    }

    // VisibleForTesting
    final static class Credentials implements HasSessionKey {
        final String clientId;
        final String clientSecret;
        final String tokenUrl;

        Credentials(String clientId, String clientSecret, String tokenUrl) {
            Utils.checkNotNull(clientId, "clientId");
            Utils.checkNotNull(clientSecret, "clientSecret");
            Utils.checkNotNull(tokenUrl, "tokenUrl");
            this.clientId = clientId;
            this.clientSecret = clientSecret;
            this.tokenUrl = tokenUrl;
        }

        @Override
        public String sessionKey() {
            return Utils.sessionKey(clientId, clientSecret);
        }
    }

    private static Optional<Credentials> credentials(Optional<SecuritySource> source) {
        if (!source.isPresent()) {
            return Optional.empty();
        }
        Object security = source.get().getSecurity();
        if (security == null) {
            return Optional.empty();
        }
        
        // To find credentials we use reflection-based inspection of the SpeakeasyMetadata 
        // annotated fields in the object graph of `security`.

        // Look recursively for a non-empty complex field (not just a String) that holds 
        // client credentials and use the first one found. If present then is nested security
        // and we treat the field value as the security object when we search for the client credentials specific fields.
        
        Object sec = Security.findComplexObjectWithNonEmptyAnnotatedField(security, 
                        "\\bscheme=true\\b",
                        "\\btype=oauth2\\b", 
                        "\\bsubtype=client_credentials\\b")
                    .orElse(security);

        Optional<String> clientId = oauth2FieldValue(sec, "clientID");
        Optional<String> clientSecret = oauth2FieldValue(sec, "clientSecret");
        // tokenURL is not annotated so it doesn't get automatically serialized in some languages
        Optional<String> tokenUrl = fieldValue(sec, "tokenURL");
        if (clientId.isEmpty() || clientSecret.isEmpty() || tokenUrl.isEmpty()) {
            return Optional.empty();
        } else {
            return Optional.of(new Credentials(clientId.get(), clientSecret.get(), tokenUrl.get()));
        }
    }

    private static Optional<String> oauth2FieldValue(Object security, String name) {
        return Security.findStringValueWhereMetadataNameIs(security, name);
    }

    @SuppressWarnings("unchecked")
    private static Optional<String> fieldValue(Object o, String fieldName) {
        try {
            Field field = o.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            Object value = field.get(o);
            if (value instanceof Optional) {
                return (Optional<String>) value;
            } else {
                return Optional.of((String) value);
            }
        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
            return Optional.empty();
        }
    }
}