/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.hooks;

import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.OffsetDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import com.airbyte.api.SecuritySource;
import com.airbyte.api.models.errors.AuthException;
import com.airbyte.api.models.shared.SchemeClientCredentials;
import com.airbyte.api.utils.Helpers;
import com.airbyte.api.utils.HTTPClient;
import com.airbyte.api.utils.Hook.AfterError;
import com.airbyte.api.utils.Hook.AfterErrorContext;
import com.airbyte.api.utils.Hook.BeforeRequest;
import com.airbyte.api.utils.Hook.BeforeRequestContext;
import com.airbyte.api.utils.Hook.SdkInit;
import com.airbyte.api.utils.Hook.SdkInitData;
import com.airbyte.api.utils.RequestBody;
import com.airbyte.api.utils.Utils;

import com.fasterxml.jackson.annotation.JsonProperty;

public final class ClientCredentialsHook implements SdkInit, BeforeRequest, AfterError {

    // VisibleForTesting
    static final int REFRESH_BEFORE_EXPIRY_SECONDS = 60;

    private final Map<String, Session> sessions;

    // set by sdkInit
    private String baseUrl;
    private HTTPClient client;

    public ClientCredentialsHook() {
        this.sessions = new HashMap<>();
    }

    @Override
    public SdkInitData sdkInit(SdkInitData data) {
        baseUrl = data.baseUrl();
        client = data.client();
        return new SdkInitData(baseUrl, client);
    }

    @Override
    public HttpRequest beforeRequest(BeforeRequestContext context, HttpRequest request) throws Exception {
        if (!context.oauthScopes().isPresent()) {
            // OAuth2 not in use (scopes must be defined, and can be an empty array)
            return request;
        }
        final Credentials credentials;
        Optional<Credentials> c = credentials(context.securitySource());
        if (c.isPresent()) {
            credentials = c.get();
        } else {
            return request;
        }

        final String sessionKey = sessionKey(credentials);
        Optional<Session> currentSession = Optional.ofNullable(sessions.get(sessionKey));
        final Session session;
        if (shouldCreateNewSession(currentSession, context.oauthScopes())) {
            // note that we accumulate scopes. For example if a session existed 
            // for scope 'read' and this request requires scope 'write' then we 
            // request a new token for `read, write`. 
            
            // TODO it may be better to rather make `sessions` a Map<String, List<Session>>
            // where the none of the Session scope lists fully contains another in the same map value.
            // This would ensure that an operation is always called with a token with the minimum
            // permissions required and also would ensure that a token request is not rejected 
            // because of disallowed scope combinations (yet to see that in the wild).
            // For the example above with `read` and `write` scoped requests we would get a token 
            // for `read` scope, and then get a token for `write` scope and store both tokens in separate
            // Session objects in the map value list for the credential pair.
            
            List<String> scopes = accumulateScopes(context.oauthScopes(), currentSession);
            session = doTokenRequest(baseUrl, client, credentials, scopes);
            sessions.put(sessionKey, session);
        } else {
            session = currentSession.get();
        }

        return Helpers.copy(request) //
                // overwrites any previous value
                .setHeader("Authorization", "Bearer " + session.token.orElse("")) //
                .build();
    }

    // VisibleForTesting
    static boolean shouldCreateNewSession(Optional<Session> currentSession, Optional<List<String>> oauthScopes) {
        return !currentSession.isPresent() //
                || !hasRequiredScopes(currentSession.get().scopes, oauthScopes) //
                || hasTokenExpired(currentSession.get().expiresAt, OffsetDateTime.now());
    }

    @Override
    public HttpResponse<InputStream> afterError(AfterErrorContext context, Optional<HttpResponse<InputStream>> response,
            Optional<Exception> error) throws Exception {
        if (error.isPresent()) {
            throw error.get();
        } else if (!context.oauthScopes().isPresent()) {
            return response.get();
        }

        Optional<Credentials> credentials = credentials(context.securitySource());
        if (!credentials.isPresent()) {
            return response.get();
        }

        if (response.get().statusCode() == HttpURLConnection.HTTP_UNAUTHORIZED) {
            String sessionKey = sessionKey(credentials.get());
            sessions.remove(sessionKey);
        }
        return response.get();
    }

    private static Session doTokenRequest(String baseUrl, HTTPClient client, Credentials credentials, List<String> scopes) throws IllegalArgumentException,
            IllegalAccessException, IOException, InterruptedException, URISyntaxException {
        Map<String, String> payload = new HashMap<>();
        payload.put("grant_type", "client_credentials");
        payload.put("client_id", credentials.clientId);
        payload.put("client_secret", credentials.clientSecret);
        if (scopes.size() > 0) {
            payload.put("scope", scopes.stream().collect(Collectors.joining(" ")));
        }
        URI tokenUri = URI.create(baseUrl).resolve(credentials.tokenUrl);
        HttpRequest request = HttpRequest //
                .newBuilder(tokenUri) //
                .header("Content-Type", "application/x-www-form-urlencoded") //
                .POST(RequestBody.serializeFormData(payload).body()) //
                .build();
        HttpResponse<InputStream> response = client.send(request);
        if (response.statusCode() != HttpURLConnection.HTTP_OK) {
            String responseBody = Utils.toUtf8AndClose(response.body());
            throw new AuthException(response.statusCode(), "Unexpected status code " + response.statusCode() + ": " + responseBody);
        }
        TokenResponse t = Utils.mapper().readValue(response.body(), TokenResponse.class);
        if (!t.tokenType.orElse("").equals("Bearer")) {
            throw new AuthException("Expected 'Bearer' token type but was '" + t.tokenType.orElse("") + "'");
        }
        final Optional<OffsetDateTime> expiresAt = t.expiresInMs
                .map(x -> OffsetDateTime.now().plus(x, ChronoUnit.MILLIS));
        return new Session(credentials, t.accessToken, scopes, expiresAt);
    }

    private static List<String> accumulateScopes(Optional<List<String>> requiredScopes, Optional<Session> session) {
        if (session.isPresent()) {
            List<String> scopes = new ArrayList<>(requiredScopes.orElse(Collections.emptyList()));
            scopes.addAll(session.get().scopes);
            return scopes.stream() //
                    .distinct() //
                    .collect(Collectors.toList());
        } else {
            return requiredScopes.orElse(Collections.emptyList());
        }
    }

    // VisibleForTesting
    static boolean hasTokenExpired(Optional<OffsetDateTime> expiresAt, OffsetDateTime now) {
        return expiresAt.isEmpty() //
                || now.plusSeconds(REFRESH_BEFORE_EXPIRY_SECONDS).isAfter(expiresAt.get());
    }

    // VisibleForTesting
    static boolean hasRequiredScopes(List<String> sessionScopes, Optional<List<String>> requiredScopes) {
        return sessionScopes.containsAll(requiredScopes.orElse(Collections.emptyList()));
    }

    final static class TokenResponse {

        @JsonProperty("access_token")
        Optional<String> accessToken;

        @JsonProperty("token_type")
        Optional<String> tokenType;

        @JsonProperty("expires_in")
        Optional<Long> expiresInMs;

    }

    // VisibleForTesting
    final static class Credentials {
        final String clientId;
        final String clientSecret;
        final String tokenUrl;

        Credentials(String clientId, String clientSecret, String tokenUrl) {
            Utils.checkNotNull(clientId, "clientId");
            Utils.checkNotNull(clientSecret, "clientSecret");
            Utils.checkNotNull(tokenUrl, "tokenUrl");
            this.clientId = clientId;
            this.clientSecret = clientSecret;
            this.tokenUrl = tokenUrl;
        }
    }

    // VisibleForTesting
    final static class Session {
        final Credentials credentials;
        final Optional<String> token;
        final List<String> scopes;
        final Optional<OffsetDateTime> expiresAt;

        Session(Credentials credentials, Optional<String> token, List<String> scopes,
                Optional<OffsetDateTime> expiresAt) {
            this.credentials = credentials;
            this.token = token;
            this.scopes = scopes;
            this.expiresAt = expiresAt;
        }
    }

    private static Optional<Credentials> credentials(Optional<SecuritySource> source) {
        if (!source.isPresent()) {
            return Optional.empty();
        }
        // clientID, clientSecret etc will be typed as `Optional` if global security not present
        Optional<String> clientId = source.get().getSecurity().clientCredentials().map(SchemeClientCredentials::clientID);
        Optional<String> clientSecret = source.get().getSecurity().clientCredentials().map(SchemeClientCredentials::clientSecret);
        Optional<String> tokenUrl = source.get().getSecurity().clientCredentials().map(SchemeClientCredentials::tokenURL);
        if (clientId.isEmpty() || clientSecret.isEmpty() || tokenUrl.isEmpty()) {
            return Optional.empty();
        } else {
           return Optional.of(new Credentials(clientId.get(), clientSecret.get(), tokenUrl.get()));
        }
    }

    private static Optional<String> toOptional(String s) {
        return Optional.ofNullable(s);
    }
    
    private static Optional<String> toOptional(Optional<String> s) {
        return s;
    }

    private static String sessionKey(Credentials credentials) {
        return sessionKey(credentials.clientId, credentials.clientSecret);
    }

    private static String sessionKey(String clientId, String clientSecret) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            String input = clientId + ":" + clientSecret;
            byte[] bytes = md.digest(input.getBytes(StandardCharsets.UTF_8));
            return Utils.bytesToLowerCaseHex(bytes);
        } catch (NoSuchAlgorithmException e) {
            // not expected, MD5 always available
            throw new RuntimeException(e);
        }
    }
}
