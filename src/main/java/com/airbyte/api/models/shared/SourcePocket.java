/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;

public class SourcePocket {

    /**
     * The user's Pocket access token.
     */
    @JsonProperty("access_token")
    private String accessToken;

    /**
     * Your application's Consumer Key.
     */
    @JsonProperty("consumer_key")
    private String consumerKey;

    /**
     * Select the content type of the items to retrieve.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("content_type")
    private Optional<? extends ContentType> contentType;

    /**
     * Select the granularity of the information about each item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("detail_type")
    private Optional<? extends DetailType> detailType;

    /**
     * Only return items from a particular `domain`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("domain")
    private Optional<String> domain;

    /**
     * Retrieve only favorited items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("favorite")
    private Optional<Boolean> favorite;

    /**
     * Only return items whose title or url contain the `search` string.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("search")
    private Optional<String> search;

    /**
     * Only return items modified since the given timestamp.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("since")
    private Optional<String> since;

    /**
     * Sort retrieved items by the given criteria.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort")
    private Optional<? extends SourcePocketSortBy> sort;

    @JsonProperty("sourceType")
    private Pocket sourceType;

    /**
     * Select the state of the items to retrieve.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("state")
    private Optional<? extends State> state;

    /**
     * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tag")
    private Optional<String> tag;

    @JsonCreator
    public SourcePocket(
            @JsonProperty("access_token") String accessToken,
            @JsonProperty("consumer_key") String consumerKey,
            @JsonProperty("content_type") Optional<? extends ContentType> contentType,
            @JsonProperty("detail_type") Optional<? extends DetailType> detailType,
            @JsonProperty("domain") Optional<String> domain,
            @JsonProperty("favorite") Optional<Boolean> favorite,
            @JsonProperty("search") Optional<String> search,
            @JsonProperty("since") Optional<String> since,
            @JsonProperty("sort") Optional<? extends SourcePocketSortBy> sort,
            @JsonProperty("state") Optional<? extends State> state,
            @JsonProperty("tag") Optional<String> tag) {
        Utils.checkNotNull(accessToken, "accessToken");
        Utils.checkNotNull(consumerKey, "consumerKey");
        Utils.checkNotNull(contentType, "contentType");
        Utils.checkNotNull(detailType, "detailType");
        Utils.checkNotNull(domain, "domain");
        Utils.checkNotNull(favorite, "favorite");
        Utils.checkNotNull(search, "search");
        Utils.checkNotNull(since, "since");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(state, "state");
        Utils.checkNotNull(tag, "tag");
        this.accessToken = accessToken;
        this.consumerKey = consumerKey;
        this.contentType = contentType;
        this.detailType = detailType;
        this.domain = domain;
        this.favorite = favorite;
        this.search = search;
        this.since = since;
        this.sort = sort;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.state = state;
        this.tag = tag;
    }
    
    public SourcePocket(
            String accessToken,
            String consumerKey) {
        this(accessToken, consumerKey, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The user's Pocket access token.
     */
    @JsonIgnore
    public String accessToken() {
        return accessToken;
    }

    /**
     * Your application's Consumer Key.
     */
    @JsonIgnore
    public String consumerKey() {
        return consumerKey;
    }

    /**
     * Select the content type of the items to retrieve.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ContentType> contentType() {
        return (Optional<ContentType>) contentType;
    }

    /**
     * Select the granularity of the information about each item.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DetailType> detailType() {
        return (Optional<DetailType>) detailType;
    }

    /**
     * Only return items from a particular `domain`.
     */
    @JsonIgnore
    public Optional<String> domain() {
        return domain;
    }

    /**
     * Retrieve only favorited items.
     */
    @JsonIgnore
    public Optional<Boolean> favorite() {
        return favorite;
    }

    /**
     * Only return items whose title or url contain the `search` string.
     */
    @JsonIgnore
    public Optional<String> search() {
        return search;
    }

    /**
     * Only return items modified since the given timestamp.
     */
    @JsonIgnore
    public Optional<String> since() {
        return since;
    }

    /**
     * Sort retrieved items by the given criteria.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourcePocketSortBy> sort() {
        return (Optional<SourcePocketSortBy>) sort;
    }

    @JsonIgnore
    public Pocket sourceType() {
        return sourceType;
    }

    /**
     * Select the state of the items to retrieve.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<State> state() {
        return (Optional<State>) state;
    }

    /**
     * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
     */
    @JsonIgnore
    public Optional<String> tag() {
        return tag;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The user's Pocket access token.
     */
    public SourcePocket withAccessToken(String accessToken) {
        Utils.checkNotNull(accessToken, "accessToken");
        this.accessToken = accessToken;
        return this;
    }

    /**
     * Your application's Consumer Key.
     */
    public SourcePocket withConsumerKey(String consumerKey) {
        Utils.checkNotNull(consumerKey, "consumerKey");
        this.consumerKey = consumerKey;
        return this;
    }

    /**
     * Select the content type of the items to retrieve.
     */
    public SourcePocket withContentType(ContentType contentType) {
        Utils.checkNotNull(contentType, "contentType");
        this.contentType = Optional.ofNullable(contentType);
        return this;
    }

    /**
     * Select the content type of the items to retrieve.
     */
    public SourcePocket withContentType(Optional<? extends ContentType> contentType) {
        Utils.checkNotNull(contentType, "contentType");
        this.contentType = contentType;
        return this;
    }

    /**
     * Select the granularity of the information about each item.
     */
    public SourcePocket withDetailType(DetailType detailType) {
        Utils.checkNotNull(detailType, "detailType");
        this.detailType = Optional.ofNullable(detailType);
        return this;
    }

    /**
     * Select the granularity of the information about each item.
     */
    public SourcePocket withDetailType(Optional<? extends DetailType> detailType) {
        Utils.checkNotNull(detailType, "detailType");
        this.detailType = detailType;
        return this;
    }

    /**
     * Only return items from a particular `domain`.
     */
    public SourcePocket withDomain(String domain) {
        Utils.checkNotNull(domain, "domain");
        this.domain = Optional.ofNullable(domain);
        return this;
    }

    /**
     * Only return items from a particular `domain`.
     */
    public SourcePocket withDomain(Optional<String> domain) {
        Utils.checkNotNull(domain, "domain");
        this.domain = domain;
        return this;
    }

    /**
     * Retrieve only favorited items.
     */
    public SourcePocket withFavorite(boolean favorite) {
        Utils.checkNotNull(favorite, "favorite");
        this.favorite = Optional.ofNullable(favorite);
        return this;
    }

    /**
     * Retrieve only favorited items.
     */
    public SourcePocket withFavorite(Optional<Boolean> favorite) {
        Utils.checkNotNull(favorite, "favorite");
        this.favorite = favorite;
        return this;
    }

    /**
     * Only return items whose title or url contain the `search` string.
     */
    public SourcePocket withSearch(String search) {
        Utils.checkNotNull(search, "search");
        this.search = Optional.ofNullable(search);
        return this;
    }

    /**
     * Only return items whose title or url contain the `search` string.
     */
    public SourcePocket withSearch(Optional<String> search) {
        Utils.checkNotNull(search, "search");
        this.search = search;
        return this;
    }

    /**
     * Only return items modified since the given timestamp.
     */
    public SourcePocket withSince(String since) {
        Utils.checkNotNull(since, "since");
        this.since = Optional.ofNullable(since);
        return this;
    }

    /**
     * Only return items modified since the given timestamp.
     */
    public SourcePocket withSince(Optional<String> since) {
        Utils.checkNotNull(since, "since");
        this.since = since;
        return this;
    }

    /**
     * Sort retrieved items by the given criteria.
     */
    public SourcePocket withSort(SourcePocketSortBy sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }

    /**
     * Sort retrieved items by the given criteria.
     */
    public SourcePocket withSort(Optional<? extends SourcePocketSortBy> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * Select the state of the items to retrieve.
     */
    public SourcePocket withState(State state) {
        Utils.checkNotNull(state, "state");
        this.state = Optional.ofNullable(state);
        return this;
    }

    /**
     * Select the state of the items to retrieve.
     */
    public SourcePocket withState(Optional<? extends State> state) {
        Utils.checkNotNull(state, "state");
        this.state = state;
        return this;
    }

    /**
     * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
     */
    public SourcePocket withTag(String tag) {
        Utils.checkNotNull(tag, "tag");
        this.tag = Optional.ofNullable(tag);
        return this;
    }

    /**
     * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
     */
    public SourcePocket withTag(Optional<String> tag) {
        Utils.checkNotNull(tag, "tag");
        this.tag = tag;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourcePocket other = (SourcePocket) o;
        return 
            Objects.deepEquals(this.accessToken, other.accessToken) &&
            Objects.deepEquals(this.consumerKey, other.consumerKey) &&
            Objects.deepEquals(this.contentType, other.contentType) &&
            Objects.deepEquals(this.detailType, other.detailType) &&
            Objects.deepEquals(this.domain, other.domain) &&
            Objects.deepEquals(this.favorite, other.favorite) &&
            Objects.deepEquals(this.search, other.search) &&
            Objects.deepEquals(this.since, other.since) &&
            Objects.deepEquals(this.sort, other.sort) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.state, other.state) &&
            Objects.deepEquals(this.tag, other.tag);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            accessToken,
            consumerKey,
            contentType,
            detailType,
            domain,
            favorite,
            search,
            since,
            sort,
            sourceType,
            state,
            tag);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourcePocket.class,
                "accessToken", accessToken,
                "consumerKey", consumerKey,
                "contentType", contentType,
                "detailType", detailType,
                "domain", domain,
                "favorite", favorite,
                "search", search,
                "since", since,
                "sort", sort,
                "sourceType", sourceType,
                "state", state,
                "tag", tag);
    }
    
    public final static class Builder {
 
        private String accessToken;
 
        private String consumerKey;
 
        private Optional<? extends ContentType> contentType = Optional.empty();
 
        private Optional<? extends DetailType> detailType = Optional.empty();
 
        private Optional<String> domain = Optional.empty();
 
        private Optional<Boolean> favorite;
 
        private Optional<String> search = Optional.empty();
 
        private Optional<String> since = Optional.empty();
 
        private Optional<? extends SourcePocketSortBy> sort = Optional.empty();
 
        private Optional<? extends State> state = Optional.empty();
 
        private Optional<String> tag = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The user's Pocket access token.
         */
        public Builder accessToken(String accessToken) {
            Utils.checkNotNull(accessToken, "accessToken");
            this.accessToken = accessToken;
            return this;
        }

        /**
         * Your application's Consumer Key.
         */
        public Builder consumerKey(String consumerKey) {
            Utils.checkNotNull(consumerKey, "consumerKey");
            this.consumerKey = consumerKey;
            return this;
        }

        /**
         * Select the content type of the items to retrieve.
         */
        public Builder contentType(ContentType contentType) {
            Utils.checkNotNull(contentType, "contentType");
            this.contentType = Optional.ofNullable(contentType);
            return this;
        }

        /**
         * Select the content type of the items to retrieve.
         */
        public Builder contentType(Optional<? extends ContentType> contentType) {
            Utils.checkNotNull(contentType, "contentType");
            this.contentType = contentType;
            return this;
        }

        /**
         * Select the granularity of the information about each item.
         */
        public Builder detailType(DetailType detailType) {
            Utils.checkNotNull(detailType, "detailType");
            this.detailType = Optional.ofNullable(detailType);
            return this;
        }

        /**
         * Select the granularity of the information about each item.
         */
        public Builder detailType(Optional<? extends DetailType> detailType) {
            Utils.checkNotNull(detailType, "detailType");
            this.detailType = detailType;
            return this;
        }

        /**
         * Only return items from a particular `domain`.
         */
        public Builder domain(String domain) {
            Utils.checkNotNull(domain, "domain");
            this.domain = Optional.ofNullable(domain);
            return this;
        }

        /**
         * Only return items from a particular `domain`.
         */
        public Builder domain(Optional<String> domain) {
            Utils.checkNotNull(domain, "domain");
            this.domain = domain;
            return this;
        }

        /**
         * Retrieve only favorited items.
         */
        public Builder favorite(boolean favorite) {
            Utils.checkNotNull(favorite, "favorite");
            this.favorite = Optional.ofNullable(favorite);
            return this;
        }

        /**
         * Retrieve only favorited items.
         */
        public Builder favorite(Optional<Boolean> favorite) {
            Utils.checkNotNull(favorite, "favorite");
            this.favorite = favorite;
            return this;
        }

        /**
         * Only return items whose title or url contain the `search` string.
         */
        public Builder search(String search) {
            Utils.checkNotNull(search, "search");
            this.search = Optional.ofNullable(search);
            return this;
        }

        /**
         * Only return items whose title or url contain the `search` string.
         */
        public Builder search(Optional<String> search) {
            Utils.checkNotNull(search, "search");
            this.search = search;
            return this;
        }

        /**
         * Only return items modified since the given timestamp.
         */
        public Builder since(String since) {
            Utils.checkNotNull(since, "since");
            this.since = Optional.ofNullable(since);
            return this;
        }

        /**
         * Only return items modified since the given timestamp.
         */
        public Builder since(Optional<String> since) {
            Utils.checkNotNull(since, "since");
            this.since = since;
            return this;
        }

        /**
         * Sort retrieved items by the given criteria.
         */
        public Builder sort(SourcePocketSortBy sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * Sort retrieved items by the given criteria.
         */
        public Builder sort(Optional<? extends SourcePocketSortBy> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }

        /**
         * Select the state of the items to retrieve.
         */
        public Builder state(State state) {
            Utils.checkNotNull(state, "state");
            this.state = Optional.ofNullable(state);
            return this;
        }

        /**
         * Select the state of the items to retrieve.
         */
        public Builder state(Optional<? extends State> state) {
            Utils.checkNotNull(state, "state");
            this.state = state;
            return this;
        }

        /**
         * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
         */
        public Builder tag(String tag) {
            Utils.checkNotNull(tag, "tag");
            this.tag = Optional.ofNullable(tag);
            return this;
        }

        /**
         * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
         */
        public Builder tag(Optional<String> tag) {
            Utils.checkNotNull(tag, "tag");
            this.tag = tag;
            return this;
        }
        
        public SourcePocket build() {
            if (favorite == null) {
                favorite = _SINGLETON_VALUE_Favorite.value();
            }
            return new SourcePocket(
                accessToken,
                consumerKey,
                contentType,
                detailType,
                domain,
                favorite,
                search,
                since,
                sort,
                state,
                tag);
        }

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_Favorite =
                new LazySingletonValue<>(
                        "favorite",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Pocket> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"pocket\"",
                        new TypeReference<Pocket>() {});
    }
}
