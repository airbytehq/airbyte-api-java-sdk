/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

/**
 * Csv - This connector utilises &lt;a href="https: // arrow.apache.org/docs/python/generated/pyarrow.csv.open_csv.html" target="_blank"&gt;PyArrow (Apache Arrow)&lt;/a&gt; for CSV parsing.
 */

public class Csv {

    /**
     * Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank"&gt;detailed here&lt;/a&gt;. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("additional_reader_options")
    private Optional<? extends String> additionalReaderOptions;

    /**
     * Optionally add a valid JSON string here to provide additional &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank"&gt;Pyarrow ReadOptions&lt;/a&gt;. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("advanced_options")
    private Optional<? extends String> advancedOptions;

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("block_size")
    private Optional<? extends Long> blockSize;

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("delimiter")
    private Optional<? extends String> delimiter;

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("double_quote")
    private Optional<? extends Boolean> doubleQuote;

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("encoding")
    private Optional<? extends String> encoding;

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("escape_char")
    private Optional<? extends String> escapeChar;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filetype")
    private Optional<? extends SourceS3SchemasFormatFileFormatFiletype> filetype;

    /**
     * Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("infer_datatypes")
    private Optional<? extends Boolean> inferDatatypes;

    /**
     * Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("newlines_in_values")
    private Optional<? extends Boolean> newlinesInValues;

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("quote_char")
    private Optional<? extends String> quoteChar;

    public Csv(
            @JsonProperty("additional_reader_options") Optional<? extends String> additionalReaderOptions,
            @JsonProperty("advanced_options") Optional<? extends String> advancedOptions,
            @JsonProperty("block_size") Optional<? extends Long> blockSize,
            @JsonProperty("delimiter") Optional<? extends String> delimiter,
            @JsonProperty("double_quote") Optional<? extends Boolean> doubleQuote,
            @JsonProperty("encoding") Optional<? extends String> encoding,
            @JsonProperty("escape_char") Optional<? extends String> escapeChar,
            @JsonProperty("infer_datatypes") Optional<? extends Boolean> inferDatatypes,
            @JsonProperty("newlines_in_values") Optional<? extends Boolean> newlinesInValues,
            @JsonProperty("quote_char") Optional<? extends String> quoteChar) {
        Utils.checkNotNull(additionalReaderOptions, "additionalReaderOptions");
        Utils.checkNotNull(advancedOptions, "advancedOptions");
        Utils.checkNotNull(blockSize, "blockSize");
        Utils.checkNotNull(delimiter, "delimiter");
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        Utils.checkNotNull(encoding, "encoding");
        Utils.checkNotNull(escapeChar, "escapeChar");
        Utils.checkNotNull(inferDatatypes, "inferDatatypes");
        Utils.checkNotNull(newlinesInValues, "newlinesInValues");
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.additionalReaderOptions = additionalReaderOptions;
        this.advancedOptions = advancedOptions;
        this.blockSize = blockSize;
        this.delimiter = delimiter;
        this.doubleQuote = doubleQuote;
        this.encoding = encoding;
        this.escapeChar = escapeChar;
        this.filetype = Builder._SINGLETON_VALUE_Filetype.value();
        this.inferDatatypes = inferDatatypes;
        this.newlinesInValues = newlinesInValues;
        this.quoteChar = quoteChar;
    }

    /**
     * Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank"&gt;detailed here&lt;/a&gt;. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
     */
    public Optional<? extends String> additionalReaderOptions() {
        return additionalReaderOptions;
    }

    /**
     * Optionally add a valid JSON string here to provide additional &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank"&gt;Pyarrow ReadOptions&lt;/a&gt;. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
     */
    public Optional<? extends String> advancedOptions() {
        return advancedOptions;
    }

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    public Optional<? extends Long> blockSize() {
        return blockSize;
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public Optional<? extends String> delimiter() {
        return delimiter;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public Optional<? extends Boolean> doubleQuote() {
        return doubleQuote;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public Optional<? extends String> encoding() {
        return encoding;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public Optional<? extends String> escapeChar() {
        return escapeChar;
    }

    public Optional<? extends SourceS3SchemasFormatFileFormatFiletype> filetype() {
        return filetype;
    }

    /**
     * Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings
     */
    public Optional<? extends Boolean> inferDatatypes() {
        return inferDatatypes;
    }

    /**
     * Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False.
     */
    public Optional<? extends Boolean> newlinesInValues() {
        return newlinesInValues;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public Optional<? extends String> quoteChar() {
        return quoteChar;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank"&gt;detailed here&lt;/a&gt;. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
     */
    public Csv withAdditionalReaderOptions(String additionalReaderOptions) {
        Utils.checkNotNull(additionalReaderOptions, "additionalReaderOptions");
        this.additionalReaderOptions = Optional.ofNullable(additionalReaderOptions);
        return this;
    }

    /**
     * Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank"&gt;detailed here&lt;/a&gt;. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
     */
    public Csv withAdditionalReaderOptions(Optional<? extends String> additionalReaderOptions) {
        Utils.checkNotNull(additionalReaderOptions, "additionalReaderOptions");
        this.additionalReaderOptions = additionalReaderOptions;
        return this;
    }

    /**
     * Optionally add a valid JSON string here to provide additional &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank"&gt;Pyarrow ReadOptions&lt;/a&gt;. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
     */
    public Csv withAdvancedOptions(String advancedOptions) {
        Utils.checkNotNull(advancedOptions, "advancedOptions");
        this.advancedOptions = Optional.ofNullable(advancedOptions);
        return this;
    }

    /**
     * Optionally add a valid JSON string here to provide additional &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank"&gt;Pyarrow ReadOptions&lt;/a&gt;. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
     */
    public Csv withAdvancedOptions(Optional<? extends String> advancedOptions) {
        Utils.checkNotNull(advancedOptions, "advancedOptions");
        this.advancedOptions = advancedOptions;
        return this;
    }

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    public Csv withBlockSize(long blockSize) {
        Utils.checkNotNull(blockSize, "blockSize");
        this.blockSize = Optional.ofNullable(blockSize);
        return this;
    }

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    public Csv withBlockSize(Optional<? extends Long> blockSize) {
        Utils.checkNotNull(blockSize, "blockSize");
        this.blockSize = blockSize;
        return this;
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public Csv withDelimiter(String delimiter) {
        Utils.checkNotNull(delimiter, "delimiter");
        this.delimiter = Optional.ofNullable(delimiter);
        return this;
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public Csv withDelimiter(Optional<? extends String> delimiter) {
        Utils.checkNotNull(delimiter, "delimiter");
        this.delimiter = delimiter;
        return this;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public Csv withDoubleQuote(boolean doubleQuote) {
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        this.doubleQuote = Optional.ofNullable(doubleQuote);
        return this;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public Csv withDoubleQuote(Optional<? extends Boolean> doubleQuote) {
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        this.doubleQuote = doubleQuote;
        return this;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public Csv withEncoding(String encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = Optional.ofNullable(encoding);
        return this;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public Csv withEncoding(Optional<? extends String> encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = encoding;
        return this;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public Csv withEscapeChar(String escapeChar) {
        Utils.checkNotNull(escapeChar, "escapeChar");
        this.escapeChar = Optional.ofNullable(escapeChar);
        return this;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public Csv withEscapeChar(Optional<? extends String> escapeChar) {
        Utils.checkNotNull(escapeChar, "escapeChar");
        this.escapeChar = escapeChar;
        return this;
    }

    /**
     * Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings
     */
    public Csv withInferDatatypes(boolean inferDatatypes) {
        Utils.checkNotNull(inferDatatypes, "inferDatatypes");
        this.inferDatatypes = Optional.ofNullable(inferDatatypes);
        return this;
    }

    /**
     * Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings
     */
    public Csv withInferDatatypes(Optional<? extends Boolean> inferDatatypes) {
        Utils.checkNotNull(inferDatatypes, "inferDatatypes");
        this.inferDatatypes = inferDatatypes;
        return this;
    }

    /**
     * Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False.
     */
    public Csv withNewlinesInValues(boolean newlinesInValues) {
        Utils.checkNotNull(newlinesInValues, "newlinesInValues");
        this.newlinesInValues = Optional.ofNullable(newlinesInValues);
        return this;
    }

    /**
     * Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False.
     */
    public Csv withNewlinesInValues(Optional<? extends Boolean> newlinesInValues) {
        Utils.checkNotNull(newlinesInValues, "newlinesInValues");
        this.newlinesInValues = newlinesInValues;
        return this;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public Csv withQuoteChar(String quoteChar) {
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.quoteChar = Optional.ofNullable(quoteChar);
        return this;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public Csv withQuoteChar(Optional<? extends String> quoteChar) {
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.quoteChar = quoteChar;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Csv other = (Csv) o;
        return 
            java.util.Objects.deepEquals(this.additionalReaderOptions, other.additionalReaderOptions) &&
            java.util.Objects.deepEquals(this.advancedOptions, other.advancedOptions) &&
            java.util.Objects.deepEquals(this.blockSize, other.blockSize) &&
            java.util.Objects.deepEquals(this.delimiter, other.delimiter) &&
            java.util.Objects.deepEquals(this.doubleQuote, other.doubleQuote) &&
            java.util.Objects.deepEquals(this.encoding, other.encoding) &&
            java.util.Objects.deepEquals(this.escapeChar, other.escapeChar) &&
            java.util.Objects.deepEquals(this.filetype, other.filetype) &&
            java.util.Objects.deepEquals(this.inferDatatypes, other.inferDatatypes) &&
            java.util.Objects.deepEquals(this.newlinesInValues, other.newlinesInValues) &&
            java.util.Objects.deepEquals(this.quoteChar, other.quoteChar);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            additionalReaderOptions,
            advancedOptions,
            blockSize,
            delimiter,
            doubleQuote,
            encoding,
            escapeChar,
            filetype,
            inferDatatypes,
            newlinesInValues,
            quoteChar);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Csv.class,
                "additionalReaderOptions", additionalReaderOptions,
                "advancedOptions", advancedOptions,
                "blockSize", blockSize,
                "delimiter", delimiter,
                "doubleQuote", doubleQuote,
                "encoding", encoding,
                "escapeChar", escapeChar,
                "filetype", filetype,
                "inferDatatypes", inferDatatypes,
                "newlinesInValues", newlinesInValues,
                "quoteChar", quoteChar);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> additionalReaderOptions = Optional.empty();
 
        private Optional<? extends String> advancedOptions = Optional.empty();
 
        private Optional<? extends Long> blockSize;
 
        private Optional<? extends String> delimiter;
 
        private Optional<? extends Boolean> doubleQuote;
 
        private Optional<? extends String> encoding;
 
        private Optional<? extends String> escapeChar = Optional.empty();
 
        private Optional<? extends Boolean> inferDatatypes;
 
        private Optional<? extends Boolean> newlinesInValues;
 
        private Optional<? extends String> quoteChar;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank"&gt;detailed here&lt;/a&gt;. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
         */
        public Builder additionalReaderOptions(String additionalReaderOptions) {
            Utils.checkNotNull(additionalReaderOptions, "additionalReaderOptions");
            this.additionalReaderOptions = Optional.ofNullable(additionalReaderOptions);
            return this;
        }

        /**
         * Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank"&gt;detailed here&lt;/a&gt;. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
         */
        public Builder additionalReaderOptions(Optional<? extends String> additionalReaderOptions) {
            Utils.checkNotNull(additionalReaderOptions, "additionalReaderOptions");
            this.additionalReaderOptions = additionalReaderOptions;
            return this;
        }

        /**
         * Optionally add a valid JSON string here to provide additional &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank"&gt;Pyarrow ReadOptions&lt;/a&gt;. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
         */
        public Builder advancedOptions(String advancedOptions) {
            Utils.checkNotNull(advancedOptions, "advancedOptions");
            this.advancedOptions = Optional.ofNullable(advancedOptions);
            return this;
        }

        /**
         * Optionally add a valid JSON string here to provide additional &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank"&gt;Pyarrow ReadOptions&lt;/a&gt;. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
         */
        public Builder advancedOptions(Optional<? extends String> advancedOptions) {
            Utils.checkNotNull(advancedOptions, "advancedOptions");
            this.advancedOptions = advancedOptions;
            return this;
        }

        /**
         * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
         */
        public Builder blockSize(long blockSize) {
            Utils.checkNotNull(blockSize, "blockSize");
            this.blockSize = Optional.ofNullable(blockSize);
            return this;
        }

        /**
         * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
         */
        public Builder blockSize(Optional<? extends Long> blockSize) {
            Utils.checkNotNull(blockSize, "blockSize");
            this.blockSize = blockSize;
            return this;
        }

        /**
         * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
         */
        public Builder delimiter(String delimiter) {
            Utils.checkNotNull(delimiter, "delimiter");
            this.delimiter = Optional.ofNullable(delimiter);
            return this;
        }

        /**
         * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
         */
        public Builder delimiter(Optional<? extends String> delimiter) {
            Utils.checkNotNull(delimiter, "delimiter");
            this.delimiter = delimiter;
            return this;
        }

        /**
         * Whether two quotes in a quoted CSV value denote a single quote in the data.
         */
        public Builder doubleQuote(boolean doubleQuote) {
            Utils.checkNotNull(doubleQuote, "doubleQuote");
            this.doubleQuote = Optional.ofNullable(doubleQuote);
            return this;
        }

        /**
         * Whether two quotes in a quoted CSV value denote a single quote in the data.
         */
        public Builder doubleQuote(Optional<? extends Boolean> doubleQuote) {
            Utils.checkNotNull(doubleQuote, "doubleQuote");
            this.doubleQuote = doubleQuote;
            return this;
        }

        /**
         * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
         */
        public Builder encoding(String encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = Optional.ofNullable(encoding);
            return this;
        }

        /**
         * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
         */
        public Builder encoding(Optional<? extends String> encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = encoding;
            return this;
        }

        /**
         * The character used for escaping special characters. To disallow escaping, leave this field blank.
         */
        public Builder escapeChar(String escapeChar) {
            Utils.checkNotNull(escapeChar, "escapeChar");
            this.escapeChar = Optional.ofNullable(escapeChar);
            return this;
        }

        /**
         * The character used for escaping special characters. To disallow escaping, leave this field blank.
         */
        public Builder escapeChar(Optional<? extends String> escapeChar) {
            Utils.checkNotNull(escapeChar, "escapeChar");
            this.escapeChar = escapeChar;
            return this;
        }

        /**
         * Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings
         */
        public Builder inferDatatypes(boolean inferDatatypes) {
            Utils.checkNotNull(inferDatatypes, "inferDatatypes");
            this.inferDatatypes = Optional.ofNullable(inferDatatypes);
            return this;
        }

        /**
         * Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings
         */
        public Builder inferDatatypes(Optional<? extends Boolean> inferDatatypes) {
            Utils.checkNotNull(inferDatatypes, "inferDatatypes");
            this.inferDatatypes = inferDatatypes;
            return this;
        }

        /**
         * Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False.
         */
        public Builder newlinesInValues(boolean newlinesInValues) {
            Utils.checkNotNull(newlinesInValues, "newlinesInValues");
            this.newlinesInValues = Optional.ofNullable(newlinesInValues);
            return this;
        }

        /**
         * Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False.
         */
        public Builder newlinesInValues(Optional<? extends Boolean> newlinesInValues) {
            Utils.checkNotNull(newlinesInValues, "newlinesInValues");
            this.newlinesInValues = newlinesInValues;
            return this;
        }

        /**
         * The character used for quoting CSV values. To disallow quoting, make this field blank.
         */
        public Builder quoteChar(String quoteChar) {
            Utils.checkNotNull(quoteChar, "quoteChar");
            this.quoteChar = Optional.ofNullable(quoteChar);
            return this;
        }

        /**
         * The character used for quoting CSV values. To disallow quoting, make this field blank.
         */
        public Builder quoteChar(Optional<? extends String> quoteChar) {
            Utils.checkNotNull(quoteChar, "quoteChar");
            this.quoteChar = quoteChar;
            return this;
        }
        
        public Csv build() {
            if (blockSize == null) {
                blockSize = _SINGLETON_VALUE_BlockSize.value();
            }
            if (delimiter == null) {
                delimiter = _SINGLETON_VALUE_Delimiter.value();
            }
            if (doubleQuote == null) {
                doubleQuote = _SINGLETON_VALUE_DoubleQuote.value();
            }
            if (encoding == null) {
                encoding = _SINGLETON_VALUE_Encoding.value();
            }
            if (inferDatatypes == null) {
                inferDatatypes = _SINGLETON_VALUE_InferDatatypes.value();
            }
            if (newlinesInValues == null) {
                newlinesInValues = _SINGLETON_VALUE_NewlinesInValues.value();
            }
            if (quoteChar == null) {
                quoteChar = _SINGLETON_VALUE_QuoteChar.value();
            }
            return new Csv(
                additionalReaderOptions,
                advancedOptions,
                blockSize,
                delimiter,
                doubleQuote,
                encoding,
                escapeChar,
                inferDatatypes,
                newlinesInValues,
                quoteChar);
        }

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_BlockSize =
                new LazySingletonValue<>(
                        "block_size",
                        "10000",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_Delimiter =
                new LazySingletonValue<>(
                        "delimiter",
                        "\",\"",
                        new TypeReference<Optional<? extends String>>() {});

        private static final LazySingletonValue<Optional<? extends Boolean>> _SINGLETON_VALUE_DoubleQuote =
                new LazySingletonValue<>(
                        "double_quote",
                        "true",
                        new TypeReference<Optional<? extends Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_Encoding =
                new LazySingletonValue<>(
                        "encoding",
                        "\"utf8\"",
                        new TypeReference<Optional<? extends String>>() {});

        private static final LazySingletonValue<Optional<? extends SourceS3SchemasFormatFileFormatFiletype>> _SINGLETON_VALUE_Filetype =
                new LazySingletonValue<>(
                        "filetype",
                        "\"csv\"",
                        new TypeReference<Optional<? extends SourceS3SchemasFormatFileFormatFiletype>>() {});

        private static final LazySingletonValue<Optional<? extends Boolean>> _SINGLETON_VALUE_InferDatatypes =
                new LazySingletonValue<>(
                        "infer_datatypes",
                        "true",
                        new TypeReference<Optional<? extends Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends Boolean>> _SINGLETON_VALUE_NewlinesInValues =
                new LazySingletonValue<>(
                        "newlines_in_values",
                        "false",
                        new TypeReference<Optional<? extends Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_QuoteChar =
                new LazySingletonValue<>(
                        "quote_char",
                        "\"\\\"\"",
                        new TypeReference<Optional<? extends String>>() {});
    }
}

