/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.OffsetDateTime;
import java.util.Optional;

/**
 * S3AmazonWebServices - Deprecated and will be removed soon. Please do not use this field anymore and use bucket, aws_access_key_id, aws_secret_access_key and endpoint instead. Use this to load files from S3 or S3-compatible services
 */

public class S3AmazonWebServices {

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aws_access_key_id")
    private Optional<? extends String> awsAccessKeyId;

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aws_secret_access_key")
    private Optional<? extends String> awsSecretAccessKey;

    /**
     * Name of the S3 bucket where the file(s) exist.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bucket")
    private Optional<? extends String> bucket;

    /**
     * Endpoint to an S3 compatible service. Leave empty to use AWS.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("endpoint")
    private Optional<? extends String> endpoint;

    /**
     * By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("path_prefix")
    private Optional<? extends String> pathPrefix;

    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("role_arn")
    private Optional<? extends String> roleArn;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<? extends OffsetDateTime> startDate;

    public S3AmazonWebServices(
            @JsonProperty("aws_access_key_id") Optional<? extends String> awsAccessKeyId,
            @JsonProperty("aws_secret_access_key") Optional<? extends String> awsSecretAccessKey,
            @JsonProperty("bucket") Optional<? extends String> bucket,
            @JsonProperty("endpoint") Optional<? extends String> endpoint,
            @JsonProperty("path_prefix") Optional<? extends String> pathPrefix,
            @JsonProperty("role_arn") Optional<? extends String> roleArn,
            @JsonProperty("start_date") Optional<? extends OffsetDateTime> startDate) {
        Utils.checkNotNull(awsAccessKeyId, "awsAccessKeyId");
        Utils.checkNotNull(awsSecretAccessKey, "awsSecretAccessKey");
        Utils.checkNotNull(bucket, "bucket");
        Utils.checkNotNull(endpoint, "endpoint");
        Utils.checkNotNull(pathPrefix, "pathPrefix");
        Utils.checkNotNull(roleArn, "roleArn");
        Utils.checkNotNull(startDate, "startDate");
        this.awsAccessKeyId = awsAccessKeyId;
        this.awsSecretAccessKey = awsSecretAccessKey;
        this.bucket = bucket;
        this.endpoint = endpoint;
        this.pathPrefix = pathPrefix;
        this.roleArn = roleArn;
        this.startDate = startDate;
    }

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    public Optional<? extends String> awsAccessKeyId() {
        return awsAccessKeyId;
    }

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    public Optional<? extends String> awsSecretAccessKey() {
        return awsSecretAccessKey;
    }

    /**
     * Name of the S3 bucket where the file(s) exist.
     */
    public Optional<? extends String> bucket() {
        return bucket;
    }

    /**
     * Endpoint to an S3 compatible service. Leave empty to use AWS.
     */
    public Optional<? extends String> endpoint() {
        return endpoint;
    }

    /**
     * By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate.
     */
    public Optional<? extends String> pathPrefix() {
        return pathPrefix;
    }

    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
     */
    public Optional<? extends String> roleArn() {
        return roleArn;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
     */
    public Optional<? extends OffsetDateTime> startDate() {
        return startDate;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    public S3AmazonWebServices withAwsAccessKeyId(String awsAccessKeyId) {
        Utils.checkNotNull(awsAccessKeyId, "awsAccessKeyId");
        this.awsAccessKeyId = Optional.ofNullable(awsAccessKeyId);
        return this;
    }

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    public S3AmazonWebServices withAwsAccessKeyId(Optional<? extends String> awsAccessKeyId) {
        Utils.checkNotNull(awsAccessKeyId, "awsAccessKeyId");
        this.awsAccessKeyId = awsAccessKeyId;
        return this;
    }

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    public S3AmazonWebServices withAwsSecretAccessKey(String awsSecretAccessKey) {
        Utils.checkNotNull(awsSecretAccessKey, "awsSecretAccessKey");
        this.awsSecretAccessKey = Optional.ofNullable(awsSecretAccessKey);
        return this;
    }

    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    public S3AmazonWebServices withAwsSecretAccessKey(Optional<? extends String> awsSecretAccessKey) {
        Utils.checkNotNull(awsSecretAccessKey, "awsSecretAccessKey");
        this.awsSecretAccessKey = awsSecretAccessKey;
        return this;
    }

    /**
     * Name of the S3 bucket where the file(s) exist.
     */
    public S3AmazonWebServices withBucket(String bucket) {
        Utils.checkNotNull(bucket, "bucket");
        this.bucket = Optional.ofNullable(bucket);
        return this;
    }

    /**
     * Name of the S3 bucket where the file(s) exist.
     */
    public S3AmazonWebServices withBucket(Optional<? extends String> bucket) {
        Utils.checkNotNull(bucket, "bucket");
        this.bucket = bucket;
        return this;
    }

    /**
     * Endpoint to an S3 compatible service. Leave empty to use AWS.
     */
    public S3AmazonWebServices withEndpoint(String endpoint) {
        Utils.checkNotNull(endpoint, "endpoint");
        this.endpoint = Optional.ofNullable(endpoint);
        return this;
    }

    /**
     * Endpoint to an S3 compatible service. Leave empty to use AWS.
     */
    public S3AmazonWebServices withEndpoint(Optional<? extends String> endpoint) {
        Utils.checkNotNull(endpoint, "endpoint");
        this.endpoint = endpoint;
        return this;
    }

    /**
     * By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate.
     */
    public S3AmazonWebServices withPathPrefix(String pathPrefix) {
        Utils.checkNotNull(pathPrefix, "pathPrefix");
        this.pathPrefix = Optional.ofNullable(pathPrefix);
        return this;
    }

    /**
     * By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate.
     */
    public S3AmazonWebServices withPathPrefix(Optional<? extends String> pathPrefix) {
        Utils.checkNotNull(pathPrefix, "pathPrefix");
        this.pathPrefix = pathPrefix;
        return this;
    }

    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
     */
    public S3AmazonWebServices withRoleArn(String roleArn) {
        Utils.checkNotNull(roleArn, "roleArn");
        this.roleArn = Optional.ofNullable(roleArn);
        return this;
    }

    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
     */
    public S3AmazonWebServices withRoleArn(Optional<? extends String> roleArn) {
        Utils.checkNotNull(roleArn, "roleArn");
        this.roleArn = roleArn;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
     */
    public S3AmazonWebServices withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
     */
    public S3AmazonWebServices withStartDate(Optional<? extends OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        S3AmazonWebServices other = (S3AmazonWebServices) o;
        return 
            java.util.Objects.deepEquals(this.awsAccessKeyId, other.awsAccessKeyId) &&
            java.util.Objects.deepEquals(this.awsSecretAccessKey, other.awsSecretAccessKey) &&
            java.util.Objects.deepEquals(this.bucket, other.bucket) &&
            java.util.Objects.deepEquals(this.endpoint, other.endpoint) &&
            java.util.Objects.deepEquals(this.pathPrefix, other.pathPrefix) &&
            java.util.Objects.deepEquals(this.roleArn, other.roleArn) &&
            java.util.Objects.deepEquals(this.startDate, other.startDate);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            awsAccessKeyId,
            awsSecretAccessKey,
            bucket,
            endpoint,
            pathPrefix,
            roleArn,
            startDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(S3AmazonWebServices.class,
                "awsAccessKeyId", awsAccessKeyId,
                "awsSecretAccessKey", awsSecretAccessKey,
                "bucket", bucket,
                "endpoint", endpoint,
                "pathPrefix", pathPrefix,
                "roleArn", roleArn,
                "startDate", startDate);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> awsAccessKeyId = Optional.empty();
 
        private Optional<? extends String> awsSecretAccessKey = Optional.empty();
 
        private Optional<? extends String> bucket = Optional.empty();
 
        private Optional<? extends String> endpoint;
 
        private Optional<? extends String> pathPrefix;
 
        private Optional<? extends String> roleArn = Optional.empty();
 
        private Optional<? extends OffsetDateTime> startDate = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
         */
        public Builder awsAccessKeyId(String awsAccessKeyId) {
            Utils.checkNotNull(awsAccessKeyId, "awsAccessKeyId");
            this.awsAccessKeyId = Optional.ofNullable(awsAccessKeyId);
            return this;
        }

        /**
         * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
         */
        public Builder awsAccessKeyId(Optional<? extends String> awsAccessKeyId) {
            Utils.checkNotNull(awsAccessKeyId, "awsAccessKeyId");
            this.awsAccessKeyId = awsAccessKeyId;
            return this;
        }

        /**
         * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
         */
        public Builder awsSecretAccessKey(String awsSecretAccessKey) {
            Utils.checkNotNull(awsSecretAccessKey, "awsSecretAccessKey");
            this.awsSecretAccessKey = Optional.ofNullable(awsSecretAccessKey);
            return this;
        }

        /**
         * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
         */
        public Builder awsSecretAccessKey(Optional<? extends String> awsSecretAccessKey) {
            Utils.checkNotNull(awsSecretAccessKey, "awsSecretAccessKey");
            this.awsSecretAccessKey = awsSecretAccessKey;
            return this;
        }

        /**
         * Name of the S3 bucket where the file(s) exist.
         */
        public Builder bucket(String bucket) {
            Utils.checkNotNull(bucket, "bucket");
            this.bucket = Optional.ofNullable(bucket);
            return this;
        }

        /**
         * Name of the S3 bucket where the file(s) exist.
         */
        public Builder bucket(Optional<? extends String> bucket) {
            Utils.checkNotNull(bucket, "bucket");
            this.bucket = bucket;
            return this;
        }

        /**
         * Endpoint to an S3 compatible service. Leave empty to use AWS.
         */
        public Builder endpoint(String endpoint) {
            Utils.checkNotNull(endpoint, "endpoint");
            this.endpoint = Optional.ofNullable(endpoint);
            return this;
        }

        /**
         * Endpoint to an S3 compatible service. Leave empty to use AWS.
         */
        public Builder endpoint(Optional<? extends String> endpoint) {
            Utils.checkNotNull(endpoint, "endpoint");
            this.endpoint = endpoint;
            return this;
        }

        /**
         * By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate.
         */
        public Builder pathPrefix(String pathPrefix) {
            Utils.checkNotNull(pathPrefix, "pathPrefix");
            this.pathPrefix = Optional.ofNullable(pathPrefix);
            return this;
        }

        /**
         * By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate.
         */
        public Builder pathPrefix(Optional<? extends String> pathPrefix) {
            Utils.checkNotNull(pathPrefix, "pathPrefix");
            this.pathPrefix = pathPrefix;
            return this;
        }

        /**
         * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
         */
        public Builder roleArn(String roleArn) {
            Utils.checkNotNull(roleArn, "roleArn");
            this.roleArn = Optional.ofNullable(roleArn);
            return this;
        }

        /**
         * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
         */
        public Builder roleArn(Optional<? extends String> roleArn) {
            Utils.checkNotNull(roleArn, "roleArn");
            this.roleArn = roleArn;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(Optional<? extends OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }
        
        public S3AmazonWebServices build() {
            if (endpoint == null) {
                endpoint = _SINGLETON_VALUE_Endpoint.value();
            }
            if (pathPrefix == null) {
                pathPrefix = _SINGLETON_VALUE_PathPrefix.value();
            }
            return new S3AmazonWebServices(
                awsAccessKeyId,
                awsSecretAccessKey,
                bucket,
                endpoint,
                pathPrefix,
                roleArn,
                startDate);
        }

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_Endpoint =
                new LazySingletonValue<>(
                        "endpoint",
                        "\"\"",
                        new TypeReference<Optional<? extends String>>() {});

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_PathPrefix =
                new LazySingletonValue<>(
                        "path_prefix",
                        "\"\"",
                        new TypeReference<Optional<? extends String>>() {});
    }
}

