/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.Objects;
import java.util.Optional;


public class SourceStripe {

    /**
     * Your Stripe account ID (starts with 'acct_', find yours &lt;a href="https://dashboard.stripe.com/settings/account"&gt;here&lt;/a&gt;).
     */
    @JsonProperty("account_id")
    private String accountId;

    /**
     * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("call_rate_limit")
    private Optional<Long> callRateLimit;

    /**
     * Stripe API key (usually starts with 'sk_live_'; find yours &lt;a href="https://dashboard.stripe.com/apikeys"&gt;here&lt;/a&gt;).
     */
    @JsonProperty("client_secret")
    private String clientSecret;

    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info &lt;a href="https://docs.airbyte.com/integrations/sources/stripe#requirements"&gt;here&lt;/a&gt;
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lookback_window_days")
    private Optional<Long> lookbackWindowDays;

    /**
     * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("num_workers")
    private Optional<Long> numWorkers;

    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("slice_range")
    private Optional<Long> sliceRange;

    @JsonProperty("sourceType")
    private Stripe sourceType;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<OffsetDateTime> startDate;

    @JsonCreator
    public SourceStripe(
            @JsonProperty("account_id") String accountId,
            @JsonProperty("call_rate_limit") Optional<Long> callRateLimit,
            @JsonProperty("client_secret") String clientSecret,
            @JsonProperty("lookback_window_days") Optional<Long> lookbackWindowDays,
            @JsonProperty("num_workers") Optional<Long> numWorkers,
            @JsonProperty("slice_range") Optional<Long> sliceRange,
            @JsonProperty("start_date") Optional<OffsetDateTime> startDate) {
        Utils.checkNotNull(accountId, "accountId");
        Utils.checkNotNull(callRateLimit, "callRateLimit");
        Utils.checkNotNull(clientSecret, "clientSecret");
        Utils.checkNotNull(lookbackWindowDays, "lookbackWindowDays");
        Utils.checkNotNull(numWorkers, "numWorkers");
        Utils.checkNotNull(sliceRange, "sliceRange");
        Utils.checkNotNull(startDate, "startDate");
        this.accountId = accountId;
        this.callRateLimit = callRateLimit;
        this.clientSecret = clientSecret;
        this.lookbackWindowDays = lookbackWindowDays;
        this.numWorkers = numWorkers;
        this.sliceRange = sliceRange;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
    }
    
    public SourceStripe(
            String accountId,
            String clientSecret) {
        this(accountId, Optional.empty(), clientSecret, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Your Stripe account ID (starts with 'acct_', find yours &lt;a href="https://dashboard.stripe.com/settings/account"&gt;here&lt;/a&gt;).
     */
    @JsonIgnore
    public String accountId() {
        return accountId;
    }

    /**
     * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
     */
    @JsonIgnore
    public Optional<Long> callRateLimit() {
        return callRateLimit;
    }

    /**
     * Stripe API key (usually starts with 'sk_live_'; find yours &lt;a href="https://dashboard.stripe.com/apikeys"&gt;here&lt;/a&gt;).
     */
    @JsonIgnore
    public String clientSecret() {
        return clientSecret;
    }

    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info &lt;a href="https://docs.airbyte.com/integrations/sources/stripe#requirements"&gt;here&lt;/a&gt;
     */
    @JsonIgnore
    public Optional<Long> lookbackWindowDays() {
        return lookbackWindowDays;
    }

    /**
     * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account.
     */
    @JsonIgnore
    public Optional<Long> numWorkers() {
        return numWorkers;
    }

    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
     */
    @JsonIgnore
    public Optional<Long> sliceRange() {
        return sliceRange;
    }

    @JsonIgnore
    public Stripe sourceType() {
        return sourceType;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> startDate() {
        return startDate;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Your Stripe account ID (starts with 'acct_', find yours &lt;a href="https://dashboard.stripe.com/settings/account"&gt;here&lt;/a&gt;).
     */
    public SourceStripe withAccountId(String accountId) {
        Utils.checkNotNull(accountId, "accountId");
        this.accountId = accountId;
        return this;
    }

    /**
     * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
     */
    public SourceStripe withCallRateLimit(long callRateLimit) {
        Utils.checkNotNull(callRateLimit, "callRateLimit");
        this.callRateLimit = Optional.ofNullable(callRateLimit);
        return this;
    }

    /**
     * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
     */
    public SourceStripe withCallRateLimit(Optional<Long> callRateLimit) {
        Utils.checkNotNull(callRateLimit, "callRateLimit");
        this.callRateLimit = callRateLimit;
        return this;
    }

    /**
     * Stripe API key (usually starts with 'sk_live_'; find yours &lt;a href="https://dashboard.stripe.com/apikeys"&gt;here&lt;/a&gt;).
     */
    public SourceStripe withClientSecret(String clientSecret) {
        Utils.checkNotNull(clientSecret, "clientSecret");
        this.clientSecret = clientSecret;
        return this;
    }

    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info &lt;a href="https://docs.airbyte.com/integrations/sources/stripe#requirements"&gt;here&lt;/a&gt;
     */
    public SourceStripe withLookbackWindowDays(long lookbackWindowDays) {
        Utils.checkNotNull(lookbackWindowDays, "lookbackWindowDays");
        this.lookbackWindowDays = Optional.ofNullable(lookbackWindowDays);
        return this;
    }

    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info &lt;a href="https://docs.airbyte.com/integrations/sources/stripe#requirements"&gt;here&lt;/a&gt;
     */
    public SourceStripe withLookbackWindowDays(Optional<Long> lookbackWindowDays) {
        Utils.checkNotNull(lookbackWindowDays, "lookbackWindowDays");
        this.lookbackWindowDays = lookbackWindowDays;
        return this;
    }

    /**
     * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account.
     */
    public SourceStripe withNumWorkers(long numWorkers) {
        Utils.checkNotNull(numWorkers, "numWorkers");
        this.numWorkers = Optional.ofNullable(numWorkers);
        return this;
    }

    /**
     * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account.
     */
    public SourceStripe withNumWorkers(Optional<Long> numWorkers) {
        Utils.checkNotNull(numWorkers, "numWorkers");
        this.numWorkers = numWorkers;
        return this;
    }

    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
     */
    public SourceStripe withSliceRange(long sliceRange) {
        Utils.checkNotNull(sliceRange, "sliceRange");
        this.sliceRange = Optional.ofNullable(sliceRange);
        return this;
    }

    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
     */
    public SourceStripe withSliceRange(Optional<Long> sliceRange) {
        Utils.checkNotNull(sliceRange, "sliceRange");
        this.sliceRange = sliceRange;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
     */
    public SourceStripe withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
     */
    public SourceStripe withStartDate(Optional<OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceStripe other = (SourceStripe) o;
        return 
            Objects.deepEquals(this.accountId, other.accountId) &&
            Objects.deepEquals(this.callRateLimit, other.callRateLimit) &&
            Objects.deepEquals(this.clientSecret, other.clientSecret) &&
            Objects.deepEquals(this.lookbackWindowDays, other.lookbackWindowDays) &&
            Objects.deepEquals(this.numWorkers, other.numWorkers) &&
            Objects.deepEquals(this.sliceRange, other.sliceRange) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.startDate, other.startDate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            accountId,
            callRateLimit,
            clientSecret,
            lookbackWindowDays,
            numWorkers,
            sliceRange,
            sourceType,
            startDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceStripe.class,
                "accountId", accountId,
                "callRateLimit", callRateLimit,
                "clientSecret", clientSecret,
                "lookbackWindowDays", lookbackWindowDays,
                "numWorkers", numWorkers,
                "sliceRange", sliceRange,
                "sourceType", sourceType,
                "startDate", startDate);
    }
    
    public final static class Builder {
 
        private String accountId;
 
        private Optional<Long> callRateLimit = Optional.empty();
 
        private String clientSecret;
 
        private Optional<Long> lookbackWindowDays;
 
        private Optional<Long> numWorkers;
 
        private Optional<Long> sliceRange;
 
        private Optional<OffsetDateTime> startDate;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Your Stripe account ID (starts with 'acct_', find yours &lt;a href="https://dashboard.stripe.com/settings/account"&gt;here&lt;/a&gt;).
         */
        public Builder accountId(String accountId) {
            Utils.checkNotNull(accountId, "accountId");
            this.accountId = accountId;
            return this;
        }

        /**
         * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
         */
        public Builder callRateLimit(long callRateLimit) {
            Utils.checkNotNull(callRateLimit, "callRateLimit");
            this.callRateLimit = Optional.ofNullable(callRateLimit);
            return this;
        }

        /**
         * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
         */
        public Builder callRateLimit(Optional<Long> callRateLimit) {
            Utils.checkNotNull(callRateLimit, "callRateLimit");
            this.callRateLimit = callRateLimit;
            return this;
        }

        /**
         * Stripe API key (usually starts with 'sk_live_'; find yours &lt;a href="https://dashboard.stripe.com/apikeys"&gt;here&lt;/a&gt;).
         */
        public Builder clientSecret(String clientSecret) {
            Utils.checkNotNull(clientSecret, "clientSecret");
            this.clientSecret = clientSecret;
            return this;
        }

        /**
         * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info &lt;a href="https://docs.airbyte.com/integrations/sources/stripe#requirements"&gt;here&lt;/a&gt;
         */
        public Builder lookbackWindowDays(long lookbackWindowDays) {
            Utils.checkNotNull(lookbackWindowDays, "lookbackWindowDays");
            this.lookbackWindowDays = Optional.ofNullable(lookbackWindowDays);
            return this;
        }

        /**
         * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info &lt;a href="https://docs.airbyte.com/integrations/sources/stripe#requirements"&gt;here&lt;/a&gt;
         */
        public Builder lookbackWindowDays(Optional<Long> lookbackWindowDays) {
            Utils.checkNotNull(lookbackWindowDays, "lookbackWindowDays");
            this.lookbackWindowDays = lookbackWindowDays;
            return this;
        }

        /**
         * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account.
         */
        public Builder numWorkers(long numWorkers) {
            Utils.checkNotNull(numWorkers, "numWorkers");
            this.numWorkers = Optional.ofNullable(numWorkers);
            return this;
        }

        /**
         * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account.
         */
        public Builder numWorkers(Optional<Long> numWorkers) {
            Utils.checkNotNull(numWorkers, "numWorkers");
            this.numWorkers = numWorkers;
            return this;
        }

        /**
         * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
         */
        public Builder sliceRange(long sliceRange) {
            Utils.checkNotNull(sliceRange, "sliceRange");
            this.sliceRange = Optional.ofNullable(sliceRange);
            return this;
        }

        /**
         * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
         */
        public Builder sliceRange(Optional<Long> sliceRange) {
            Utils.checkNotNull(sliceRange, "sliceRange");
            this.sliceRange = sliceRange;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
         */
        public Builder startDate(Optional<OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }
        
        public SourceStripe build() {
            if (lookbackWindowDays == null) {
                lookbackWindowDays = _SINGLETON_VALUE_LookbackWindowDays.value();
            }
            if (numWorkers == null) {
                numWorkers = _SINGLETON_VALUE_NumWorkers.value();
            }
            if (sliceRange == null) {
                sliceRange = _SINGLETON_VALUE_SliceRange.value();
            }
            if (startDate == null) {
                startDate = _SINGLETON_VALUE_StartDate.value();
            }            return new SourceStripe(
                accountId,
                callRateLimit,
                clientSecret,
                lookbackWindowDays,
                numWorkers,
                sliceRange,
                startDate);
        }

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_LookbackWindowDays =
                new LazySingletonValue<>(
                        "lookback_window_days",
                        "0",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_NumWorkers =
                new LazySingletonValue<>(
                        "num_workers",
                        "10",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_SliceRange =
                new LazySingletonValue<>(
                        "slice_range",
                        "365",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Stripe> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"stripe\"",
                        new TypeReference<Stripe>() {});

        private static final LazySingletonValue<Optional<OffsetDateTime>> _SINGLETON_VALUE_StartDate =
                new LazySingletonValue<>(
                        "start_date",
                        "\"2017-01-25T00:00:00Z\"",
                        new TypeReference<Optional<OffsetDateTime>>() {});
    }
}

