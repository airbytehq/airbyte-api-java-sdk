/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;

public class DestinationPostgres {

    /**
     * Name of the database.
     */
    @JsonProperty("database")
    private String database;

    @JsonProperty("destinationType")
    private Postgres destinationType;

    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("disable_type_dedupe")
    private Optional<Boolean> disableTypeDedupe;

    /**
     * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("drop_cascade")
    private Optional<Boolean> dropCascade;

    /**
     * Hostname of the database.
     */
    @JsonProperty("host")
    private String host;

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jdbc_url_params")
    private Optional<String> jdbcUrlParams;

    /**
     * Password associated with the username.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("password")
    private Optional<String> password;

    /**
     * Port of the database.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("port")
    private Optional<Long> port;

    /**
     * The schema to write raw tables into
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("raw_data_schema")
    private Optional<String> rawDataSchema;

    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schema")
    private Optional<String> schema;

    /**
     * Encrypt data using SSL. When activating SSL, please select one of the connection modes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ssl")
    private Optional<Boolean> ssl;

    /**
     * SSL connection modes. 
     *  &lt;b&gt;disable&lt;/b&gt; - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  &lt;b&gt;allow&lt;/b&gt; - Chose this mode to enable encryption only when required by the source database
     *  &lt;b&gt;prefer&lt;/b&gt; - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     *  &lt;b&gt;require&lt;/b&gt; - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     *   &lt;b&gt;verify-ca&lt;/b&gt; - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     *   &lt;b&gt;verify-full&lt;/b&gt; - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     *  See more information - &lt;a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"&gt; in the docs&lt;/a&gt;.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ssl_mode")
    private Optional<? extends SSLModes> sslMode;

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tunnel_method")
    private Optional<? extends DestinationPostgresSSHTunnelMethod> tunnelMethod;

    /**
     * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unconstrained_number")
    private Optional<Boolean> unconstrainedNumber;

    /**
     * Username to use to access the database.
     */
    @JsonProperty("username")
    private String username;

    @JsonCreator
    public DestinationPostgres(
            @JsonProperty("database") String database,
            @JsonProperty("disable_type_dedupe") Optional<Boolean> disableTypeDedupe,
            @JsonProperty("drop_cascade") Optional<Boolean> dropCascade,
            @JsonProperty("host") String host,
            @JsonProperty("jdbc_url_params") Optional<String> jdbcUrlParams,
            @JsonProperty("password") Optional<String> password,
            @JsonProperty("port") Optional<Long> port,
            @JsonProperty("raw_data_schema") Optional<String> rawDataSchema,
            @JsonProperty("schema") Optional<String> schema,
            @JsonProperty("ssl") Optional<Boolean> ssl,
            @JsonProperty("ssl_mode") Optional<? extends SSLModes> sslMode,
            @JsonProperty("tunnel_method") Optional<? extends DestinationPostgresSSHTunnelMethod> tunnelMethod,
            @JsonProperty("unconstrained_number") Optional<Boolean> unconstrainedNumber,
            @JsonProperty("username") String username) {
        Utils.checkNotNull(database, "database");
        Utils.checkNotNull(disableTypeDedupe, "disableTypeDedupe");
        Utils.checkNotNull(dropCascade, "dropCascade");
        Utils.checkNotNull(host, "host");
        Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
        Utils.checkNotNull(password, "password");
        Utils.checkNotNull(port, "port");
        Utils.checkNotNull(rawDataSchema, "rawDataSchema");
        Utils.checkNotNull(schema, "schema");
        Utils.checkNotNull(ssl, "ssl");
        Utils.checkNotNull(sslMode, "sslMode");
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        Utils.checkNotNull(unconstrainedNumber, "unconstrainedNumber");
        Utils.checkNotNull(username, "username");
        this.database = database;
        this.destinationType = Builder._SINGLETON_VALUE_DestinationType.value();
        this.disableTypeDedupe = disableTypeDedupe;
        this.dropCascade = dropCascade;
        this.host = host;
        this.jdbcUrlParams = jdbcUrlParams;
        this.password = password;
        this.port = port;
        this.rawDataSchema = rawDataSchema;
        this.schema = schema;
        this.ssl = ssl;
        this.sslMode = sslMode;
        this.tunnelMethod = tunnelMethod;
        this.unconstrainedNumber = unconstrainedNumber;
        this.username = username;
    }
    
    public DestinationPostgres(
            String database,
            String host,
            String username) {
        this(database, Optional.empty(), Optional.empty(), host, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), username);
    }

    /**
     * Name of the database.
     */
    @JsonIgnore
    public String database() {
        return database;
    }

    @JsonIgnore
    public Postgres destinationType() {
        return destinationType;
    }

    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
     */
    @JsonIgnore
    public Optional<Boolean> disableTypeDedupe() {
        return disableTypeDedupe;
    }

    /**
     * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
     */
    @JsonIgnore
    public Optional<Boolean> dropCascade() {
        return dropCascade;
    }

    /**
     * Hostname of the database.
     */
    @JsonIgnore
    public String host() {
        return host;
    }

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    @JsonIgnore
    public Optional<String> jdbcUrlParams() {
        return jdbcUrlParams;
    }

    /**
     * Password associated with the username.
     */
    @JsonIgnore
    public Optional<String> password() {
        return password;
    }

    /**
     * Port of the database.
     */
    @JsonIgnore
    public Optional<Long> port() {
        return port;
    }

    /**
     * The schema to write raw tables into
     */
    @JsonIgnore
    public Optional<String> rawDataSchema() {
        return rawDataSchema;
    }

    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    @JsonIgnore
    public Optional<String> schema() {
        return schema;
    }

    /**
     * Encrypt data using SSL. When activating SSL, please select one of the connection modes.
     */
    @JsonIgnore
    public Optional<Boolean> ssl() {
        return ssl;
    }

    /**
     * SSL connection modes. 
     *  &lt;b&gt;disable&lt;/b&gt; - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  &lt;b&gt;allow&lt;/b&gt; - Chose this mode to enable encryption only when required by the source database
     *  &lt;b&gt;prefer&lt;/b&gt; - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     *  &lt;b&gt;require&lt;/b&gt; - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     *   &lt;b&gt;verify-ca&lt;/b&gt; - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     *   &lt;b&gt;verify-full&lt;/b&gt; - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     *  See more information - &lt;a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"&gt; in the docs&lt;/a&gt;.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SSLModes> sslMode() {
        return (Optional<SSLModes>) sslMode;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DestinationPostgresSSHTunnelMethod> tunnelMethod() {
        return (Optional<DestinationPostgresSSHTunnelMethod>) tunnelMethod;
    }

    /**
     * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
     */
    @JsonIgnore
    public Optional<Boolean> unconstrainedNumber() {
        return unconstrainedNumber;
    }

    /**
     * Username to use to access the database.
     */
    @JsonIgnore
    public String username() {
        return username;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Name of the database.
     */
    public DestinationPostgres withDatabase(String database) {
        Utils.checkNotNull(database, "database");
        this.database = database;
        return this;
    }

    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
     */
    public DestinationPostgres withDisableTypeDedupe(boolean disableTypeDedupe) {
        Utils.checkNotNull(disableTypeDedupe, "disableTypeDedupe");
        this.disableTypeDedupe = Optional.ofNullable(disableTypeDedupe);
        return this;
    }

    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
     */
    public DestinationPostgres withDisableTypeDedupe(Optional<Boolean> disableTypeDedupe) {
        Utils.checkNotNull(disableTypeDedupe, "disableTypeDedupe");
        this.disableTypeDedupe = disableTypeDedupe;
        return this;
    }

    /**
     * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
     */
    public DestinationPostgres withDropCascade(boolean dropCascade) {
        Utils.checkNotNull(dropCascade, "dropCascade");
        this.dropCascade = Optional.ofNullable(dropCascade);
        return this;
    }

    /**
     * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
     */
    public DestinationPostgres withDropCascade(Optional<Boolean> dropCascade) {
        Utils.checkNotNull(dropCascade, "dropCascade");
        this.dropCascade = dropCascade;
        return this;
    }

    /**
     * Hostname of the database.
     */
    public DestinationPostgres withHost(String host) {
        Utils.checkNotNull(host, "host");
        this.host = host;
        return this;
    }

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    public DestinationPostgres withJdbcUrlParams(String jdbcUrlParams) {
        Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
        this.jdbcUrlParams = Optional.ofNullable(jdbcUrlParams);
        return this;
    }

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    public DestinationPostgres withJdbcUrlParams(Optional<String> jdbcUrlParams) {
        Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
        this.jdbcUrlParams = jdbcUrlParams;
        return this;
    }

    /**
     * Password associated with the username.
     */
    public DestinationPostgres withPassword(String password) {
        Utils.checkNotNull(password, "password");
        this.password = Optional.ofNullable(password);
        return this;
    }

    /**
     * Password associated with the username.
     */
    public DestinationPostgres withPassword(Optional<String> password) {
        Utils.checkNotNull(password, "password");
        this.password = password;
        return this;
    }

    /**
     * Port of the database.
     */
    public DestinationPostgres withPort(long port) {
        Utils.checkNotNull(port, "port");
        this.port = Optional.ofNullable(port);
        return this;
    }

    /**
     * Port of the database.
     */
    public DestinationPostgres withPort(Optional<Long> port) {
        Utils.checkNotNull(port, "port");
        this.port = port;
        return this;
    }

    /**
     * The schema to write raw tables into
     */
    public DestinationPostgres withRawDataSchema(String rawDataSchema) {
        Utils.checkNotNull(rawDataSchema, "rawDataSchema");
        this.rawDataSchema = Optional.ofNullable(rawDataSchema);
        return this;
    }

    /**
     * The schema to write raw tables into
     */
    public DestinationPostgres withRawDataSchema(Optional<String> rawDataSchema) {
        Utils.checkNotNull(rawDataSchema, "rawDataSchema");
        this.rawDataSchema = rawDataSchema;
        return this;
    }

    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    public DestinationPostgres withSchema(String schema) {
        Utils.checkNotNull(schema, "schema");
        this.schema = Optional.ofNullable(schema);
        return this;
    }

    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
     */
    public DestinationPostgres withSchema(Optional<String> schema) {
        Utils.checkNotNull(schema, "schema");
        this.schema = schema;
        return this;
    }

    /**
     * Encrypt data using SSL. When activating SSL, please select one of the connection modes.
     */
    public DestinationPostgres withSsl(boolean ssl) {
        Utils.checkNotNull(ssl, "ssl");
        this.ssl = Optional.ofNullable(ssl);
        return this;
    }

    /**
     * Encrypt data using SSL. When activating SSL, please select one of the connection modes.
     */
    public DestinationPostgres withSsl(Optional<Boolean> ssl) {
        Utils.checkNotNull(ssl, "ssl");
        this.ssl = ssl;
        return this;
    }

    /**
     * SSL connection modes. 
     *  &lt;b&gt;disable&lt;/b&gt; - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  &lt;b&gt;allow&lt;/b&gt; - Chose this mode to enable encryption only when required by the source database
     *  &lt;b&gt;prefer&lt;/b&gt; - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     *  &lt;b&gt;require&lt;/b&gt; - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     *   &lt;b&gt;verify-ca&lt;/b&gt; - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     *   &lt;b&gt;verify-full&lt;/b&gt; - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     *  See more information - &lt;a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"&gt; in the docs&lt;/a&gt;.
     */
    public DestinationPostgres withSslMode(SSLModes sslMode) {
        Utils.checkNotNull(sslMode, "sslMode");
        this.sslMode = Optional.ofNullable(sslMode);
        return this;
    }

    /**
     * SSL connection modes. 
     *  &lt;b&gt;disable&lt;/b&gt; - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  &lt;b&gt;allow&lt;/b&gt; - Chose this mode to enable encryption only when required by the source database
     *  &lt;b&gt;prefer&lt;/b&gt; - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     *  &lt;b&gt;require&lt;/b&gt; - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     *   &lt;b&gt;verify-ca&lt;/b&gt; - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     *   &lt;b&gt;verify-full&lt;/b&gt; - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     *  See more information - &lt;a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"&gt; in the docs&lt;/a&gt;.
     */
    public DestinationPostgres withSslMode(Optional<? extends SSLModes> sslMode) {
        Utils.checkNotNull(sslMode, "sslMode");
        this.sslMode = sslMode;
        return this;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    public DestinationPostgres withTunnelMethod(DestinationPostgresSSHTunnelMethod tunnelMethod) {
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        this.tunnelMethod = Optional.ofNullable(tunnelMethod);
        return this;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    public DestinationPostgres withTunnelMethod(Optional<? extends DestinationPostgresSSHTunnelMethod> tunnelMethod) {
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        this.tunnelMethod = tunnelMethod;
        return this;
    }

    /**
     * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
     */
    public DestinationPostgres withUnconstrainedNumber(boolean unconstrainedNumber) {
        Utils.checkNotNull(unconstrainedNumber, "unconstrainedNumber");
        this.unconstrainedNumber = Optional.ofNullable(unconstrainedNumber);
        return this;
    }

    /**
     * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
     */
    public DestinationPostgres withUnconstrainedNumber(Optional<Boolean> unconstrainedNumber) {
        Utils.checkNotNull(unconstrainedNumber, "unconstrainedNumber");
        this.unconstrainedNumber = unconstrainedNumber;
        return this;
    }

    /**
     * Username to use to access the database.
     */
    public DestinationPostgres withUsername(String username) {
        Utils.checkNotNull(username, "username");
        this.username = username;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DestinationPostgres other = (DestinationPostgres) o;
        return 
            Objects.deepEquals(this.database, other.database) &&
            Objects.deepEquals(this.destinationType, other.destinationType) &&
            Objects.deepEquals(this.disableTypeDedupe, other.disableTypeDedupe) &&
            Objects.deepEquals(this.dropCascade, other.dropCascade) &&
            Objects.deepEquals(this.host, other.host) &&
            Objects.deepEquals(this.jdbcUrlParams, other.jdbcUrlParams) &&
            Objects.deepEquals(this.password, other.password) &&
            Objects.deepEquals(this.port, other.port) &&
            Objects.deepEquals(this.rawDataSchema, other.rawDataSchema) &&
            Objects.deepEquals(this.schema, other.schema) &&
            Objects.deepEquals(this.ssl, other.ssl) &&
            Objects.deepEquals(this.sslMode, other.sslMode) &&
            Objects.deepEquals(this.tunnelMethod, other.tunnelMethod) &&
            Objects.deepEquals(this.unconstrainedNumber, other.unconstrainedNumber) &&
            Objects.deepEquals(this.username, other.username);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            database,
            destinationType,
            disableTypeDedupe,
            dropCascade,
            host,
            jdbcUrlParams,
            password,
            port,
            rawDataSchema,
            schema,
            ssl,
            sslMode,
            tunnelMethod,
            unconstrainedNumber,
            username);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DestinationPostgres.class,
                "database", database,
                "destinationType", destinationType,
                "disableTypeDedupe", disableTypeDedupe,
                "dropCascade", dropCascade,
                "host", host,
                "jdbcUrlParams", jdbcUrlParams,
                "password", password,
                "port", port,
                "rawDataSchema", rawDataSchema,
                "schema", schema,
                "ssl", ssl,
                "sslMode", sslMode,
                "tunnelMethod", tunnelMethod,
                "unconstrainedNumber", unconstrainedNumber,
                "username", username);
    }
    
    public final static class Builder {
 
        private String database;
 
        private Optional<Boolean> disableTypeDedupe;
 
        private Optional<Boolean> dropCascade;
 
        private String host;
 
        private Optional<String> jdbcUrlParams = Optional.empty();
 
        private Optional<String> password = Optional.empty();
 
        private Optional<Long> port;
 
        private Optional<String> rawDataSchema = Optional.empty();
 
        private Optional<String> schema;
 
        private Optional<Boolean> ssl;
 
        private Optional<? extends SSLModes> sslMode = Optional.empty();
 
        private Optional<? extends DestinationPostgresSSHTunnelMethod> tunnelMethod = Optional.empty();
 
        private Optional<Boolean> unconstrainedNumber;
 
        private String username;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Name of the database.
         */
        public Builder database(String database) {
            Utils.checkNotNull(database, "database");
            this.database = database;
            return this;
        }

        /**
         * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
         */
        public Builder disableTypeDedupe(boolean disableTypeDedupe) {
            Utils.checkNotNull(disableTypeDedupe, "disableTypeDedupe");
            this.disableTypeDedupe = Optional.ofNullable(disableTypeDedupe);
            return this;
        }

        /**
         * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
         */
        public Builder disableTypeDedupe(Optional<Boolean> disableTypeDedupe) {
            Utils.checkNotNull(disableTypeDedupe, "disableTypeDedupe");
            this.disableTypeDedupe = disableTypeDedupe;
            return this;
        }

        /**
         * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
         */
        public Builder dropCascade(boolean dropCascade) {
            Utils.checkNotNull(dropCascade, "dropCascade");
            this.dropCascade = Optional.ofNullable(dropCascade);
            return this;
        }

        /**
         * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
         */
        public Builder dropCascade(Optional<Boolean> dropCascade) {
            Utils.checkNotNull(dropCascade, "dropCascade");
            this.dropCascade = dropCascade;
            return this;
        }

        /**
         * Hostname of the database.
         */
        public Builder host(String host) {
            Utils.checkNotNull(host, "host");
            this.host = host;
            return this;
        }

        /**
         * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
         */
        public Builder jdbcUrlParams(String jdbcUrlParams) {
            Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
            this.jdbcUrlParams = Optional.ofNullable(jdbcUrlParams);
            return this;
        }

        /**
         * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
         */
        public Builder jdbcUrlParams(Optional<String> jdbcUrlParams) {
            Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
            this.jdbcUrlParams = jdbcUrlParams;
            return this;
        }

        /**
         * Password associated with the username.
         */
        public Builder password(String password) {
            Utils.checkNotNull(password, "password");
            this.password = Optional.ofNullable(password);
            return this;
        }

        /**
         * Password associated with the username.
         */
        public Builder password(Optional<String> password) {
            Utils.checkNotNull(password, "password");
            this.password = password;
            return this;
        }

        /**
         * Port of the database.
         */
        public Builder port(long port) {
            Utils.checkNotNull(port, "port");
            this.port = Optional.ofNullable(port);
            return this;
        }

        /**
         * Port of the database.
         */
        public Builder port(Optional<Long> port) {
            Utils.checkNotNull(port, "port");
            this.port = port;
            return this;
        }

        /**
         * The schema to write raw tables into
         */
        public Builder rawDataSchema(String rawDataSchema) {
            Utils.checkNotNull(rawDataSchema, "rawDataSchema");
            this.rawDataSchema = Optional.ofNullable(rawDataSchema);
            return this;
        }

        /**
         * The schema to write raw tables into
         */
        public Builder rawDataSchema(Optional<String> rawDataSchema) {
            Utils.checkNotNull(rawDataSchema, "rawDataSchema");
            this.rawDataSchema = rawDataSchema;
            return this;
        }

        /**
         * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
         */
        public Builder schema(String schema) {
            Utils.checkNotNull(schema, "schema");
            this.schema = Optional.ofNullable(schema);
            return this;
        }

        /**
         * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
         */
        public Builder schema(Optional<String> schema) {
            Utils.checkNotNull(schema, "schema");
            this.schema = schema;
            return this;
        }

        /**
         * Encrypt data using SSL. When activating SSL, please select one of the connection modes.
         */
        public Builder ssl(boolean ssl) {
            Utils.checkNotNull(ssl, "ssl");
            this.ssl = Optional.ofNullable(ssl);
            return this;
        }

        /**
         * Encrypt data using SSL. When activating SSL, please select one of the connection modes.
         */
        public Builder ssl(Optional<Boolean> ssl) {
            Utils.checkNotNull(ssl, "ssl");
            this.ssl = ssl;
            return this;
        }

        /**
         * SSL connection modes. 
         *  &lt;b&gt;disable&lt;/b&gt; - Chose this mode to disable encryption of communication between Airbyte and destination database
         *  &lt;b&gt;allow&lt;/b&gt; - Chose this mode to enable encryption only when required by the source database
         *  &lt;b&gt;prefer&lt;/b&gt; - Chose this mode to allow unencrypted connection only if the source database does not support encryption
         *  &lt;b&gt;require&lt;/b&gt; - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
         *   &lt;b&gt;verify-ca&lt;/b&gt; - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
         *   &lt;b&gt;verify-full&lt;/b&gt; - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
         *  See more information - &lt;a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"&gt; in the docs&lt;/a&gt;.
         */
        public Builder sslMode(SSLModes sslMode) {
            Utils.checkNotNull(sslMode, "sslMode");
            this.sslMode = Optional.ofNullable(sslMode);
            return this;
        }

        /**
         * SSL connection modes. 
         *  &lt;b&gt;disable&lt;/b&gt; - Chose this mode to disable encryption of communication between Airbyte and destination database
         *  &lt;b&gt;allow&lt;/b&gt; - Chose this mode to enable encryption only when required by the source database
         *  &lt;b&gt;prefer&lt;/b&gt; - Chose this mode to allow unencrypted connection only if the source database does not support encryption
         *  &lt;b&gt;require&lt;/b&gt; - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
         *   &lt;b&gt;verify-ca&lt;/b&gt; - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
         *   &lt;b&gt;verify-full&lt;/b&gt; - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
         *  See more information - &lt;a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"&gt; in the docs&lt;/a&gt;.
         */
        public Builder sslMode(Optional<? extends SSLModes> sslMode) {
            Utils.checkNotNull(sslMode, "sslMode");
            this.sslMode = sslMode;
            return this;
        }

        /**
         * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
         */
        public Builder tunnelMethod(DestinationPostgresSSHTunnelMethod tunnelMethod) {
            Utils.checkNotNull(tunnelMethod, "tunnelMethod");
            this.tunnelMethod = Optional.ofNullable(tunnelMethod);
            return this;
        }

        /**
         * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
         */
        public Builder tunnelMethod(Optional<? extends DestinationPostgresSSHTunnelMethod> tunnelMethod) {
            Utils.checkNotNull(tunnelMethod, "tunnelMethod");
            this.tunnelMethod = tunnelMethod;
            return this;
        }

        /**
         * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
         */
        public Builder unconstrainedNumber(boolean unconstrainedNumber) {
            Utils.checkNotNull(unconstrainedNumber, "unconstrainedNumber");
            this.unconstrainedNumber = Optional.ofNullable(unconstrainedNumber);
            return this;
        }

        /**
         * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
         */
        public Builder unconstrainedNumber(Optional<Boolean> unconstrainedNumber) {
            Utils.checkNotNull(unconstrainedNumber, "unconstrainedNumber");
            this.unconstrainedNumber = unconstrainedNumber;
            return this;
        }

        /**
         * Username to use to access the database.
         */
        public Builder username(String username) {
            Utils.checkNotNull(username, "username");
            this.username = username;
            return this;
        }
        
        public DestinationPostgres build() {
            if (disableTypeDedupe == null) {
                disableTypeDedupe = _SINGLETON_VALUE_DisableTypeDedupe.value();
            }
            if (dropCascade == null) {
                dropCascade = _SINGLETON_VALUE_DropCascade.value();
            }
            if (port == null) {
                port = _SINGLETON_VALUE_Port.value();
            }
            if (schema == null) {
                schema = _SINGLETON_VALUE_Schema.value();
            }
            if (ssl == null) {
                ssl = _SINGLETON_VALUE_Ssl.value();
            }
            if (unconstrainedNumber == null) {
                unconstrainedNumber = _SINGLETON_VALUE_UnconstrainedNumber.value();
            }
            return new DestinationPostgres(
                database,
                disableTypeDedupe,
                dropCascade,
                host,
                jdbcUrlParams,
                password,
                port,
                rawDataSchema,
                schema,
                ssl,
                sslMode,
                tunnelMethod,
                unconstrainedNumber,
                username);
        }

        private static final LazySingletonValue<Postgres> _SINGLETON_VALUE_DestinationType =
                new LazySingletonValue<>(
                        "destinationType",
                        "\"postgres\"",
                        new TypeReference<Postgres>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_DisableTypeDedupe =
                new LazySingletonValue<>(
                        "disable_type_dedupe",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_DropCascade =
                new LazySingletonValue<>(
                        "drop_cascade",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_Port =
                new LazySingletonValue<>(
                        "port",
                        "5432",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Schema =
                new LazySingletonValue<>(
                        "schema",
                        "\"public\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_Ssl =
                new LazySingletonValue<>(
                        "ssl",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_UnconstrainedNumber =
                new LazySingletonValue<>(
                        "unconstrained_number",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});
    }
}
