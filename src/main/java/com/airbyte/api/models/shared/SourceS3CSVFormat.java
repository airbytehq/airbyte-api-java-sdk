/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class SourceS3CSVFormat {

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("delimiter")
    private Optional<String> delimiter;

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("double_quote")
    private Optional<Boolean> doubleQuote;

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("encoding")
    private Optional<String> encoding;

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("escape_char")
    private Optional<String> escapeChar;

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("false_values")
    private Optional<? extends List<String>> falseValues;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filetype")
    private Optional<? extends SourceS3SchemasFiletype> filetype;

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("header_definition")
    private Optional<? extends SourceS3CSVHeaderDefinition> headerDefinition;

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ignore_errors_on_fields_mismatch")
    private Optional<Boolean> ignoreErrorsOnFieldsMismatch;

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("null_values")
    private Optional<? extends List<String>> nullValues;

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("quote_char")
    private Optional<String> quoteChar;

    /**
     * The number of rows to skip after the header row.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_rows_after_header")
    private Optional<Long> skipRowsAfterHeader;

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_rows_before_header")
    private Optional<Long> skipRowsBeforeHeader;

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("strings_can_be_null")
    private Optional<Boolean> stringsCanBeNull;

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("true_values")
    private Optional<? extends List<String>> trueValues;

    @JsonCreator
    public SourceS3CSVFormat(
            @JsonProperty("delimiter") Optional<String> delimiter,
            @JsonProperty("double_quote") Optional<Boolean> doubleQuote,
            @JsonProperty("encoding") Optional<String> encoding,
            @JsonProperty("escape_char") Optional<String> escapeChar,
            @JsonProperty("false_values") Optional<? extends List<String>> falseValues,
            @JsonProperty("header_definition") Optional<? extends SourceS3CSVHeaderDefinition> headerDefinition,
            @JsonProperty("ignore_errors_on_fields_mismatch") Optional<Boolean> ignoreErrorsOnFieldsMismatch,
            @JsonProperty("null_values") Optional<? extends List<String>> nullValues,
            @JsonProperty("quote_char") Optional<String> quoteChar,
            @JsonProperty("skip_rows_after_header") Optional<Long> skipRowsAfterHeader,
            @JsonProperty("skip_rows_before_header") Optional<Long> skipRowsBeforeHeader,
            @JsonProperty("strings_can_be_null") Optional<Boolean> stringsCanBeNull,
            @JsonProperty("true_values") Optional<? extends List<String>> trueValues) {
        Utils.checkNotNull(delimiter, "delimiter");
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        Utils.checkNotNull(encoding, "encoding");
        Utils.checkNotNull(escapeChar, "escapeChar");
        Utils.checkNotNull(falseValues, "falseValues");
        Utils.checkNotNull(headerDefinition, "headerDefinition");
        Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
        Utils.checkNotNull(nullValues, "nullValues");
        Utils.checkNotNull(quoteChar, "quoteChar");
        Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
        Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
        Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
        Utils.checkNotNull(trueValues, "trueValues");
        this.delimiter = delimiter;
        this.doubleQuote = doubleQuote;
        this.encoding = encoding;
        this.escapeChar = escapeChar;
        this.falseValues = falseValues;
        this.filetype = Builder._SINGLETON_VALUE_Filetype.value();
        this.headerDefinition = headerDefinition;
        this.ignoreErrorsOnFieldsMismatch = ignoreErrorsOnFieldsMismatch;
        this.nullValues = nullValues;
        this.quoteChar = quoteChar;
        this.skipRowsAfterHeader = skipRowsAfterHeader;
        this.skipRowsBeforeHeader = skipRowsBeforeHeader;
        this.stringsCanBeNull = stringsCanBeNull;
        this.trueValues = trueValues;
    }
    
    public SourceS3CSVFormat() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    @JsonIgnore
    public Optional<String> delimiter() {
        return delimiter;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    @JsonIgnore
    public Optional<Boolean> doubleQuote() {
        return doubleQuote;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    @JsonIgnore
    public Optional<String> encoding() {
        return encoding;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    @JsonIgnore
    public Optional<String> escapeChar() {
        return escapeChar;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> falseValues() {
        return (Optional<List<String>>) falseValues;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceS3SchemasFiletype> filetype() {
        return (Optional<SourceS3SchemasFiletype>) filetype;
    }

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceS3CSVHeaderDefinition> headerDefinition() {
        return (Optional<SourceS3CSVHeaderDefinition>) headerDefinition;
    }

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    @JsonIgnore
    public Optional<Boolean> ignoreErrorsOnFieldsMismatch() {
        return ignoreErrorsOnFieldsMismatch;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> nullValues() {
        return (Optional<List<String>>) nullValues;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    @JsonIgnore
    public Optional<String> quoteChar() {
        return quoteChar;
    }

    /**
     * The number of rows to skip after the header row.
     */
    @JsonIgnore
    public Optional<Long> skipRowsAfterHeader() {
        return skipRowsAfterHeader;
    }

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    @JsonIgnore
    public Optional<Long> skipRowsBeforeHeader() {
        return skipRowsBeforeHeader;
    }

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    @JsonIgnore
    public Optional<Boolean> stringsCanBeNull() {
        return stringsCanBeNull;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> trueValues() {
        return (Optional<List<String>>) trueValues;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public SourceS3CSVFormat withDelimiter(String delimiter) {
        Utils.checkNotNull(delimiter, "delimiter");
        this.delimiter = Optional.ofNullable(delimiter);
        return this;
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public SourceS3CSVFormat withDelimiter(Optional<String> delimiter) {
        Utils.checkNotNull(delimiter, "delimiter");
        this.delimiter = delimiter;
        return this;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public SourceS3CSVFormat withDoubleQuote(boolean doubleQuote) {
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        this.doubleQuote = Optional.ofNullable(doubleQuote);
        return this;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public SourceS3CSVFormat withDoubleQuote(Optional<Boolean> doubleQuote) {
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        this.doubleQuote = doubleQuote;
        return this;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public SourceS3CSVFormat withEncoding(String encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = Optional.ofNullable(encoding);
        return this;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public SourceS3CSVFormat withEncoding(Optional<String> encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = encoding;
        return this;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public SourceS3CSVFormat withEscapeChar(String escapeChar) {
        Utils.checkNotNull(escapeChar, "escapeChar");
        this.escapeChar = Optional.ofNullable(escapeChar);
        return this;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public SourceS3CSVFormat withEscapeChar(Optional<String> escapeChar) {
        Utils.checkNotNull(escapeChar, "escapeChar");
        this.escapeChar = escapeChar;
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    public SourceS3CSVFormat withFalseValues(List<String> falseValues) {
        Utils.checkNotNull(falseValues, "falseValues");
        this.falseValues = Optional.ofNullable(falseValues);
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    public SourceS3CSVFormat withFalseValues(Optional<? extends List<String>> falseValues) {
        Utils.checkNotNull(falseValues, "falseValues");
        this.falseValues = falseValues;
        return this;
    }

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    public SourceS3CSVFormat withHeaderDefinition(SourceS3CSVHeaderDefinition headerDefinition) {
        Utils.checkNotNull(headerDefinition, "headerDefinition");
        this.headerDefinition = Optional.ofNullable(headerDefinition);
        return this;
    }

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    public SourceS3CSVFormat withHeaderDefinition(Optional<? extends SourceS3CSVHeaderDefinition> headerDefinition) {
        Utils.checkNotNull(headerDefinition, "headerDefinition");
        this.headerDefinition = headerDefinition;
        return this;
    }

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    public SourceS3CSVFormat withIgnoreErrorsOnFieldsMismatch(boolean ignoreErrorsOnFieldsMismatch) {
        Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
        this.ignoreErrorsOnFieldsMismatch = Optional.ofNullable(ignoreErrorsOnFieldsMismatch);
        return this;
    }

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    public SourceS3CSVFormat withIgnoreErrorsOnFieldsMismatch(Optional<Boolean> ignoreErrorsOnFieldsMismatch) {
        Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
        this.ignoreErrorsOnFieldsMismatch = ignoreErrorsOnFieldsMismatch;
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    public SourceS3CSVFormat withNullValues(List<String> nullValues) {
        Utils.checkNotNull(nullValues, "nullValues");
        this.nullValues = Optional.ofNullable(nullValues);
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    public SourceS3CSVFormat withNullValues(Optional<? extends List<String>> nullValues) {
        Utils.checkNotNull(nullValues, "nullValues");
        this.nullValues = nullValues;
        return this;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public SourceS3CSVFormat withQuoteChar(String quoteChar) {
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.quoteChar = Optional.ofNullable(quoteChar);
        return this;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public SourceS3CSVFormat withQuoteChar(Optional<String> quoteChar) {
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.quoteChar = quoteChar;
        return this;
    }

    /**
     * The number of rows to skip after the header row.
     */
    public SourceS3CSVFormat withSkipRowsAfterHeader(long skipRowsAfterHeader) {
        Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
        this.skipRowsAfterHeader = Optional.ofNullable(skipRowsAfterHeader);
        return this;
    }

    /**
     * The number of rows to skip after the header row.
     */
    public SourceS3CSVFormat withSkipRowsAfterHeader(Optional<Long> skipRowsAfterHeader) {
        Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
        this.skipRowsAfterHeader = skipRowsAfterHeader;
        return this;
    }

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    public SourceS3CSVFormat withSkipRowsBeforeHeader(long skipRowsBeforeHeader) {
        Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
        this.skipRowsBeforeHeader = Optional.ofNullable(skipRowsBeforeHeader);
        return this;
    }

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    public SourceS3CSVFormat withSkipRowsBeforeHeader(Optional<Long> skipRowsBeforeHeader) {
        Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
        this.skipRowsBeforeHeader = skipRowsBeforeHeader;
        return this;
    }

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    public SourceS3CSVFormat withStringsCanBeNull(boolean stringsCanBeNull) {
        Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
        this.stringsCanBeNull = Optional.ofNullable(stringsCanBeNull);
        return this;
    }

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    public SourceS3CSVFormat withStringsCanBeNull(Optional<Boolean> stringsCanBeNull) {
        Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
        this.stringsCanBeNull = stringsCanBeNull;
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    public SourceS3CSVFormat withTrueValues(List<String> trueValues) {
        Utils.checkNotNull(trueValues, "trueValues");
        this.trueValues = Optional.ofNullable(trueValues);
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    public SourceS3CSVFormat withTrueValues(Optional<? extends List<String>> trueValues) {
        Utils.checkNotNull(trueValues, "trueValues");
        this.trueValues = trueValues;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceS3CSVFormat other = (SourceS3CSVFormat) o;
        return 
            Objects.deepEquals(this.delimiter, other.delimiter) &&
            Objects.deepEquals(this.doubleQuote, other.doubleQuote) &&
            Objects.deepEquals(this.encoding, other.encoding) &&
            Objects.deepEquals(this.escapeChar, other.escapeChar) &&
            Objects.deepEquals(this.falseValues, other.falseValues) &&
            Objects.deepEquals(this.filetype, other.filetype) &&
            Objects.deepEquals(this.headerDefinition, other.headerDefinition) &&
            Objects.deepEquals(this.ignoreErrorsOnFieldsMismatch, other.ignoreErrorsOnFieldsMismatch) &&
            Objects.deepEquals(this.nullValues, other.nullValues) &&
            Objects.deepEquals(this.quoteChar, other.quoteChar) &&
            Objects.deepEquals(this.skipRowsAfterHeader, other.skipRowsAfterHeader) &&
            Objects.deepEquals(this.skipRowsBeforeHeader, other.skipRowsBeforeHeader) &&
            Objects.deepEquals(this.stringsCanBeNull, other.stringsCanBeNull) &&
            Objects.deepEquals(this.trueValues, other.trueValues);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            delimiter,
            doubleQuote,
            encoding,
            escapeChar,
            falseValues,
            filetype,
            headerDefinition,
            ignoreErrorsOnFieldsMismatch,
            nullValues,
            quoteChar,
            skipRowsAfterHeader,
            skipRowsBeforeHeader,
            stringsCanBeNull,
            trueValues);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceS3CSVFormat.class,
                "delimiter", delimiter,
                "doubleQuote", doubleQuote,
                "encoding", encoding,
                "escapeChar", escapeChar,
                "falseValues", falseValues,
                "filetype", filetype,
                "headerDefinition", headerDefinition,
                "ignoreErrorsOnFieldsMismatch", ignoreErrorsOnFieldsMismatch,
                "nullValues", nullValues,
                "quoteChar", quoteChar,
                "skipRowsAfterHeader", skipRowsAfterHeader,
                "skipRowsBeforeHeader", skipRowsBeforeHeader,
                "stringsCanBeNull", stringsCanBeNull,
                "trueValues", trueValues);
    }
    
    public final static class Builder {
 
        private Optional<String> delimiter;
 
        private Optional<Boolean> doubleQuote;
 
        private Optional<String> encoding;
 
        private Optional<String> escapeChar = Optional.empty();
 
        private Optional<? extends List<String>> falseValues = Optional.empty();
 
        private Optional<? extends SourceS3CSVHeaderDefinition> headerDefinition = Optional.empty();
 
        private Optional<Boolean> ignoreErrorsOnFieldsMismatch;
 
        private Optional<? extends List<String>> nullValues = Optional.empty();
 
        private Optional<String> quoteChar;
 
        private Optional<Long> skipRowsAfterHeader;
 
        private Optional<Long> skipRowsBeforeHeader;
 
        private Optional<Boolean> stringsCanBeNull;
 
        private Optional<? extends List<String>> trueValues = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
         */
        public Builder delimiter(String delimiter) {
            Utils.checkNotNull(delimiter, "delimiter");
            this.delimiter = Optional.ofNullable(delimiter);
            return this;
        }

        /**
         * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
         */
        public Builder delimiter(Optional<String> delimiter) {
            Utils.checkNotNull(delimiter, "delimiter");
            this.delimiter = delimiter;
            return this;
        }

        /**
         * Whether two quotes in a quoted CSV value denote a single quote in the data.
         */
        public Builder doubleQuote(boolean doubleQuote) {
            Utils.checkNotNull(doubleQuote, "doubleQuote");
            this.doubleQuote = Optional.ofNullable(doubleQuote);
            return this;
        }

        /**
         * Whether two quotes in a quoted CSV value denote a single quote in the data.
         */
        public Builder doubleQuote(Optional<Boolean> doubleQuote) {
            Utils.checkNotNull(doubleQuote, "doubleQuote");
            this.doubleQuote = doubleQuote;
            return this;
        }

        /**
         * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
         */
        public Builder encoding(String encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = Optional.ofNullable(encoding);
            return this;
        }

        /**
         * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
         */
        public Builder encoding(Optional<String> encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = encoding;
            return this;
        }

        /**
         * The character used for escaping special characters. To disallow escaping, leave this field blank.
         */
        public Builder escapeChar(String escapeChar) {
            Utils.checkNotNull(escapeChar, "escapeChar");
            this.escapeChar = Optional.ofNullable(escapeChar);
            return this;
        }

        /**
         * The character used for escaping special characters. To disallow escaping, leave this field blank.
         */
        public Builder escapeChar(Optional<String> escapeChar) {
            Utils.checkNotNull(escapeChar, "escapeChar");
            this.escapeChar = escapeChar;
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as false values.
         */
        public Builder falseValues(List<String> falseValues) {
            Utils.checkNotNull(falseValues, "falseValues");
            this.falseValues = Optional.ofNullable(falseValues);
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as false values.
         */
        public Builder falseValues(Optional<? extends List<String>> falseValues) {
            Utils.checkNotNull(falseValues, "falseValues");
            this.falseValues = falseValues;
            return this;
        }

        /**
         * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
         */
        public Builder headerDefinition(SourceS3CSVHeaderDefinition headerDefinition) {
            Utils.checkNotNull(headerDefinition, "headerDefinition");
            this.headerDefinition = Optional.ofNullable(headerDefinition);
            return this;
        }

        /**
         * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
         */
        public Builder headerDefinition(Optional<? extends SourceS3CSVHeaderDefinition> headerDefinition) {
            Utils.checkNotNull(headerDefinition, "headerDefinition");
            this.headerDefinition = headerDefinition;
            return this;
        }

        /**
         * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
         */
        public Builder ignoreErrorsOnFieldsMismatch(boolean ignoreErrorsOnFieldsMismatch) {
            Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
            this.ignoreErrorsOnFieldsMismatch = Optional.ofNullable(ignoreErrorsOnFieldsMismatch);
            return this;
        }

        /**
         * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
         */
        public Builder ignoreErrorsOnFieldsMismatch(Optional<Boolean> ignoreErrorsOnFieldsMismatch) {
            Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
            this.ignoreErrorsOnFieldsMismatch = ignoreErrorsOnFieldsMismatch;
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
         */
        public Builder nullValues(List<String> nullValues) {
            Utils.checkNotNull(nullValues, "nullValues");
            this.nullValues = Optional.ofNullable(nullValues);
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
         */
        public Builder nullValues(Optional<? extends List<String>> nullValues) {
            Utils.checkNotNull(nullValues, "nullValues");
            this.nullValues = nullValues;
            return this;
        }

        /**
         * The character used for quoting CSV values. To disallow quoting, make this field blank.
         */
        public Builder quoteChar(String quoteChar) {
            Utils.checkNotNull(quoteChar, "quoteChar");
            this.quoteChar = Optional.ofNullable(quoteChar);
            return this;
        }

        /**
         * The character used for quoting CSV values. To disallow quoting, make this field blank.
         */
        public Builder quoteChar(Optional<String> quoteChar) {
            Utils.checkNotNull(quoteChar, "quoteChar");
            this.quoteChar = quoteChar;
            return this;
        }

        /**
         * The number of rows to skip after the header row.
         */
        public Builder skipRowsAfterHeader(long skipRowsAfterHeader) {
            Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
            this.skipRowsAfterHeader = Optional.ofNullable(skipRowsAfterHeader);
            return this;
        }

        /**
         * The number of rows to skip after the header row.
         */
        public Builder skipRowsAfterHeader(Optional<Long> skipRowsAfterHeader) {
            Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
            this.skipRowsAfterHeader = skipRowsAfterHeader;
            return this;
        }

        /**
         * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
         */
        public Builder skipRowsBeforeHeader(long skipRowsBeforeHeader) {
            Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
            this.skipRowsBeforeHeader = Optional.ofNullable(skipRowsBeforeHeader);
            return this;
        }

        /**
         * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
         */
        public Builder skipRowsBeforeHeader(Optional<Long> skipRowsBeforeHeader) {
            Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
            this.skipRowsBeforeHeader = skipRowsBeforeHeader;
            return this;
        }

        /**
         * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
         */
        public Builder stringsCanBeNull(boolean stringsCanBeNull) {
            Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
            this.stringsCanBeNull = Optional.ofNullable(stringsCanBeNull);
            return this;
        }

        /**
         * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
         */
        public Builder stringsCanBeNull(Optional<Boolean> stringsCanBeNull) {
            Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
            this.stringsCanBeNull = stringsCanBeNull;
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as true values.
         */
        public Builder trueValues(List<String> trueValues) {
            Utils.checkNotNull(trueValues, "trueValues");
            this.trueValues = Optional.ofNullable(trueValues);
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as true values.
         */
        public Builder trueValues(Optional<? extends List<String>> trueValues) {
            Utils.checkNotNull(trueValues, "trueValues");
            this.trueValues = trueValues;
            return this;
        }
        
        public SourceS3CSVFormat build() {
            if (delimiter == null) {
                delimiter = _SINGLETON_VALUE_Delimiter.value();
            }
            if (doubleQuote == null) {
                doubleQuote = _SINGLETON_VALUE_DoubleQuote.value();
            }
            if (encoding == null) {
                encoding = _SINGLETON_VALUE_Encoding.value();
            }
            if (ignoreErrorsOnFieldsMismatch == null) {
                ignoreErrorsOnFieldsMismatch = _SINGLETON_VALUE_IgnoreErrorsOnFieldsMismatch.value();
            }
            if (quoteChar == null) {
                quoteChar = _SINGLETON_VALUE_QuoteChar.value();
            }
            if (skipRowsAfterHeader == null) {
                skipRowsAfterHeader = _SINGLETON_VALUE_SkipRowsAfterHeader.value();
            }
            if (skipRowsBeforeHeader == null) {
                skipRowsBeforeHeader = _SINGLETON_VALUE_SkipRowsBeforeHeader.value();
            }
            if (stringsCanBeNull == null) {
                stringsCanBeNull = _SINGLETON_VALUE_StringsCanBeNull.value();
            }
            return new SourceS3CSVFormat(
                delimiter,
                doubleQuote,
                encoding,
                escapeChar,
                falseValues,
                headerDefinition,
                ignoreErrorsOnFieldsMismatch,
                nullValues,
                quoteChar,
                skipRowsAfterHeader,
                skipRowsBeforeHeader,
                stringsCanBeNull,
                trueValues);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Delimiter =
                new LazySingletonValue<>(
                        "delimiter",
                        "\",\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_DoubleQuote =
                new LazySingletonValue<>(
                        "double_quote",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Encoding =
                new LazySingletonValue<>(
                        "encoding",
                        "\"utf8\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<? extends SourceS3SchemasFiletype>> _SINGLETON_VALUE_Filetype =
                new LazySingletonValue<>(
                        "filetype",
                        "\"csv\"",
                        new TypeReference<Optional<? extends SourceS3SchemasFiletype>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_IgnoreErrorsOnFieldsMismatch =
                new LazySingletonValue<>(
                        "ignore_errors_on_fields_mismatch",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_QuoteChar =
                new LazySingletonValue<>(
                        "quote_char",
                        "\"\\\"\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_SkipRowsAfterHeader =
                new LazySingletonValue<>(
                        "skip_rows_after_header",
                        "0",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_SkipRowsBeforeHeader =
                new LazySingletonValue<>(
                        "skip_rows_before_header",
                        "0",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_StringsCanBeNull =
                new LazySingletonValue<>(
                        "strings_can_be_null",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});
    }
}
