/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;

public class SourceBabelforce {

    /**
     * The Babelforce access key ID
     */
    @JsonProperty("access_key_id")
    private String accessKeyId;

    /**
     * The Babelforce access token
     */
    @JsonProperty("access_token")
    private String accessToken;

    /**
     * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("date_created_from")
    private Optional<Long> dateCreatedFrom;

    /**
     * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("date_created_to")
    private Optional<Long> dateCreatedTo;

    /**
     * Babelforce region
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("region")
    private Optional<? extends SourceBabelforceRegion> region;

    @JsonProperty("sourceType")
    private Babelforce sourceType;

    @JsonCreator
    public SourceBabelforce(
            @JsonProperty("access_key_id") String accessKeyId,
            @JsonProperty("access_token") String accessToken,
            @JsonProperty("date_created_from") Optional<Long> dateCreatedFrom,
            @JsonProperty("date_created_to") Optional<Long> dateCreatedTo,
            @JsonProperty("region") Optional<? extends SourceBabelforceRegion> region) {
        Utils.checkNotNull(accessKeyId, "accessKeyId");
        Utils.checkNotNull(accessToken, "accessToken");
        Utils.checkNotNull(dateCreatedFrom, "dateCreatedFrom");
        Utils.checkNotNull(dateCreatedTo, "dateCreatedTo");
        Utils.checkNotNull(region, "region");
        this.accessKeyId = accessKeyId;
        this.accessToken = accessToken;
        this.dateCreatedFrom = dateCreatedFrom;
        this.dateCreatedTo = dateCreatedTo;
        this.region = region;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
    }
    
    public SourceBabelforce(
            String accessKeyId,
            String accessToken) {
        this(accessKeyId, accessToken, Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The Babelforce access key ID
     */
    @JsonIgnore
    public String accessKeyId() {
        return accessKeyId;
    }

    /**
     * The Babelforce access token
     */
    @JsonIgnore
    public String accessToken() {
        return accessToken;
    }

    /**
     * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    @JsonIgnore
    public Optional<Long> dateCreatedFrom() {
        return dateCreatedFrom;
    }

    /**
     * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    @JsonIgnore
    public Optional<Long> dateCreatedTo() {
        return dateCreatedTo;
    }

    /**
     * Babelforce region
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceBabelforceRegion> region() {
        return (Optional<SourceBabelforceRegion>) region;
    }

    @JsonIgnore
    public Babelforce sourceType() {
        return sourceType;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The Babelforce access key ID
     */
    public SourceBabelforce withAccessKeyId(String accessKeyId) {
        Utils.checkNotNull(accessKeyId, "accessKeyId");
        this.accessKeyId = accessKeyId;
        return this;
    }

    /**
     * The Babelforce access token
     */
    public SourceBabelforce withAccessToken(String accessToken) {
        Utils.checkNotNull(accessToken, "accessToken");
        this.accessToken = accessToken;
        return this;
    }

    /**
     * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    public SourceBabelforce withDateCreatedFrom(long dateCreatedFrom) {
        Utils.checkNotNull(dateCreatedFrom, "dateCreatedFrom");
        this.dateCreatedFrom = Optional.ofNullable(dateCreatedFrom);
        return this;
    }

    /**
     * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    public SourceBabelforce withDateCreatedFrom(Optional<Long> dateCreatedFrom) {
        Utils.checkNotNull(dateCreatedFrom, "dateCreatedFrom");
        this.dateCreatedFrom = dateCreatedFrom;
        return this;
    }

    /**
     * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    public SourceBabelforce withDateCreatedTo(long dateCreatedTo) {
        Utils.checkNotNull(dateCreatedTo, "dateCreatedTo");
        this.dateCreatedTo = Optional.ofNullable(dateCreatedTo);
        return this;
    }

    /**
     * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    public SourceBabelforce withDateCreatedTo(Optional<Long> dateCreatedTo) {
        Utils.checkNotNull(dateCreatedTo, "dateCreatedTo");
        this.dateCreatedTo = dateCreatedTo;
        return this;
    }

    /**
     * Babelforce region
     */
    public SourceBabelforce withRegion(SourceBabelforceRegion region) {
        Utils.checkNotNull(region, "region");
        this.region = Optional.ofNullable(region);
        return this;
    }

    /**
     * Babelforce region
     */
    public SourceBabelforce withRegion(Optional<? extends SourceBabelforceRegion> region) {
        Utils.checkNotNull(region, "region");
        this.region = region;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceBabelforce other = (SourceBabelforce) o;
        return 
            Objects.deepEquals(this.accessKeyId, other.accessKeyId) &&
            Objects.deepEquals(this.accessToken, other.accessToken) &&
            Objects.deepEquals(this.dateCreatedFrom, other.dateCreatedFrom) &&
            Objects.deepEquals(this.dateCreatedTo, other.dateCreatedTo) &&
            Objects.deepEquals(this.region, other.region) &&
            Objects.deepEquals(this.sourceType, other.sourceType);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            accessKeyId,
            accessToken,
            dateCreatedFrom,
            dateCreatedTo,
            region,
            sourceType);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceBabelforce.class,
                "accessKeyId", accessKeyId,
                "accessToken", accessToken,
                "dateCreatedFrom", dateCreatedFrom,
                "dateCreatedTo", dateCreatedTo,
                "region", region,
                "sourceType", sourceType);
    }
    
    public final static class Builder {
 
        private String accessKeyId;
 
        private String accessToken;
 
        private Optional<Long> dateCreatedFrom = Optional.empty();
 
        private Optional<Long> dateCreatedTo = Optional.empty();
 
        private Optional<? extends SourceBabelforceRegion> region;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The Babelforce access key ID
         */
        public Builder accessKeyId(String accessKeyId) {
            Utils.checkNotNull(accessKeyId, "accessKeyId");
            this.accessKeyId = accessKeyId;
            return this;
        }

        /**
         * The Babelforce access token
         */
        public Builder accessToken(String accessToken) {
            Utils.checkNotNull(accessToken, "accessToken");
            this.accessToken = accessToken;
            return this;
        }

        /**
         * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
         */
        public Builder dateCreatedFrom(long dateCreatedFrom) {
            Utils.checkNotNull(dateCreatedFrom, "dateCreatedFrom");
            this.dateCreatedFrom = Optional.ofNullable(dateCreatedFrom);
            return this;
        }

        /**
         * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
         */
        public Builder dateCreatedFrom(Optional<Long> dateCreatedFrom) {
            Utils.checkNotNull(dateCreatedFrom, "dateCreatedFrom");
            this.dateCreatedFrom = dateCreatedFrom;
            return this;
        }

        /**
         * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
         */
        public Builder dateCreatedTo(long dateCreatedTo) {
            Utils.checkNotNull(dateCreatedTo, "dateCreatedTo");
            this.dateCreatedTo = Optional.ofNullable(dateCreatedTo);
            return this;
        }

        /**
         * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
         */
        public Builder dateCreatedTo(Optional<Long> dateCreatedTo) {
            Utils.checkNotNull(dateCreatedTo, "dateCreatedTo");
            this.dateCreatedTo = dateCreatedTo;
            return this;
        }

        /**
         * Babelforce region
         */
        public Builder region(SourceBabelforceRegion region) {
            Utils.checkNotNull(region, "region");
            this.region = Optional.ofNullable(region);
            return this;
        }

        /**
         * Babelforce region
         */
        public Builder region(Optional<? extends SourceBabelforceRegion> region) {
            Utils.checkNotNull(region, "region");
            this.region = region;
            return this;
        }
        
        public SourceBabelforce build() {
            if (region == null) {
                region = _SINGLETON_VALUE_Region.value();
            }
            return new SourceBabelforce(
                accessKeyId,
                accessToken,
                dateCreatedFrom,
                dateCreatedTo,
                region);
        }

        private static final LazySingletonValue<Optional<? extends SourceBabelforceRegion>> _SINGLETON_VALUE_Region =
                new LazySingletonValue<>(
                        "region",
                        "\"services\"",
                        new TypeReference<Optional<? extends SourceBabelforceRegion>>() {});

        private static final LazySingletonValue<Babelforce> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"babelforce\"",
                        new TypeReference<Babelforce>() {});
    }
}
