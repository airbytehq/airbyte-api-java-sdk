/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.OffsetDateTime;
import java.util.Optional;

public class SourceQuickbooksOAuth20 {

    /**
     * Access token for making authenticated requests.
     */
    @JsonProperty("access_token")
    private String accessToken;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_type")
    private Optional<? extends SourceQuickbooksAuthType> authType;

    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonProperty("client_id")
    private String clientId;

    /**
     *  Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonProperty("client_secret")
    private String clientSecret;

    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    @JsonProperty("realm_id")
    private String realmId;

    /**
     * A token used when refreshing the access token.
     */
    @JsonProperty("refresh_token")
    private String refreshToken;

    /**
     * The date-time when the access token should be refreshed.
     */
    @JsonProperty("token_expiry_date")
    private OffsetDateTime tokenExpiryDate;

    @JsonCreator
    public SourceQuickbooksOAuth20(
            @JsonProperty("access_token") String accessToken,
            @JsonProperty("client_id") String clientId,
            @JsonProperty("client_secret") String clientSecret,
            @JsonProperty("realm_id") String realmId,
            @JsonProperty("refresh_token") String refreshToken,
            @JsonProperty("token_expiry_date") OffsetDateTime tokenExpiryDate) {
        Utils.checkNotNull(accessToken, "accessToken");
        Utils.checkNotNull(clientId, "clientId");
        Utils.checkNotNull(clientSecret, "clientSecret");
        Utils.checkNotNull(realmId, "realmId");
        Utils.checkNotNull(refreshToken, "refreshToken");
        Utils.checkNotNull(tokenExpiryDate, "tokenExpiryDate");
        this.accessToken = accessToken;
        this.authType = Builder._SINGLETON_VALUE_AuthType.value();
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.realmId = realmId;
        this.refreshToken = refreshToken;
        this.tokenExpiryDate = tokenExpiryDate;
    }

    /**
     * Access token for making authenticated requests.
     */
    @JsonIgnore
    public String accessToken() {
        return accessToken;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceQuickbooksAuthType> authType() {
        return (Optional<SourceQuickbooksAuthType>) authType;
    }

    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonIgnore
    public String clientId() {
        return clientId;
    }

    /**
     *  Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonIgnore
    public String clientSecret() {
        return clientSecret;
    }

    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    @JsonIgnore
    public String realmId() {
        return realmId;
    }

    /**
     * A token used when refreshing the access token.
     */
    @JsonIgnore
    public String refreshToken() {
        return refreshToken;
    }

    /**
     * The date-time when the access token should be refreshed.
     */
    @JsonIgnore
    public OffsetDateTime tokenExpiryDate() {
        return tokenExpiryDate;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Access token for making authenticated requests.
     */
    public SourceQuickbooksOAuth20 withAccessToken(String accessToken) {
        Utils.checkNotNull(accessToken, "accessToken");
        this.accessToken = accessToken;
        return this;
    }

    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    public SourceQuickbooksOAuth20 withClientId(String clientId) {
        Utils.checkNotNull(clientId, "clientId");
        this.clientId = clientId;
        return this;
    }

    /**
     *  Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    public SourceQuickbooksOAuth20 withClientSecret(String clientSecret) {
        Utils.checkNotNull(clientSecret, "clientSecret");
        this.clientSecret = clientSecret;
        return this;
    }

    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    public SourceQuickbooksOAuth20 withRealmId(String realmId) {
        Utils.checkNotNull(realmId, "realmId");
        this.realmId = realmId;
        return this;
    }

    /**
     * A token used when refreshing the access token.
     */
    public SourceQuickbooksOAuth20 withRefreshToken(String refreshToken) {
        Utils.checkNotNull(refreshToken, "refreshToken");
        this.refreshToken = refreshToken;
        return this;
    }

    /**
     * The date-time when the access token should be refreshed.
     */
    public SourceQuickbooksOAuth20 withTokenExpiryDate(OffsetDateTime tokenExpiryDate) {
        Utils.checkNotNull(tokenExpiryDate, "tokenExpiryDate");
        this.tokenExpiryDate = tokenExpiryDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceQuickbooksOAuth20 other = (SourceQuickbooksOAuth20) o;
        return 
            java.util.Objects.deepEquals(this.accessToken, other.accessToken) &&
            java.util.Objects.deepEquals(this.authType, other.authType) &&
            java.util.Objects.deepEquals(this.clientId, other.clientId) &&
            java.util.Objects.deepEquals(this.clientSecret, other.clientSecret) &&
            java.util.Objects.deepEquals(this.realmId, other.realmId) &&
            java.util.Objects.deepEquals(this.refreshToken, other.refreshToken) &&
            java.util.Objects.deepEquals(this.tokenExpiryDate, other.tokenExpiryDate);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            accessToken,
            authType,
            clientId,
            clientSecret,
            realmId,
            refreshToken,
            tokenExpiryDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceQuickbooksOAuth20.class,
                "accessToken", accessToken,
                "authType", authType,
                "clientId", clientId,
                "clientSecret", clientSecret,
                "realmId", realmId,
                "refreshToken", refreshToken,
                "tokenExpiryDate", tokenExpiryDate);
    }
    
    public final static class Builder {
 
        private String accessToken;
 
        private String clientId;
 
        private String clientSecret;
 
        private String realmId;
 
        private String refreshToken;
 
        private OffsetDateTime tokenExpiryDate;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Access token for making authenticated requests.
         */
        public Builder accessToken(String accessToken) {
            Utils.checkNotNull(accessToken, "accessToken");
            this.accessToken = accessToken;
            return this;
        }

        /**
         * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
         */
        public Builder clientId(String clientId) {
            Utils.checkNotNull(clientId, "clientId");
            this.clientId = clientId;
            return this;
        }

        /**
         *  Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
         */
        public Builder clientSecret(String clientSecret) {
            Utils.checkNotNull(clientSecret, "clientSecret");
            this.clientSecret = clientSecret;
            return this;
        }

        /**
         * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
         */
        public Builder realmId(String realmId) {
            Utils.checkNotNull(realmId, "realmId");
            this.realmId = realmId;
            return this;
        }

        /**
         * A token used when refreshing the access token.
         */
        public Builder refreshToken(String refreshToken) {
            Utils.checkNotNull(refreshToken, "refreshToken");
            this.refreshToken = refreshToken;
            return this;
        }

        /**
         * The date-time when the access token should be refreshed.
         */
        public Builder tokenExpiryDate(OffsetDateTime tokenExpiryDate) {
            Utils.checkNotNull(tokenExpiryDate, "tokenExpiryDate");
            this.tokenExpiryDate = tokenExpiryDate;
            return this;
        }
        
        public SourceQuickbooksOAuth20 build() {
            return new SourceQuickbooksOAuth20(
                accessToken,
                clientId,
                clientSecret,
                realmId,
                refreshToken,
                tokenExpiryDate);
        }

        private static final LazySingletonValue<Optional<? extends SourceQuickbooksAuthType>> _SINGLETON_VALUE_AuthType =
                new LazySingletonValue<>(
                        "auth_type",
                        "\"oauth2.0\"",
                        new TypeReference<Optional<? extends SourceQuickbooksAuthType>>() {});
    }
}

