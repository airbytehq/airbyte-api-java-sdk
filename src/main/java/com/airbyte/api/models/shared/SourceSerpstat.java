/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class SourceSerpstat {

    /**
     * Serpstat API key can be found here: https://serpstat.com/users/profile/
     */
    @JsonProperty("api_key")
    private String apiKey;

    /**
     * The domain name to get data for (ex. serpstat.com)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("domain")
    private Optional<String> domain;

    /**
     * The list of domains that will be used in streams that support batch operations
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("domains")
    private Optional<? extends List<Object>> domains;

    /**
     * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filter_by")
    private Optional<String> filterBy;

    /**
     * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filter_value")
    private Optional<String> filterValue;

    /**
     * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("page_size")
    private Optional<Long> pageSize;

    /**
     * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pages_to_fetch")
    private Optional<Long> pagesToFetch;

    /**
     * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("region_id")
    private Optional<String> regionId;

    /**
     * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort_by")
    private Optional<String> sortBy;

    /**
     * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort_value")
    private Optional<String> sortValue;

    @JsonProperty("sourceType")
    private Serpstat sourceType;

    @JsonCreator
    public SourceSerpstat(
            @JsonProperty("api_key") String apiKey,
            @JsonProperty("domain") Optional<String> domain,
            @JsonProperty("domains") Optional<? extends List<Object>> domains,
            @JsonProperty("filter_by") Optional<String> filterBy,
            @JsonProperty("filter_value") Optional<String> filterValue,
            @JsonProperty("page_size") Optional<Long> pageSize,
            @JsonProperty("pages_to_fetch") Optional<Long> pagesToFetch,
            @JsonProperty("region_id") Optional<String> regionId,
            @JsonProperty("sort_by") Optional<String> sortBy,
            @JsonProperty("sort_value") Optional<String> sortValue) {
        Utils.checkNotNull(apiKey, "apiKey");
        Utils.checkNotNull(domain, "domain");
        Utils.checkNotNull(domains, "domains");
        Utils.checkNotNull(filterBy, "filterBy");
        Utils.checkNotNull(filterValue, "filterValue");
        Utils.checkNotNull(pageSize, "pageSize");
        Utils.checkNotNull(pagesToFetch, "pagesToFetch");
        Utils.checkNotNull(regionId, "regionId");
        Utils.checkNotNull(sortBy, "sortBy");
        Utils.checkNotNull(sortValue, "sortValue");
        this.apiKey = apiKey;
        this.domain = domain;
        this.domains = domains;
        this.filterBy = filterBy;
        this.filterValue = filterValue;
        this.pageSize = pageSize;
        this.pagesToFetch = pagesToFetch;
        this.regionId = regionId;
        this.sortBy = sortBy;
        this.sortValue = sortValue;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
    }
    
    public SourceSerpstat(
            String apiKey) {
        this(apiKey, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Serpstat API key can be found here: https://serpstat.com/users/profile/
     */
    @JsonIgnore
    public String apiKey() {
        return apiKey;
    }

    /**
     * The domain name to get data for (ex. serpstat.com)
     */
    @JsonIgnore
    public Optional<String> domain() {
        return domain;
    }

    /**
     * The list of domains that will be used in streams that support batch operations
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Object>> domains() {
        return (Optional<List<Object>>) domains;
    }

    /**
     * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    @JsonIgnore
    public Optional<String> filterBy() {
        return filterBy;
    }

    /**
     * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    @JsonIgnore
    public Optional<String> filterValue() {
        return filterValue;
    }

    /**
     * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent.
     */
    @JsonIgnore
    public Optional<Long> pageSize() {
        return pageSize;
    }

    /**
     * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent.
     */
    @JsonIgnore
    public Optional<Long> pagesToFetch() {
        return pagesToFetch;
    }

    /**
     * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/.
     */
    @JsonIgnore
    public Optional<String> regionId() {
        return regionId;
    }

    /**
     * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    @JsonIgnore
    public Optional<String> sortBy() {
        return sortBy;
    }

    /**
     * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    @JsonIgnore
    public Optional<String> sortValue() {
        return sortValue;
    }

    @JsonIgnore
    public Serpstat sourceType() {
        return sourceType;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Serpstat API key can be found here: https://serpstat.com/users/profile/
     */
    public SourceSerpstat withApiKey(String apiKey) {
        Utils.checkNotNull(apiKey, "apiKey");
        this.apiKey = apiKey;
        return this;
    }

    /**
     * The domain name to get data for (ex. serpstat.com)
     */
    public SourceSerpstat withDomain(String domain) {
        Utils.checkNotNull(domain, "domain");
        this.domain = Optional.ofNullable(domain);
        return this;
    }

    /**
     * The domain name to get data for (ex. serpstat.com)
     */
    public SourceSerpstat withDomain(Optional<String> domain) {
        Utils.checkNotNull(domain, "domain");
        this.domain = domain;
        return this;
    }

    /**
     * The list of domains that will be used in streams that support batch operations
     */
    public SourceSerpstat withDomains(List<Object> domains) {
        Utils.checkNotNull(domains, "domains");
        this.domains = Optional.ofNullable(domains);
        return this;
    }

    /**
     * The list of domains that will be used in streams that support batch operations
     */
    public SourceSerpstat withDomains(Optional<? extends List<Object>> domains) {
        Utils.checkNotNull(domains, "domains");
        this.domains = domains;
        return this;
    }

    /**
     * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withFilterBy(String filterBy) {
        Utils.checkNotNull(filterBy, "filterBy");
        this.filterBy = Optional.ofNullable(filterBy);
        return this;
    }

    /**
     * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withFilterBy(Optional<String> filterBy) {
        Utils.checkNotNull(filterBy, "filterBy");
        this.filterBy = filterBy;
        return this;
    }

    /**
     * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withFilterValue(String filterValue) {
        Utils.checkNotNull(filterValue, "filterValue");
        this.filterValue = Optional.ofNullable(filterValue);
        return this;
    }

    /**
     * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withFilterValue(Optional<String> filterValue) {
        Utils.checkNotNull(filterValue, "filterValue");
        this.filterValue = filterValue;
        return this;
    }

    /**
     * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent.
     */
    public SourceSerpstat withPageSize(long pageSize) {
        Utils.checkNotNull(pageSize, "pageSize");
        this.pageSize = Optional.ofNullable(pageSize);
        return this;
    }

    /**
     * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent.
     */
    public SourceSerpstat withPageSize(Optional<Long> pageSize) {
        Utils.checkNotNull(pageSize, "pageSize");
        this.pageSize = pageSize;
        return this;
    }

    /**
     * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent.
     */
    public SourceSerpstat withPagesToFetch(long pagesToFetch) {
        Utils.checkNotNull(pagesToFetch, "pagesToFetch");
        this.pagesToFetch = Optional.ofNullable(pagesToFetch);
        return this;
    }

    /**
     * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent.
     */
    public SourceSerpstat withPagesToFetch(Optional<Long> pagesToFetch) {
        Utils.checkNotNull(pagesToFetch, "pagesToFetch");
        this.pagesToFetch = pagesToFetch;
        return this;
    }

    /**
     * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/.
     */
    public SourceSerpstat withRegionId(String regionId) {
        Utils.checkNotNull(regionId, "regionId");
        this.regionId = Optional.ofNullable(regionId);
        return this;
    }

    /**
     * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/.
     */
    public SourceSerpstat withRegionId(Optional<String> regionId) {
        Utils.checkNotNull(regionId, "regionId");
        this.regionId = regionId;
        return this;
    }

    /**
     * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withSortBy(String sortBy) {
        Utils.checkNotNull(sortBy, "sortBy");
        this.sortBy = Optional.ofNullable(sortBy);
        return this;
    }

    /**
     * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withSortBy(Optional<String> sortBy) {
        Utils.checkNotNull(sortBy, "sortBy");
        this.sortBy = sortBy;
        return this;
    }

    /**
     * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withSortValue(String sortValue) {
        Utils.checkNotNull(sortValue, "sortValue");
        this.sortValue = Optional.ofNullable(sortValue);
        return this;
    }

    /**
     * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    public SourceSerpstat withSortValue(Optional<String> sortValue) {
        Utils.checkNotNull(sortValue, "sortValue");
        this.sortValue = sortValue;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceSerpstat other = (SourceSerpstat) o;
        return 
            Objects.deepEquals(this.apiKey, other.apiKey) &&
            Objects.deepEquals(this.domain, other.domain) &&
            Objects.deepEquals(this.domains, other.domains) &&
            Objects.deepEquals(this.filterBy, other.filterBy) &&
            Objects.deepEquals(this.filterValue, other.filterValue) &&
            Objects.deepEquals(this.pageSize, other.pageSize) &&
            Objects.deepEquals(this.pagesToFetch, other.pagesToFetch) &&
            Objects.deepEquals(this.regionId, other.regionId) &&
            Objects.deepEquals(this.sortBy, other.sortBy) &&
            Objects.deepEquals(this.sortValue, other.sortValue) &&
            Objects.deepEquals(this.sourceType, other.sourceType);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            apiKey,
            domain,
            domains,
            filterBy,
            filterValue,
            pageSize,
            pagesToFetch,
            regionId,
            sortBy,
            sortValue,
            sourceType);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceSerpstat.class,
                "apiKey", apiKey,
                "domain", domain,
                "domains", domains,
                "filterBy", filterBy,
                "filterValue", filterValue,
                "pageSize", pageSize,
                "pagesToFetch", pagesToFetch,
                "regionId", regionId,
                "sortBy", sortBy,
                "sortValue", sortValue,
                "sourceType", sourceType);
    }
    
    public final static class Builder {
 
        private String apiKey;
 
        private Optional<String> domain;
 
        private Optional<? extends List<Object>> domains = Optional.empty();
 
        private Optional<String> filterBy = Optional.empty();
 
        private Optional<String> filterValue = Optional.empty();
 
        private Optional<Long> pageSize;
 
        private Optional<Long> pagesToFetch;
 
        private Optional<String> regionId;
 
        private Optional<String> sortBy = Optional.empty();
 
        private Optional<String> sortValue = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Serpstat API key can be found here: https://serpstat.com/users/profile/
         */
        public Builder apiKey(String apiKey) {
            Utils.checkNotNull(apiKey, "apiKey");
            this.apiKey = apiKey;
            return this;
        }

        /**
         * The domain name to get data for (ex. serpstat.com)
         */
        public Builder domain(String domain) {
            Utils.checkNotNull(domain, "domain");
            this.domain = Optional.ofNullable(domain);
            return this;
        }

        /**
         * The domain name to get data for (ex. serpstat.com)
         */
        public Builder domain(Optional<String> domain) {
            Utils.checkNotNull(domain, "domain");
            this.domain = domain;
            return this;
        }

        /**
         * The list of domains that will be used in streams that support batch operations
         */
        public Builder domains(List<Object> domains) {
            Utils.checkNotNull(domains, "domains");
            this.domains = Optional.ofNullable(domains);
            return this;
        }

        /**
         * The list of domains that will be used in streams that support batch operations
         */
        public Builder domains(Optional<? extends List<Object>> domains) {
            Utils.checkNotNull(domains, "domains");
            this.domains = domains;
            return this;
        }

        /**
         * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
         */
        public Builder filterBy(String filterBy) {
            Utils.checkNotNull(filterBy, "filterBy");
            this.filterBy = Optional.ofNullable(filterBy);
            return this;
        }

        /**
         * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
         */
        public Builder filterBy(Optional<String> filterBy) {
            Utils.checkNotNull(filterBy, "filterBy");
            this.filterBy = filterBy;
            return this;
        }

        /**
         * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
         */
        public Builder filterValue(String filterValue) {
            Utils.checkNotNull(filterValue, "filterValue");
            this.filterValue = Optional.ofNullable(filterValue);
            return this;
        }

        /**
         * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
         */
        public Builder filterValue(Optional<String> filterValue) {
            Utils.checkNotNull(filterValue, "filterValue");
            this.filterValue = filterValue;
            return this;
        }

        /**
         * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent.
         */
        public Builder pageSize(long pageSize) {
            Utils.checkNotNull(pageSize, "pageSize");
            this.pageSize = Optional.ofNullable(pageSize);
            return this;
        }

        /**
         * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent.
         */
        public Builder pageSize(Optional<Long> pageSize) {
            Utils.checkNotNull(pageSize, "pageSize");
            this.pageSize = pageSize;
            return this;
        }

        /**
         * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent.
         */
        public Builder pagesToFetch(long pagesToFetch) {
            Utils.checkNotNull(pagesToFetch, "pagesToFetch");
            this.pagesToFetch = Optional.ofNullable(pagesToFetch);
            return this;
        }

        /**
         * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent.
         */
        public Builder pagesToFetch(Optional<Long> pagesToFetch) {
            Utils.checkNotNull(pagesToFetch, "pagesToFetch");
            this.pagesToFetch = pagesToFetch;
            return this;
        }

        /**
         * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/.
         */
        public Builder regionId(String regionId) {
            Utils.checkNotNull(regionId, "regionId");
            this.regionId = Optional.ofNullable(regionId);
            return this;
        }

        /**
         * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/.
         */
        public Builder regionId(Optional<String> regionId) {
            Utils.checkNotNull(regionId, "regionId");
            this.regionId = regionId;
            return this;
        }

        /**
         * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
         */
        public Builder sortBy(String sortBy) {
            Utils.checkNotNull(sortBy, "sortBy");
            this.sortBy = Optional.ofNullable(sortBy);
            return this;
        }

        /**
         * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
         */
        public Builder sortBy(Optional<String> sortBy) {
            Utils.checkNotNull(sortBy, "sortBy");
            this.sortBy = sortBy;
            return this;
        }

        /**
         * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
         */
        public Builder sortValue(String sortValue) {
            Utils.checkNotNull(sortValue, "sortValue");
            this.sortValue = Optional.ofNullable(sortValue);
            return this;
        }

        /**
         * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
         */
        public Builder sortValue(Optional<String> sortValue) {
            Utils.checkNotNull(sortValue, "sortValue");
            this.sortValue = sortValue;
            return this;
        }
        
        public SourceSerpstat build() {
            if (domain == null) {
                domain = _SINGLETON_VALUE_Domain.value();
            }
            if (pageSize == null) {
                pageSize = _SINGLETON_VALUE_PageSize.value();
            }
            if (pagesToFetch == null) {
                pagesToFetch = _SINGLETON_VALUE_PagesToFetch.value();
            }
            if (regionId == null) {
                regionId = _SINGLETON_VALUE_RegionId.value();
            }
            return new SourceSerpstat(
                apiKey,
                domain,
                domains,
                filterBy,
                filterValue,
                pageSize,
                pagesToFetch,
                regionId,
                sortBy,
                sortValue);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Domain =
                new LazySingletonValue<>(
                        "domain",
                        "\"serpstat.com\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_PageSize =
                new LazySingletonValue<>(
                        "page_size",
                        "10",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_PagesToFetch =
                new LazySingletonValue<>(
                        "pages_to_fetch",
                        "1",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_RegionId =
                new LazySingletonValue<>(
                        "region_id",
                        "\"g_us\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Serpstat> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"serpstat\"",
                        new TypeReference<Serpstat>() {});
    }
}
