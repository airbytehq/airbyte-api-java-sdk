/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;


public class SourceFaker {

    /**
     * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("always_updated")
    private Optional<Boolean> alwaysUpdated;

    /**
     * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("count")
    private Optional<Long> count;

    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parallelism")
    private Optional<Long> parallelism;

    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("records_per_slice")
    private Optional<Long> recordsPerSlice;

    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("seed")
    private Optional<Long> seed;

    @JsonProperty("sourceType")
    private Faker sourceType;

    @JsonCreator
    public SourceFaker(
            @JsonProperty("always_updated") Optional<Boolean> alwaysUpdated,
            @JsonProperty("count") Optional<Long> count,
            @JsonProperty("parallelism") Optional<Long> parallelism,
            @JsonProperty("records_per_slice") Optional<Long> recordsPerSlice,
            @JsonProperty("seed") Optional<Long> seed) {
        Utils.checkNotNull(alwaysUpdated, "alwaysUpdated");
        Utils.checkNotNull(count, "count");
        Utils.checkNotNull(parallelism, "parallelism");
        Utils.checkNotNull(recordsPerSlice, "recordsPerSlice");
        Utils.checkNotNull(seed, "seed");
        this.alwaysUpdated = alwaysUpdated;
        this.count = count;
        this.parallelism = parallelism;
        this.recordsPerSlice = recordsPerSlice;
        this.seed = seed;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
    }
    
    public SourceFaker() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
     */
    @JsonIgnore
    public Optional<Boolean> alwaysUpdated() {
        return alwaysUpdated;
    }

    /**
     * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream.
     */
    @JsonIgnore
    public Optional<Long> count() {
        return count;
    }

    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
     */
    @JsonIgnore
    public Optional<Long> parallelism() {
        return parallelism;
    }

    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?
     */
    @JsonIgnore
    public Optional<Long> recordsPerSlice() {
        return recordsPerSlice;
    }

    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
     */
    @JsonIgnore
    public Optional<Long> seed() {
        return seed;
    }

    @JsonIgnore
    public Faker sourceType() {
        return sourceType;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
     */
    public SourceFaker withAlwaysUpdated(boolean alwaysUpdated) {
        Utils.checkNotNull(alwaysUpdated, "alwaysUpdated");
        this.alwaysUpdated = Optional.ofNullable(alwaysUpdated);
        return this;
    }

    /**
     * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
     */
    public SourceFaker withAlwaysUpdated(Optional<Boolean> alwaysUpdated) {
        Utils.checkNotNull(alwaysUpdated, "alwaysUpdated");
        this.alwaysUpdated = alwaysUpdated;
        return this;
    }

    /**
     * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream.
     */
    public SourceFaker withCount(long count) {
        Utils.checkNotNull(count, "count");
        this.count = Optional.ofNullable(count);
        return this;
    }

    /**
     * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream.
     */
    public SourceFaker withCount(Optional<Long> count) {
        Utils.checkNotNull(count, "count");
        this.count = count;
        return this;
    }

    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
     */
    public SourceFaker withParallelism(long parallelism) {
        Utils.checkNotNull(parallelism, "parallelism");
        this.parallelism = Optional.ofNullable(parallelism);
        return this;
    }

    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
     */
    public SourceFaker withParallelism(Optional<Long> parallelism) {
        Utils.checkNotNull(parallelism, "parallelism");
        this.parallelism = parallelism;
        return this;
    }

    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?
     */
    public SourceFaker withRecordsPerSlice(long recordsPerSlice) {
        Utils.checkNotNull(recordsPerSlice, "recordsPerSlice");
        this.recordsPerSlice = Optional.ofNullable(recordsPerSlice);
        return this;
    }

    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?
     */
    public SourceFaker withRecordsPerSlice(Optional<Long> recordsPerSlice) {
        Utils.checkNotNull(recordsPerSlice, "recordsPerSlice");
        this.recordsPerSlice = recordsPerSlice;
        return this;
    }

    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
     */
    public SourceFaker withSeed(long seed) {
        Utils.checkNotNull(seed, "seed");
        this.seed = Optional.ofNullable(seed);
        return this;
    }

    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
     */
    public SourceFaker withSeed(Optional<Long> seed) {
        Utils.checkNotNull(seed, "seed");
        this.seed = seed;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceFaker other = (SourceFaker) o;
        return 
            Objects.deepEquals(this.alwaysUpdated, other.alwaysUpdated) &&
            Objects.deepEquals(this.count, other.count) &&
            Objects.deepEquals(this.parallelism, other.parallelism) &&
            Objects.deepEquals(this.recordsPerSlice, other.recordsPerSlice) &&
            Objects.deepEquals(this.seed, other.seed) &&
            Objects.deepEquals(this.sourceType, other.sourceType);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            alwaysUpdated,
            count,
            parallelism,
            recordsPerSlice,
            seed,
            sourceType);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceFaker.class,
                "alwaysUpdated", alwaysUpdated,
                "count", count,
                "parallelism", parallelism,
                "recordsPerSlice", recordsPerSlice,
                "seed", seed,
                "sourceType", sourceType);
    }
    
    public final static class Builder {
 
        private Optional<Boolean> alwaysUpdated;
 
        private Optional<Long> count;
 
        private Optional<Long> parallelism;
 
        private Optional<Long> recordsPerSlice;
 
        private Optional<Long> seed;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
         */
        public Builder alwaysUpdated(boolean alwaysUpdated) {
            Utils.checkNotNull(alwaysUpdated, "alwaysUpdated");
            this.alwaysUpdated = Optional.ofNullable(alwaysUpdated);
            return this;
        }

        /**
         * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
         */
        public Builder alwaysUpdated(Optional<Boolean> alwaysUpdated) {
            Utils.checkNotNull(alwaysUpdated, "alwaysUpdated");
            this.alwaysUpdated = alwaysUpdated;
            return this;
        }

        /**
         * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream.
         */
        public Builder count(long count) {
            Utils.checkNotNull(count, "count");
            this.count = Optional.ofNullable(count);
            return this;
        }

        /**
         * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream.
         */
        public Builder count(Optional<Long> count) {
            Utils.checkNotNull(count, "count");
            this.count = count;
            return this;
        }

        /**
         * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
         */
        public Builder parallelism(long parallelism) {
            Utils.checkNotNull(parallelism, "parallelism");
            this.parallelism = Optional.ofNullable(parallelism);
            return this;
        }

        /**
         * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
         */
        public Builder parallelism(Optional<Long> parallelism) {
            Utils.checkNotNull(parallelism, "parallelism");
            this.parallelism = parallelism;
            return this;
        }

        /**
         * How many fake records will be in each page (stream slice), before a state message is emitted?
         */
        public Builder recordsPerSlice(long recordsPerSlice) {
            Utils.checkNotNull(recordsPerSlice, "recordsPerSlice");
            this.recordsPerSlice = Optional.ofNullable(recordsPerSlice);
            return this;
        }

        /**
         * How many fake records will be in each page (stream slice), before a state message is emitted?
         */
        public Builder recordsPerSlice(Optional<Long> recordsPerSlice) {
            Utils.checkNotNull(recordsPerSlice, "recordsPerSlice");
            this.recordsPerSlice = recordsPerSlice;
            return this;
        }

        /**
         * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
         */
        public Builder seed(long seed) {
            Utils.checkNotNull(seed, "seed");
            this.seed = Optional.ofNullable(seed);
            return this;
        }

        /**
         * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
         */
        public Builder seed(Optional<Long> seed) {
            Utils.checkNotNull(seed, "seed");
            this.seed = seed;
            return this;
        }
        
        public SourceFaker build() {
            if (alwaysUpdated == null) {
                alwaysUpdated = _SINGLETON_VALUE_AlwaysUpdated.value();
            }
            if (count == null) {
                count = _SINGLETON_VALUE_Count.value();
            }
            if (parallelism == null) {
                parallelism = _SINGLETON_VALUE_Parallelism.value();
            }
            if (recordsPerSlice == null) {
                recordsPerSlice = _SINGLETON_VALUE_RecordsPerSlice.value();
            }
            if (seed == null) {
                seed = _SINGLETON_VALUE_Seed.value();
            }            return new SourceFaker(
                alwaysUpdated,
                count,
                parallelism,
                recordsPerSlice,
                seed);
        }

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_AlwaysUpdated =
                new LazySingletonValue<>(
                        "always_updated",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_Count =
                new LazySingletonValue<>(
                        "count",
                        "1000",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_Parallelism =
                new LazySingletonValue<>(
                        "parallelism",
                        "4",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_RecordsPerSlice =
                new LazySingletonValue<>(
                        "records_per_slice",
                        "1000",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_Seed =
                new LazySingletonValue<>(
                        "seed",
                        "-1",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Faker> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"faker\"",
                        new TypeReference<Faker>() {});
    }
}

