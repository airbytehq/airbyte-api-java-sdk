/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

public class SourceGutendex {

    /**
     * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("author_year_end")
    private Optional<? extends String> authorYearEnd;

    /**
     * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("author_year_start")
    private Optional<? extends String> authorYearStart;

    /**
     * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("copyright")
    private Optional<? extends String> copyright;

    /**
     * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("languages")
    private Optional<? extends String> languages;

    /**
     * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("search")
    private Optional<? extends String> search;

    /**
     * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort")
    private Optional<? extends String> sort;

    @JsonProperty("sourceType")
    private Gutendex sourceType;

    /**
     * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("topic")
    private Optional<? extends String> topic;

    @JsonCreator
    public SourceGutendex(
            @JsonProperty("author_year_end") Optional<? extends String> authorYearEnd,
            @JsonProperty("author_year_start") Optional<? extends String> authorYearStart,
            @JsonProperty("copyright") Optional<? extends String> copyright,
            @JsonProperty("languages") Optional<? extends String> languages,
            @JsonProperty("search") Optional<? extends String> search,
            @JsonProperty("sort") Optional<? extends String> sort,
            @JsonProperty("topic") Optional<? extends String> topic) {
        Utils.checkNotNull(authorYearEnd, "authorYearEnd");
        Utils.checkNotNull(authorYearStart, "authorYearStart");
        Utils.checkNotNull(copyright, "copyright");
        Utils.checkNotNull(languages, "languages");
        Utils.checkNotNull(search, "search");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(topic, "topic");
        this.authorYearEnd = authorYearEnd;
        this.authorYearStart = authorYearStart;
        this.copyright = copyright;
        this.languages = languages;
        this.search = search;
        this.sort = sort;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.topic = topic;
    }
    
    public SourceGutendex() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> authorYearEnd() {
        return (Optional<String>) authorYearEnd;
    }

    /**
     * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> authorYearStart() {
        return (Optional<String>) authorYearStart;
    }

    /**
     * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> copyright() {
        return (Optional<String>) copyright;
    }

    /**
     * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> languages() {
        return (Optional<String>) languages;
    }

    /**
     * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> search() {
        return (Optional<String>) search;
    }

    /**
     * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> sort() {
        return (Optional<String>) sort;
    }

    @JsonIgnore
    public Gutendex sourceType() {
        return sourceType;
    }

    /**
     * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> topic() {
        return (Optional<String>) topic;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    public SourceGutendex withAuthorYearEnd(String authorYearEnd) {
        Utils.checkNotNull(authorYearEnd, "authorYearEnd");
        this.authorYearEnd = Optional.ofNullable(authorYearEnd);
        return this;
    }

    /**
     * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    public SourceGutendex withAuthorYearEnd(Optional<? extends String> authorYearEnd) {
        Utils.checkNotNull(authorYearEnd, "authorYearEnd");
        this.authorYearEnd = authorYearEnd;
        return this;
    }

    /**
     * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    public SourceGutendex withAuthorYearStart(String authorYearStart) {
        Utils.checkNotNull(authorYearStart, "authorYearStart");
        this.authorYearStart = Optional.ofNullable(authorYearStart);
        return this;
    }

    /**
     * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    public SourceGutendex withAuthorYearStart(Optional<? extends String> authorYearStart) {
        Utils.checkNotNull(authorYearStart, "authorYearStart");
        this.authorYearStart = authorYearStart;
        return this;
    }

    /**
     * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
     */
    public SourceGutendex withCopyright(String copyright) {
        Utils.checkNotNull(copyright, "copyright");
        this.copyright = Optional.ofNullable(copyright);
        return this;
    }

    /**
     * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
     */
    public SourceGutendex withCopyright(Optional<? extends String> copyright) {
        Utils.checkNotNull(copyright, "copyright");
        this.copyright = copyright;
        return this;
    }

    /**
     * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
     */
    public SourceGutendex withLanguages(String languages) {
        Utils.checkNotNull(languages, "languages");
        this.languages = Optional.ofNullable(languages);
        return this;
    }

    /**
     * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
     */
    public SourceGutendex withLanguages(Optional<? extends String> languages) {
        Utils.checkNotNull(languages, "languages");
        this.languages = languages;
        return this;
    }

    /**
     * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
     */
    public SourceGutendex withSearch(String search) {
        Utils.checkNotNull(search, "search");
        this.search = Optional.ofNullable(search);
        return this;
    }

    /**
     * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
     */
    public SourceGutendex withSearch(Optional<? extends String> search) {
        Utils.checkNotNull(search, "search");
        this.search = search;
        return this;
    }

    /**
     * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
     */
    public SourceGutendex withSort(String sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }

    /**
     * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
     */
    public SourceGutendex withSort(Optional<? extends String> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
     */
    public SourceGutendex withTopic(String topic) {
        Utils.checkNotNull(topic, "topic");
        this.topic = Optional.ofNullable(topic);
        return this;
    }

    /**
     * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
     */
    public SourceGutendex withTopic(Optional<? extends String> topic) {
        Utils.checkNotNull(topic, "topic");
        this.topic = topic;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceGutendex other = (SourceGutendex) o;
        return 
            java.util.Objects.deepEquals(this.authorYearEnd, other.authorYearEnd) &&
            java.util.Objects.deepEquals(this.authorYearStart, other.authorYearStart) &&
            java.util.Objects.deepEquals(this.copyright, other.copyright) &&
            java.util.Objects.deepEquals(this.languages, other.languages) &&
            java.util.Objects.deepEquals(this.search, other.search) &&
            java.util.Objects.deepEquals(this.sort, other.sort) &&
            java.util.Objects.deepEquals(this.sourceType, other.sourceType) &&
            java.util.Objects.deepEquals(this.topic, other.topic);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            authorYearEnd,
            authorYearStart,
            copyright,
            languages,
            search,
            sort,
            sourceType,
            topic);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceGutendex.class,
                "authorYearEnd", authorYearEnd,
                "authorYearStart", authorYearStart,
                "copyright", copyright,
                "languages", languages,
                "search", search,
                "sort", sort,
                "sourceType", sourceType,
                "topic", topic);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> authorYearEnd = Optional.empty();
 
        private Optional<? extends String> authorYearStart = Optional.empty();
 
        private Optional<? extends String> copyright = Optional.empty();
 
        private Optional<? extends String> languages = Optional.empty();
 
        private Optional<? extends String> search = Optional.empty();
 
        private Optional<? extends String> sort = Optional.empty();
 
        private Optional<? extends String> topic = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
         */
        public Builder authorYearEnd(String authorYearEnd) {
            Utils.checkNotNull(authorYearEnd, "authorYearEnd");
            this.authorYearEnd = Optional.ofNullable(authorYearEnd);
            return this;
        }

        /**
         * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
         */
        public Builder authorYearEnd(Optional<? extends String> authorYearEnd) {
            Utils.checkNotNull(authorYearEnd, "authorYearEnd");
            this.authorYearEnd = authorYearEnd;
            return this;
        }

        /**
         * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
         */
        public Builder authorYearStart(String authorYearStart) {
            Utils.checkNotNull(authorYearStart, "authorYearStart");
            this.authorYearStart = Optional.ofNullable(authorYearStart);
            return this;
        }

        /**
         * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
         */
        public Builder authorYearStart(Optional<? extends String> authorYearStart) {
            Utils.checkNotNull(authorYearStart, "authorYearStart");
            this.authorYearStart = authorYearStart;
            return this;
        }

        /**
         * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
         */
        public Builder copyright(String copyright) {
            Utils.checkNotNull(copyright, "copyright");
            this.copyright = Optional.ofNullable(copyright);
            return this;
        }

        /**
         * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
         */
        public Builder copyright(Optional<? extends String> copyright) {
            Utils.checkNotNull(copyright, "copyright");
            this.copyright = copyright;
            return this;
        }

        /**
         * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
         */
        public Builder languages(String languages) {
            Utils.checkNotNull(languages, "languages");
            this.languages = Optional.ofNullable(languages);
            return this;
        }

        /**
         * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
         */
        public Builder languages(Optional<? extends String> languages) {
            Utils.checkNotNull(languages, "languages");
            this.languages = languages;
            return this;
        }

        /**
         * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
         */
        public Builder search(String search) {
            Utils.checkNotNull(search, "search");
            this.search = Optional.ofNullable(search);
            return this;
        }

        /**
         * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
         */
        public Builder search(Optional<? extends String> search) {
            Utils.checkNotNull(search, "search");
            this.search = search;
            return this;
        }

        /**
         * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
         */
        public Builder sort(String sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
         */
        public Builder sort(Optional<? extends String> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }

        /**
         * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
         */
        public Builder topic(String topic) {
            Utils.checkNotNull(topic, "topic");
            this.topic = Optional.ofNullable(topic);
            return this;
        }

        /**
         * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
         */
        public Builder topic(Optional<? extends String> topic) {
            Utils.checkNotNull(topic, "topic");
            this.topic = topic;
            return this;
        }
        
        public SourceGutendex build() {
            return new SourceGutendex(
                authorYearEnd,
                authorYearStart,
                copyright,
                languages,
                search,
                sort,
                topic);
        }

        private static final LazySingletonValue<Gutendex> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"gutendex\"",
                        new TypeReference<Gutendex>() {});
    }
}

