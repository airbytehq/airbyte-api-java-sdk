/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.Objects;
import java.util.Optional;

public class SourceQuickbooks {

    /**
     * Access token for making authenticated requests.
     */
    @JsonProperty("access_token")
    private String accessToken;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_type")
    private Optional<? extends SourceQuickbooksAuthType> authType;

    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonProperty("client_id")
    private String clientId;

    /**
     * Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonProperty("client_secret")
    private String clientSecret;

    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    @JsonProperty("realm_id")
    private String realmId;

    /**
     * A token used when refreshing the access token.
     */
    @JsonProperty("refresh_token")
    private String refreshToken;

    /**
     * Determines whether to use the sandbox or production environment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sandbox")
    private Optional<Boolean> sandbox;

    @JsonProperty("sourceType")
    private Quickbooks sourceType;

    /**
     * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
     */
    @JsonProperty("start_date")
    private OffsetDateTime startDate;

    /**
     * The date-time when the access token should be refreshed.
     */
    @JsonProperty("token_expiry_date")
    private OffsetDateTime tokenExpiryDate;

    @JsonCreator
    public SourceQuickbooks(
            @JsonProperty("access_token") String accessToken,
            @JsonProperty("client_id") String clientId,
            @JsonProperty("client_secret") String clientSecret,
            @JsonProperty("realm_id") String realmId,
            @JsonProperty("refresh_token") String refreshToken,
            @JsonProperty("sandbox") Optional<Boolean> sandbox,
            @JsonProperty("start_date") OffsetDateTime startDate,
            @JsonProperty("token_expiry_date") OffsetDateTime tokenExpiryDate) {
        Utils.checkNotNull(accessToken, "accessToken");
        Utils.checkNotNull(clientId, "clientId");
        Utils.checkNotNull(clientSecret, "clientSecret");
        Utils.checkNotNull(realmId, "realmId");
        Utils.checkNotNull(refreshToken, "refreshToken");
        Utils.checkNotNull(sandbox, "sandbox");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(tokenExpiryDate, "tokenExpiryDate");
        this.accessToken = accessToken;
        this.authType = Builder._SINGLETON_VALUE_AuthType.value();
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.realmId = realmId;
        this.refreshToken = refreshToken;
        this.sandbox = sandbox;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.tokenExpiryDate = tokenExpiryDate;
    }
    
    public SourceQuickbooks(
            String accessToken,
            String clientId,
            String clientSecret,
            String realmId,
            String refreshToken,
            OffsetDateTime startDate,
            OffsetDateTime tokenExpiryDate) {
        this(accessToken, clientId, clientSecret, realmId, refreshToken, Optional.empty(), startDate, tokenExpiryDate);
    }

    /**
     * Access token for making authenticated requests.
     */
    @JsonIgnore
    public String accessToken() {
        return accessToken;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceQuickbooksAuthType> authType() {
        return (Optional<SourceQuickbooksAuthType>) authType;
    }

    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonIgnore
    public String clientId() {
        return clientId;
    }

    /**
     * Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    @JsonIgnore
    public String clientSecret() {
        return clientSecret;
    }

    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    @JsonIgnore
    public String realmId() {
        return realmId;
    }

    /**
     * A token used when refreshing the access token.
     */
    @JsonIgnore
    public String refreshToken() {
        return refreshToken;
    }

    /**
     * Determines whether to use the sandbox or production environment.
     */
    @JsonIgnore
    public Optional<Boolean> sandbox() {
        return sandbox;
    }

    @JsonIgnore
    public Quickbooks sourceType() {
        return sourceType;
    }

    /**
     * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
     */
    @JsonIgnore
    public OffsetDateTime startDate() {
        return startDate;
    }

    /**
     * The date-time when the access token should be refreshed.
     */
    @JsonIgnore
    public OffsetDateTime tokenExpiryDate() {
        return tokenExpiryDate;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Access token for making authenticated requests.
     */
    public SourceQuickbooks withAccessToken(String accessToken) {
        Utils.checkNotNull(accessToken, "accessToken");
        this.accessToken = accessToken;
        return this;
    }

    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    public SourceQuickbooks withClientId(String clientId) {
        Utils.checkNotNull(clientId, "clientId");
        this.clientId = clientId;
        return this;
    }

    /**
     * Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    public SourceQuickbooks withClientSecret(String clientSecret) {
        Utils.checkNotNull(clientSecret, "clientSecret");
        this.clientSecret = clientSecret;
        return this;
    }

    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    public SourceQuickbooks withRealmId(String realmId) {
        Utils.checkNotNull(realmId, "realmId");
        this.realmId = realmId;
        return this;
    }

    /**
     * A token used when refreshing the access token.
     */
    public SourceQuickbooks withRefreshToken(String refreshToken) {
        Utils.checkNotNull(refreshToken, "refreshToken");
        this.refreshToken = refreshToken;
        return this;
    }

    /**
     * Determines whether to use the sandbox or production environment.
     */
    public SourceQuickbooks withSandbox(boolean sandbox) {
        Utils.checkNotNull(sandbox, "sandbox");
        this.sandbox = Optional.ofNullable(sandbox);
        return this;
    }

    /**
     * Determines whether to use the sandbox or production environment.
     */
    public SourceQuickbooks withSandbox(Optional<Boolean> sandbox) {
        Utils.checkNotNull(sandbox, "sandbox");
        this.sandbox = sandbox;
        return this;
    }

    /**
     * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
     */
    public SourceQuickbooks withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The date-time when the access token should be refreshed.
     */
    public SourceQuickbooks withTokenExpiryDate(OffsetDateTime tokenExpiryDate) {
        Utils.checkNotNull(tokenExpiryDate, "tokenExpiryDate");
        this.tokenExpiryDate = tokenExpiryDate;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceQuickbooks other = (SourceQuickbooks) o;
        return 
            Objects.deepEquals(this.accessToken, other.accessToken) &&
            Objects.deepEquals(this.authType, other.authType) &&
            Objects.deepEquals(this.clientId, other.clientId) &&
            Objects.deepEquals(this.clientSecret, other.clientSecret) &&
            Objects.deepEquals(this.realmId, other.realmId) &&
            Objects.deepEquals(this.refreshToken, other.refreshToken) &&
            Objects.deepEquals(this.sandbox, other.sandbox) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.tokenExpiryDate, other.tokenExpiryDate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            accessToken,
            authType,
            clientId,
            clientSecret,
            realmId,
            refreshToken,
            sandbox,
            sourceType,
            startDate,
            tokenExpiryDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceQuickbooks.class,
                "accessToken", accessToken,
                "authType", authType,
                "clientId", clientId,
                "clientSecret", clientSecret,
                "realmId", realmId,
                "refreshToken", refreshToken,
                "sandbox", sandbox,
                "sourceType", sourceType,
                "startDate", startDate,
                "tokenExpiryDate", tokenExpiryDate);
    }
    
    public final static class Builder {
 
        private String accessToken;
 
        private String clientId;
 
        private String clientSecret;
 
        private String realmId;
 
        private String refreshToken;
 
        private Optional<Boolean> sandbox;
 
        private OffsetDateTime startDate;
 
        private OffsetDateTime tokenExpiryDate;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Access token for making authenticated requests.
         */
        public Builder accessToken(String accessToken) {
            Utils.checkNotNull(accessToken, "accessToken");
            this.accessToken = accessToken;
            return this;
        }

        /**
         * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
         */
        public Builder clientId(String clientId) {
            Utils.checkNotNull(clientId, "clientId");
            this.clientId = clientId;
            return this;
        }

        /**
         * Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
         */
        public Builder clientSecret(String clientSecret) {
            Utils.checkNotNull(clientSecret, "clientSecret");
            this.clientSecret = clientSecret;
            return this;
        }

        /**
         * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
         */
        public Builder realmId(String realmId) {
            Utils.checkNotNull(realmId, "realmId");
            this.realmId = realmId;
            return this;
        }

        /**
         * A token used when refreshing the access token.
         */
        public Builder refreshToken(String refreshToken) {
            Utils.checkNotNull(refreshToken, "refreshToken");
            this.refreshToken = refreshToken;
            return this;
        }

        /**
         * Determines whether to use the sandbox or production environment.
         */
        public Builder sandbox(boolean sandbox) {
            Utils.checkNotNull(sandbox, "sandbox");
            this.sandbox = Optional.ofNullable(sandbox);
            return this;
        }

        /**
         * Determines whether to use the sandbox or production environment.
         */
        public Builder sandbox(Optional<Boolean> sandbox) {
            Utils.checkNotNull(sandbox, "sandbox");
            this.sandbox = sandbox;
            return this;
        }

        /**
         * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * The date-time when the access token should be refreshed.
         */
        public Builder tokenExpiryDate(OffsetDateTime tokenExpiryDate) {
            Utils.checkNotNull(tokenExpiryDate, "tokenExpiryDate");
            this.tokenExpiryDate = tokenExpiryDate;
            return this;
        }
        
        public SourceQuickbooks build() {
            if (sandbox == null) {
                sandbox = _SINGLETON_VALUE_Sandbox.value();
            }
            return new SourceQuickbooks(
                accessToken,
                clientId,
                clientSecret,
                realmId,
                refreshToken,
                sandbox,
                startDate,
                tokenExpiryDate);
        }

        private static final LazySingletonValue<Optional<? extends SourceQuickbooksAuthType>> _SINGLETON_VALUE_AuthType =
                new LazySingletonValue<>(
                        "auth_type",
                        "\"oauth2.0\"",
                        new TypeReference<Optional<? extends SourceQuickbooksAuthType>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_Sandbox =
                new LazySingletonValue<>(
                        "sandbox",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Quickbooks> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"quickbooks\"",
                        new TypeReference<Quickbooks>() {});
    }
}
