/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class SourceAmazonSellerPartner {

    /**
     * Type of the Account you're going to authorize the Airbyte application by
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account_type")
    private Optional<? extends AWSSellerPartnerAccountType> accountType;

    /**
     * Your Amazon Application ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("app_id")
    private Optional<String> appId;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_type")
    private Optional<? extends SourceAmazonSellerPartnerAuthType> authType;

    /**
     * Select the AWS Environment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aws_environment")
    private Optional<? extends AWSEnvironment> awsEnvironment;

    /**
     * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
     * 
     * <p>- **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
     * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
     * 
     * <p>Select a step size that matches your data volume to optimize syncing speed and API performance.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("financial_events_step")
    private Optional<? extends FinancialEventsStepSizeInDays> financialEventsStep;

    /**
     * Your Login with Amazon Client ID.
     */
    @JsonProperty("lwa_app_id")
    private String lwaAppId;

    /**
     * Your Login with Amazon Client Secret.
     */
    @JsonProperty("lwa_client_secret")
    private String lwaClientSecret;

    /**
     * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("period_in_days")
    private Optional<Long> periodInDays;

    /**
     * The Refresh Token obtained via OAuth flow authorization.
     */
    @JsonProperty("refresh_token")
    private String refreshToken;

    /**
     * Select the AWS Region.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("region")
    private Optional<? extends AWSRegion> region;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("replication_end_date")
    private Optional<OffsetDateTime> replicationEndDate;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("replication_start_date")
    private Optional<OffsetDateTime> replicationStartDate;

    /**
     * Additional information passed to reports. This varies by report type.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("report_options_list")
    private Optional<? extends List<ReportOptions>> reportOptionsList;

    @JsonProperty("sourceType")
    private SourceAmazonSellerPartnerAmazonSellerPartner sourceType;

    /**
     * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See &lt;a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank"&gt;Troubleshooting&lt;/a&gt; section for more details
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("wait_to_avoid_fatal_errors")
    private Optional<Boolean> waitToAvoidFatalErrors;

    @JsonCreator
    public SourceAmazonSellerPartner(
            @JsonProperty("account_type") Optional<? extends AWSSellerPartnerAccountType> accountType,
            @JsonProperty("app_id") Optional<String> appId,
            @JsonProperty("aws_environment") Optional<? extends AWSEnvironment> awsEnvironment,
            @JsonProperty("financial_events_step") Optional<? extends FinancialEventsStepSizeInDays> financialEventsStep,
            @JsonProperty("lwa_app_id") String lwaAppId,
            @JsonProperty("lwa_client_secret") String lwaClientSecret,
            @JsonProperty("period_in_days") Optional<Long> periodInDays,
            @JsonProperty("refresh_token") String refreshToken,
            @JsonProperty("region") Optional<? extends AWSRegion> region,
            @JsonProperty("replication_end_date") Optional<OffsetDateTime> replicationEndDate,
            @JsonProperty("replication_start_date") Optional<OffsetDateTime> replicationStartDate,
            @JsonProperty("report_options_list") Optional<? extends List<ReportOptions>> reportOptionsList,
            @JsonProperty("wait_to_avoid_fatal_errors") Optional<Boolean> waitToAvoidFatalErrors) {
        Utils.checkNotNull(accountType, "accountType");
        Utils.checkNotNull(appId, "appId");
        Utils.checkNotNull(awsEnvironment, "awsEnvironment");
        Utils.checkNotNull(financialEventsStep, "financialEventsStep");
        Utils.checkNotNull(lwaAppId, "lwaAppId");
        Utils.checkNotNull(lwaClientSecret, "lwaClientSecret");
        Utils.checkNotNull(periodInDays, "periodInDays");
        Utils.checkNotNull(refreshToken, "refreshToken");
        Utils.checkNotNull(region, "region");
        Utils.checkNotNull(replicationEndDate, "replicationEndDate");
        Utils.checkNotNull(replicationStartDate, "replicationStartDate");
        Utils.checkNotNull(reportOptionsList, "reportOptionsList");
        Utils.checkNotNull(waitToAvoidFatalErrors, "waitToAvoidFatalErrors");
        this.accountType = accountType;
        this.appId = appId;
        this.authType = Builder._SINGLETON_VALUE_AuthType.value();
        this.awsEnvironment = awsEnvironment;
        this.financialEventsStep = financialEventsStep;
        this.lwaAppId = lwaAppId;
        this.lwaClientSecret = lwaClientSecret;
        this.periodInDays = periodInDays;
        this.refreshToken = refreshToken;
        this.region = region;
        this.replicationEndDate = replicationEndDate;
        this.replicationStartDate = replicationStartDate;
        this.reportOptionsList = reportOptionsList;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.waitToAvoidFatalErrors = waitToAvoidFatalErrors;
    }
    
    public SourceAmazonSellerPartner(
            String lwaAppId,
            String lwaClientSecret,
            String refreshToken) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), lwaAppId, lwaClientSecret, Optional.empty(), refreshToken, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Type of the Account you're going to authorize the Airbyte application by
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AWSSellerPartnerAccountType> accountType() {
        return (Optional<AWSSellerPartnerAccountType>) accountType;
    }

    /**
     * Your Amazon Application ID.
     */
    @JsonIgnore
    public Optional<String> appId() {
        return appId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceAmazonSellerPartnerAuthType> authType() {
        return (Optional<SourceAmazonSellerPartnerAuthType>) authType;
    }

    /**
     * Select the AWS Environment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AWSEnvironment> awsEnvironment() {
        return (Optional<AWSEnvironment>) awsEnvironment;
    }

    /**
     * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
     * 
     * <p>- **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
     * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
     * 
     * <p>Select a step size that matches your data volume to optimize syncing speed and API performance.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<FinancialEventsStepSizeInDays> financialEventsStep() {
        return (Optional<FinancialEventsStepSizeInDays>) financialEventsStep;
    }

    /**
     * Your Login with Amazon Client ID.
     */
    @JsonIgnore
    public String lwaAppId() {
        return lwaAppId;
    }

    /**
     * Your Login with Amazon Client Secret.
     */
    @JsonIgnore
    public String lwaClientSecret() {
        return lwaClientSecret;
    }

    /**
     * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day.
     */
    @JsonIgnore
    public Optional<Long> periodInDays() {
        return periodInDays;
    }

    /**
     * The Refresh Token obtained via OAuth flow authorization.
     */
    @JsonIgnore
    public String refreshToken() {
        return refreshToken;
    }

    /**
     * Select the AWS Region.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AWSRegion> region() {
        return (Optional<AWSRegion>) region;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> replicationEndDate() {
        return replicationEndDate;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> replicationStartDate() {
        return replicationStartDate;
    }

    /**
     * Additional information passed to reports. This varies by report type.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ReportOptions>> reportOptionsList() {
        return (Optional<List<ReportOptions>>) reportOptionsList;
    }

    @JsonIgnore
    public SourceAmazonSellerPartnerAmazonSellerPartner sourceType() {
        return sourceType;
    }

    /**
     * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See &lt;a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank"&gt;Troubleshooting&lt;/a&gt; section for more details
     */
    @JsonIgnore
    public Optional<Boolean> waitToAvoidFatalErrors() {
        return waitToAvoidFatalErrors;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Type of the Account you're going to authorize the Airbyte application by
     */
    public SourceAmazonSellerPartner withAccountType(AWSSellerPartnerAccountType accountType) {
        Utils.checkNotNull(accountType, "accountType");
        this.accountType = Optional.ofNullable(accountType);
        return this;
    }

    /**
     * Type of the Account you're going to authorize the Airbyte application by
     */
    public SourceAmazonSellerPartner withAccountType(Optional<? extends AWSSellerPartnerAccountType> accountType) {
        Utils.checkNotNull(accountType, "accountType");
        this.accountType = accountType;
        return this;
    }

    /**
     * Your Amazon Application ID.
     */
    public SourceAmazonSellerPartner withAppId(String appId) {
        Utils.checkNotNull(appId, "appId");
        this.appId = Optional.ofNullable(appId);
        return this;
    }

    /**
     * Your Amazon Application ID.
     */
    public SourceAmazonSellerPartner withAppId(Optional<String> appId) {
        Utils.checkNotNull(appId, "appId");
        this.appId = appId;
        return this;
    }

    /**
     * Select the AWS Environment.
     */
    public SourceAmazonSellerPartner withAwsEnvironment(AWSEnvironment awsEnvironment) {
        Utils.checkNotNull(awsEnvironment, "awsEnvironment");
        this.awsEnvironment = Optional.ofNullable(awsEnvironment);
        return this;
    }

    /**
     * Select the AWS Environment.
     */
    public SourceAmazonSellerPartner withAwsEnvironment(Optional<? extends AWSEnvironment> awsEnvironment) {
        Utils.checkNotNull(awsEnvironment, "awsEnvironment");
        this.awsEnvironment = awsEnvironment;
        return this;
    }

    /**
     * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
     * 
     * <p>- **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
     * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
     * 
     * <p>Select a step size that matches your data volume to optimize syncing speed and API performance.
     */
    public SourceAmazonSellerPartner withFinancialEventsStep(FinancialEventsStepSizeInDays financialEventsStep) {
        Utils.checkNotNull(financialEventsStep, "financialEventsStep");
        this.financialEventsStep = Optional.ofNullable(financialEventsStep);
        return this;
    }

    /**
     * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
     * 
     * <p>- **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
     * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
     * 
     * <p>Select a step size that matches your data volume to optimize syncing speed and API performance.
     */
    public SourceAmazonSellerPartner withFinancialEventsStep(Optional<? extends FinancialEventsStepSizeInDays> financialEventsStep) {
        Utils.checkNotNull(financialEventsStep, "financialEventsStep");
        this.financialEventsStep = financialEventsStep;
        return this;
    }

    /**
     * Your Login with Amazon Client ID.
     */
    public SourceAmazonSellerPartner withLwaAppId(String lwaAppId) {
        Utils.checkNotNull(lwaAppId, "lwaAppId");
        this.lwaAppId = lwaAppId;
        return this;
    }

    /**
     * Your Login with Amazon Client Secret.
     */
    public SourceAmazonSellerPartner withLwaClientSecret(String lwaClientSecret) {
        Utils.checkNotNull(lwaClientSecret, "lwaClientSecret");
        this.lwaClientSecret = lwaClientSecret;
        return this;
    }

    /**
     * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day.
     */
    public SourceAmazonSellerPartner withPeriodInDays(long periodInDays) {
        Utils.checkNotNull(periodInDays, "periodInDays");
        this.periodInDays = Optional.ofNullable(periodInDays);
        return this;
    }

    /**
     * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day.
     */
    public SourceAmazonSellerPartner withPeriodInDays(Optional<Long> periodInDays) {
        Utils.checkNotNull(periodInDays, "periodInDays");
        this.periodInDays = periodInDays;
        return this;
    }

    /**
     * The Refresh Token obtained via OAuth flow authorization.
     */
    public SourceAmazonSellerPartner withRefreshToken(String refreshToken) {
        Utils.checkNotNull(refreshToken, "refreshToken");
        this.refreshToken = refreshToken;
        return this;
    }

    /**
     * Select the AWS Region.
     */
    public SourceAmazonSellerPartner withRegion(AWSRegion region) {
        Utils.checkNotNull(region, "region");
        this.region = Optional.ofNullable(region);
        return this;
    }

    /**
     * Select the AWS Region.
     */
    public SourceAmazonSellerPartner withRegion(Optional<? extends AWSRegion> region) {
        Utils.checkNotNull(region, "region");
        this.region = region;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    public SourceAmazonSellerPartner withReplicationEndDate(OffsetDateTime replicationEndDate) {
        Utils.checkNotNull(replicationEndDate, "replicationEndDate");
        this.replicationEndDate = Optional.ofNullable(replicationEndDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    public SourceAmazonSellerPartner withReplicationEndDate(Optional<OffsetDateTime> replicationEndDate) {
        Utils.checkNotNull(replicationEndDate, "replicationEndDate");
        this.replicationEndDate = replicationEndDate;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
     */
    public SourceAmazonSellerPartner withReplicationStartDate(OffsetDateTime replicationStartDate) {
        Utils.checkNotNull(replicationStartDate, "replicationStartDate");
        this.replicationStartDate = Optional.ofNullable(replicationStartDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
     */
    public SourceAmazonSellerPartner withReplicationStartDate(Optional<OffsetDateTime> replicationStartDate) {
        Utils.checkNotNull(replicationStartDate, "replicationStartDate");
        this.replicationStartDate = replicationStartDate;
        return this;
    }

    /**
     * Additional information passed to reports. This varies by report type.
     */
    public SourceAmazonSellerPartner withReportOptionsList(List<ReportOptions> reportOptionsList) {
        Utils.checkNotNull(reportOptionsList, "reportOptionsList");
        this.reportOptionsList = Optional.ofNullable(reportOptionsList);
        return this;
    }

    /**
     * Additional information passed to reports. This varies by report type.
     */
    public SourceAmazonSellerPartner withReportOptionsList(Optional<? extends List<ReportOptions>> reportOptionsList) {
        Utils.checkNotNull(reportOptionsList, "reportOptionsList");
        this.reportOptionsList = reportOptionsList;
        return this;
    }

    /**
     * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See &lt;a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank"&gt;Troubleshooting&lt;/a&gt; section for more details
     */
    public SourceAmazonSellerPartner withWaitToAvoidFatalErrors(boolean waitToAvoidFatalErrors) {
        Utils.checkNotNull(waitToAvoidFatalErrors, "waitToAvoidFatalErrors");
        this.waitToAvoidFatalErrors = Optional.ofNullable(waitToAvoidFatalErrors);
        return this;
    }

    /**
     * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See &lt;a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank"&gt;Troubleshooting&lt;/a&gt; section for more details
     */
    public SourceAmazonSellerPartner withWaitToAvoidFatalErrors(Optional<Boolean> waitToAvoidFatalErrors) {
        Utils.checkNotNull(waitToAvoidFatalErrors, "waitToAvoidFatalErrors");
        this.waitToAvoidFatalErrors = waitToAvoidFatalErrors;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceAmazonSellerPartner other = (SourceAmazonSellerPartner) o;
        return 
            Objects.deepEquals(this.accountType, other.accountType) &&
            Objects.deepEquals(this.appId, other.appId) &&
            Objects.deepEquals(this.authType, other.authType) &&
            Objects.deepEquals(this.awsEnvironment, other.awsEnvironment) &&
            Objects.deepEquals(this.financialEventsStep, other.financialEventsStep) &&
            Objects.deepEquals(this.lwaAppId, other.lwaAppId) &&
            Objects.deepEquals(this.lwaClientSecret, other.lwaClientSecret) &&
            Objects.deepEquals(this.periodInDays, other.periodInDays) &&
            Objects.deepEquals(this.refreshToken, other.refreshToken) &&
            Objects.deepEquals(this.region, other.region) &&
            Objects.deepEquals(this.replicationEndDate, other.replicationEndDate) &&
            Objects.deepEquals(this.replicationStartDate, other.replicationStartDate) &&
            Objects.deepEquals(this.reportOptionsList, other.reportOptionsList) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.waitToAvoidFatalErrors, other.waitToAvoidFatalErrors);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            accountType,
            appId,
            authType,
            awsEnvironment,
            financialEventsStep,
            lwaAppId,
            lwaClientSecret,
            periodInDays,
            refreshToken,
            region,
            replicationEndDate,
            replicationStartDate,
            reportOptionsList,
            sourceType,
            waitToAvoidFatalErrors);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceAmazonSellerPartner.class,
                "accountType", accountType,
                "appId", appId,
                "authType", authType,
                "awsEnvironment", awsEnvironment,
                "financialEventsStep", financialEventsStep,
                "lwaAppId", lwaAppId,
                "lwaClientSecret", lwaClientSecret,
                "periodInDays", periodInDays,
                "refreshToken", refreshToken,
                "region", region,
                "replicationEndDate", replicationEndDate,
                "replicationStartDate", replicationStartDate,
                "reportOptionsList", reportOptionsList,
                "sourceType", sourceType,
                "waitToAvoidFatalErrors", waitToAvoidFatalErrors);
    }
    
    public final static class Builder {
 
        private Optional<? extends AWSSellerPartnerAccountType> accountType;
 
        private Optional<String> appId = Optional.empty();
 
        private Optional<? extends AWSEnvironment> awsEnvironment;
 
        private Optional<? extends FinancialEventsStepSizeInDays> financialEventsStep;
 
        private String lwaAppId;
 
        private String lwaClientSecret;
 
        private Optional<Long> periodInDays;
 
        private String refreshToken;
 
        private Optional<? extends AWSRegion> region;
 
        private Optional<OffsetDateTime> replicationEndDate = Optional.empty();
 
        private Optional<OffsetDateTime> replicationStartDate = Optional.empty();
 
        private Optional<? extends List<ReportOptions>> reportOptionsList = Optional.empty();
 
        private Optional<Boolean> waitToAvoidFatalErrors;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Type of the Account you're going to authorize the Airbyte application by
         */
        public Builder accountType(AWSSellerPartnerAccountType accountType) {
            Utils.checkNotNull(accountType, "accountType");
            this.accountType = Optional.ofNullable(accountType);
            return this;
        }

        /**
         * Type of the Account you're going to authorize the Airbyte application by
         */
        public Builder accountType(Optional<? extends AWSSellerPartnerAccountType> accountType) {
            Utils.checkNotNull(accountType, "accountType");
            this.accountType = accountType;
            return this;
        }

        /**
         * Your Amazon Application ID.
         */
        public Builder appId(String appId) {
            Utils.checkNotNull(appId, "appId");
            this.appId = Optional.ofNullable(appId);
            return this;
        }

        /**
         * Your Amazon Application ID.
         */
        public Builder appId(Optional<String> appId) {
            Utils.checkNotNull(appId, "appId");
            this.appId = appId;
            return this;
        }

        /**
         * Select the AWS Environment.
         */
        public Builder awsEnvironment(AWSEnvironment awsEnvironment) {
            Utils.checkNotNull(awsEnvironment, "awsEnvironment");
            this.awsEnvironment = Optional.ofNullable(awsEnvironment);
            return this;
        }

        /**
         * Select the AWS Environment.
         */
        public Builder awsEnvironment(Optional<? extends AWSEnvironment> awsEnvironment) {
            Utils.checkNotNull(awsEnvironment, "awsEnvironment");
            this.awsEnvironment = awsEnvironment;
            return this;
        }

        /**
         * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
         * 
         * <p>- **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
         * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
         * 
         * <p>Select a step size that matches your data volume to optimize syncing speed and API performance.
         */
        public Builder financialEventsStep(FinancialEventsStepSizeInDays financialEventsStep) {
            Utils.checkNotNull(financialEventsStep, "financialEventsStep");
            this.financialEventsStep = Optional.ofNullable(financialEventsStep);
            return this;
        }

        /**
         * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
         * 
         * <p>- **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
         * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
         * 
         * <p>Select a step size that matches your data volume to optimize syncing speed and API performance.
         */
        public Builder financialEventsStep(Optional<? extends FinancialEventsStepSizeInDays> financialEventsStep) {
            Utils.checkNotNull(financialEventsStep, "financialEventsStep");
            this.financialEventsStep = financialEventsStep;
            return this;
        }

        /**
         * Your Login with Amazon Client ID.
         */
        public Builder lwaAppId(String lwaAppId) {
            Utils.checkNotNull(lwaAppId, "lwaAppId");
            this.lwaAppId = lwaAppId;
            return this;
        }

        /**
         * Your Login with Amazon Client Secret.
         */
        public Builder lwaClientSecret(String lwaClientSecret) {
            Utils.checkNotNull(lwaClientSecret, "lwaClientSecret");
            this.lwaClientSecret = lwaClientSecret;
            return this;
        }

        /**
         * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day.
         */
        public Builder periodInDays(long periodInDays) {
            Utils.checkNotNull(periodInDays, "periodInDays");
            this.periodInDays = Optional.ofNullable(periodInDays);
            return this;
        }

        /**
         * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day.
         */
        public Builder periodInDays(Optional<Long> periodInDays) {
            Utils.checkNotNull(periodInDays, "periodInDays");
            this.periodInDays = periodInDays;
            return this;
        }

        /**
         * The Refresh Token obtained via OAuth flow authorization.
         */
        public Builder refreshToken(String refreshToken) {
            Utils.checkNotNull(refreshToken, "refreshToken");
            this.refreshToken = refreshToken;
            return this;
        }

        /**
         * Select the AWS Region.
         */
        public Builder region(AWSRegion region) {
            Utils.checkNotNull(region, "region");
            this.region = Optional.ofNullable(region);
            return this;
        }

        /**
         * Select the AWS Region.
         */
        public Builder region(Optional<? extends AWSRegion> region) {
            Utils.checkNotNull(region, "region");
            this.region = region;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
         */
        public Builder replicationEndDate(OffsetDateTime replicationEndDate) {
            Utils.checkNotNull(replicationEndDate, "replicationEndDate");
            this.replicationEndDate = Optional.ofNullable(replicationEndDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
         */
        public Builder replicationEndDate(Optional<OffsetDateTime> replicationEndDate) {
            Utils.checkNotNull(replicationEndDate, "replicationEndDate");
            this.replicationEndDate = replicationEndDate;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
         */
        public Builder replicationStartDate(OffsetDateTime replicationStartDate) {
            Utils.checkNotNull(replicationStartDate, "replicationStartDate");
            this.replicationStartDate = Optional.ofNullable(replicationStartDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
         */
        public Builder replicationStartDate(Optional<OffsetDateTime> replicationStartDate) {
            Utils.checkNotNull(replicationStartDate, "replicationStartDate");
            this.replicationStartDate = replicationStartDate;
            return this;
        }

        /**
         * Additional information passed to reports. This varies by report type.
         */
        public Builder reportOptionsList(List<ReportOptions> reportOptionsList) {
            Utils.checkNotNull(reportOptionsList, "reportOptionsList");
            this.reportOptionsList = Optional.ofNullable(reportOptionsList);
            return this;
        }

        /**
         * Additional information passed to reports. This varies by report type.
         */
        public Builder reportOptionsList(Optional<? extends List<ReportOptions>> reportOptionsList) {
            Utils.checkNotNull(reportOptionsList, "reportOptionsList");
            this.reportOptionsList = reportOptionsList;
            return this;
        }

        /**
         * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See &lt;a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank"&gt;Troubleshooting&lt;/a&gt; section for more details
         */
        public Builder waitToAvoidFatalErrors(boolean waitToAvoidFatalErrors) {
            Utils.checkNotNull(waitToAvoidFatalErrors, "waitToAvoidFatalErrors");
            this.waitToAvoidFatalErrors = Optional.ofNullable(waitToAvoidFatalErrors);
            return this;
        }

        /**
         * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See &lt;a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank"&gt;Troubleshooting&lt;/a&gt; section for more details
         */
        public Builder waitToAvoidFatalErrors(Optional<Boolean> waitToAvoidFatalErrors) {
            Utils.checkNotNull(waitToAvoidFatalErrors, "waitToAvoidFatalErrors");
            this.waitToAvoidFatalErrors = waitToAvoidFatalErrors;
            return this;
        }
        
        public SourceAmazonSellerPartner build() {
            if (accountType == null) {
                accountType = _SINGLETON_VALUE_AccountType.value();
            }
            if (awsEnvironment == null) {
                awsEnvironment = _SINGLETON_VALUE_AwsEnvironment.value();
            }
            if (financialEventsStep == null) {
                financialEventsStep = _SINGLETON_VALUE_FinancialEventsStep.value();
            }
            if (periodInDays == null) {
                periodInDays = _SINGLETON_VALUE_PeriodInDays.value();
            }
            if (region == null) {
                region = _SINGLETON_VALUE_Region.value();
            }
            if (waitToAvoidFatalErrors == null) {
                waitToAvoidFatalErrors = _SINGLETON_VALUE_WaitToAvoidFatalErrors.value();
            }
            return new SourceAmazonSellerPartner(
                accountType,
                appId,
                awsEnvironment,
                financialEventsStep,
                lwaAppId,
                lwaClientSecret,
                periodInDays,
                refreshToken,
                region,
                replicationEndDate,
                replicationStartDate,
                reportOptionsList,
                waitToAvoidFatalErrors);
        }

        private static final LazySingletonValue<Optional<? extends AWSSellerPartnerAccountType>> _SINGLETON_VALUE_AccountType =
                new LazySingletonValue<>(
                        "account_type",
                        "\"Seller\"",
                        new TypeReference<Optional<? extends AWSSellerPartnerAccountType>>() {});

        private static final LazySingletonValue<Optional<? extends SourceAmazonSellerPartnerAuthType>> _SINGLETON_VALUE_AuthType =
                new LazySingletonValue<>(
                        "auth_type",
                        "\"oauth2.0\"",
                        new TypeReference<Optional<? extends SourceAmazonSellerPartnerAuthType>>() {});

        private static final LazySingletonValue<Optional<? extends AWSEnvironment>> _SINGLETON_VALUE_AwsEnvironment =
                new LazySingletonValue<>(
                        "aws_environment",
                        "\"PRODUCTION\"",
                        new TypeReference<Optional<? extends AWSEnvironment>>() {});

        private static final LazySingletonValue<Optional<? extends FinancialEventsStepSizeInDays>> _SINGLETON_VALUE_FinancialEventsStep =
                new LazySingletonValue<>(
                        "financial_events_step",
                        "\"180\"",
                        new TypeReference<Optional<? extends FinancialEventsStepSizeInDays>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_PeriodInDays =
                new LazySingletonValue<>(
                        "period_in_days",
                        "90",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<? extends AWSRegion>> _SINGLETON_VALUE_Region =
                new LazySingletonValue<>(
                        "region",
                        "\"US\"",
                        new TypeReference<Optional<? extends AWSRegion>>() {});

        private static final LazySingletonValue<SourceAmazonSellerPartnerAmazonSellerPartner> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"amazon-seller-partner\"",
                        new TypeReference<SourceAmazonSellerPartnerAmazonSellerPartner>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_WaitToAvoidFatalErrors =
                new LazySingletonValue<>(
                        "wait_to_avoid_fatal_errors",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});
    }
}
