/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * InsightConfig - Config for custom insights
 */

public class InsightConfig {

    /**
     * A list of chosen action_breakdowns for action_breakdowns
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("action_breakdowns")
    private Optional<? extends List<ValidActionBreakdowns>> actionBreakdowns;

    /**
     * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("action_report_time")
    private Optional<? extends SourceFacebookMarketingActionReportTime> actionReportTime;

    /**
     * A list of chosen breakdowns for breakdowns
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("breakdowns")
    private Optional<? extends List<ValidBreakdowns>> breakdowns;

    /**
     * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("end_date")
    private Optional<OffsetDateTime> endDate;

    /**
     * A list of chosen fields for fields parameter
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fields")
    private Optional<? extends List<SourceFacebookMarketingValidEnums>> fields;

    /**
     * The insights job timeout
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("insights_job_timeout")
    private Optional<Long> insightsJobTimeout;

    /**
     * The attribution window
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("insights_lookback_window")
    private Optional<Long> insightsLookbackWindow;

    /**
     * Chosen level for API
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("level")
    private Optional<? extends Level> level;

    /**
     * The name value of insight
     */
    @JsonProperty("name")
    private String name;

    /**
     * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<OffsetDateTime> startDate;

    /**
     * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("time_increment")
    private Optional<Long> timeIncrement;

    @JsonCreator
    public InsightConfig(
            @JsonProperty("action_breakdowns") Optional<? extends List<ValidActionBreakdowns>> actionBreakdowns,
            @JsonProperty("action_report_time") Optional<? extends SourceFacebookMarketingActionReportTime> actionReportTime,
            @JsonProperty("breakdowns") Optional<? extends List<ValidBreakdowns>> breakdowns,
            @JsonProperty("end_date") Optional<OffsetDateTime> endDate,
            @JsonProperty("fields") Optional<? extends List<SourceFacebookMarketingValidEnums>> fields,
            @JsonProperty("insights_job_timeout") Optional<Long> insightsJobTimeout,
            @JsonProperty("insights_lookback_window") Optional<Long> insightsLookbackWindow,
            @JsonProperty("level") Optional<? extends Level> level,
            @JsonProperty("name") String name,
            @JsonProperty("start_date") Optional<OffsetDateTime> startDate,
            @JsonProperty("time_increment") Optional<Long> timeIncrement) {
        Utils.checkNotNull(actionBreakdowns, "actionBreakdowns");
        Utils.checkNotNull(actionReportTime, "actionReportTime");
        Utils.checkNotNull(breakdowns, "breakdowns");
        Utils.checkNotNull(endDate, "endDate");
        Utils.checkNotNull(fields, "fields");
        Utils.checkNotNull(insightsJobTimeout, "insightsJobTimeout");
        Utils.checkNotNull(insightsLookbackWindow, "insightsLookbackWindow");
        Utils.checkNotNull(level, "level");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(timeIncrement, "timeIncrement");
        this.actionBreakdowns = actionBreakdowns;
        this.actionReportTime = actionReportTime;
        this.breakdowns = breakdowns;
        this.endDate = endDate;
        this.fields = fields;
        this.insightsJobTimeout = insightsJobTimeout;
        this.insightsLookbackWindow = insightsLookbackWindow;
        this.level = level;
        this.name = name;
        this.startDate = startDate;
        this.timeIncrement = timeIncrement;
    }
    
    public InsightConfig(
            String name) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), name, Optional.empty(), Optional.empty());
    }

    /**
     * A list of chosen action_breakdowns for action_breakdowns
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ValidActionBreakdowns>> actionBreakdowns() {
        return (Optional<List<ValidActionBreakdowns>>) actionBreakdowns;
    }

    /**
     * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceFacebookMarketingActionReportTime> actionReportTime() {
        return (Optional<SourceFacebookMarketingActionReportTime>) actionReportTime;
    }

    /**
     * A list of chosen breakdowns for breakdowns
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ValidBreakdowns>> breakdowns() {
        return (Optional<List<ValidBreakdowns>>) breakdowns;
    }

    /**
     * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> endDate() {
        return endDate;
    }

    /**
     * A list of chosen fields for fields parameter
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SourceFacebookMarketingValidEnums>> fields() {
        return (Optional<List<SourceFacebookMarketingValidEnums>>) fields;
    }

    /**
     * The insights job timeout
     */
    @JsonIgnore
    public Optional<Long> insightsJobTimeout() {
        return insightsJobTimeout;
    }

    /**
     * The attribution window
     */
    @JsonIgnore
    public Optional<Long> insightsLookbackWindow() {
        return insightsLookbackWindow;
    }

    /**
     * Chosen level for API
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Level> level() {
        return (Optional<Level>) level;
    }

    /**
     * The name value of insight
     */
    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> startDate() {
        return startDate;
    }

    /**
     * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89.
     */
    @JsonIgnore
    public Optional<Long> timeIncrement() {
        return timeIncrement;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * A list of chosen action_breakdowns for action_breakdowns
     */
    public InsightConfig withActionBreakdowns(List<ValidActionBreakdowns> actionBreakdowns) {
        Utils.checkNotNull(actionBreakdowns, "actionBreakdowns");
        this.actionBreakdowns = Optional.ofNullable(actionBreakdowns);
        return this;
    }

    /**
     * A list of chosen action_breakdowns for action_breakdowns
     */
    public InsightConfig withActionBreakdowns(Optional<? extends List<ValidActionBreakdowns>> actionBreakdowns) {
        Utils.checkNotNull(actionBreakdowns, "actionBreakdowns");
        this.actionBreakdowns = actionBreakdowns;
        return this;
    }

    /**
     * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd.
     */
    public InsightConfig withActionReportTime(SourceFacebookMarketingActionReportTime actionReportTime) {
        Utils.checkNotNull(actionReportTime, "actionReportTime");
        this.actionReportTime = Optional.ofNullable(actionReportTime);
        return this;
    }

    /**
     * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd.
     */
    public InsightConfig withActionReportTime(Optional<? extends SourceFacebookMarketingActionReportTime> actionReportTime) {
        Utils.checkNotNull(actionReportTime, "actionReportTime");
        this.actionReportTime = actionReportTime;
        return this;
    }

    /**
     * A list of chosen breakdowns for breakdowns
     */
    public InsightConfig withBreakdowns(List<ValidBreakdowns> breakdowns) {
        Utils.checkNotNull(breakdowns, "breakdowns");
        this.breakdowns = Optional.ofNullable(breakdowns);
        return this;
    }

    /**
     * A list of chosen breakdowns for breakdowns
     */
    public InsightConfig withBreakdowns(Optional<? extends List<ValidBreakdowns>> breakdowns) {
        Utils.checkNotNull(breakdowns, "breakdowns");
        this.breakdowns = breakdowns;
        return this;
    }

    /**
     * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    public InsightConfig withEndDate(OffsetDateTime endDate) {
        Utils.checkNotNull(endDate, "endDate");
        this.endDate = Optional.ofNullable(endDate);
        return this;
    }

    /**
     * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    public InsightConfig withEndDate(Optional<OffsetDateTime> endDate) {
        Utils.checkNotNull(endDate, "endDate");
        this.endDate = endDate;
        return this;
    }

    /**
     * A list of chosen fields for fields parameter
     */
    public InsightConfig withFields(List<SourceFacebookMarketingValidEnums> fields) {
        Utils.checkNotNull(fields, "fields");
        this.fields = Optional.ofNullable(fields);
        return this;
    }

    /**
     * A list of chosen fields for fields parameter
     */
    public InsightConfig withFields(Optional<? extends List<SourceFacebookMarketingValidEnums>> fields) {
        Utils.checkNotNull(fields, "fields");
        this.fields = fields;
        return this;
    }

    /**
     * The insights job timeout
     */
    public InsightConfig withInsightsJobTimeout(long insightsJobTimeout) {
        Utils.checkNotNull(insightsJobTimeout, "insightsJobTimeout");
        this.insightsJobTimeout = Optional.ofNullable(insightsJobTimeout);
        return this;
    }

    /**
     * The insights job timeout
     */
    public InsightConfig withInsightsJobTimeout(Optional<Long> insightsJobTimeout) {
        Utils.checkNotNull(insightsJobTimeout, "insightsJobTimeout");
        this.insightsJobTimeout = insightsJobTimeout;
        return this;
    }

    /**
     * The attribution window
     */
    public InsightConfig withInsightsLookbackWindow(long insightsLookbackWindow) {
        Utils.checkNotNull(insightsLookbackWindow, "insightsLookbackWindow");
        this.insightsLookbackWindow = Optional.ofNullable(insightsLookbackWindow);
        return this;
    }

    /**
     * The attribution window
     */
    public InsightConfig withInsightsLookbackWindow(Optional<Long> insightsLookbackWindow) {
        Utils.checkNotNull(insightsLookbackWindow, "insightsLookbackWindow");
        this.insightsLookbackWindow = insightsLookbackWindow;
        return this;
    }

    /**
     * Chosen level for API
     */
    public InsightConfig withLevel(Level level) {
        Utils.checkNotNull(level, "level");
        this.level = Optional.ofNullable(level);
        return this;
    }

    /**
     * Chosen level for API
     */
    public InsightConfig withLevel(Optional<? extends Level> level) {
        Utils.checkNotNull(level, "level");
        this.level = level;
        return this;
    }

    /**
     * The name value of insight
     */
    public InsightConfig withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
     */
    public InsightConfig withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
     */
    public InsightConfig withStartDate(Optional<OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89.
     */
    public InsightConfig withTimeIncrement(long timeIncrement) {
        Utils.checkNotNull(timeIncrement, "timeIncrement");
        this.timeIncrement = Optional.ofNullable(timeIncrement);
        return this;
    }

    /**
     * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89.
     */
    public InsightConfig withTimeIncrement(Optional<Long> timeIncrement) {
        Utils.checkNotNull(timeIncrement, "timeIncrement");
        this.timeIncrement = timeIncrement;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        InsightConfig other = (InsightConfig) o;
        return 
            Objects.deepEquals(this.actionBreakdowns, other.actionBreakdowns) &&
            Objects.deepEquals(this.actionReportTime, other.actionReportTime) &&
            Objects.deepEquals(this.breakdowns, other.breakdowns) &&
            Objects.deepEquals(this.endDate, other.endDate) &&
            Objects.deepEquals(this.fields, other.fields) &&
            Objects.deepEquals(this.insightsJobTimeout, other.insightsJobTimeout) &&
            Objects.deepEquals(this.insightsLookbackWindow, other.insightsLookbackWindow) &&
            Objects.deepEquals(this.level, other.level) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.timeIncrement, other.timeIncrement);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            actionBreakdowns,
            actionReportTime,
            breakdowns,
            endDate,
            fields,
            insightsJobTimeout,
            insightsLookbackWindow,
            level,
            name,
            startDate,
            timeIncrement);
    }
    
    @Override
    public String toString() {
        return Utils.toString(InsightConfig.class,
                "actionBreakdowns", actionBreakdowns,
                "actionReportTime", actionReportTime,
                "breakdowns", breakdowns,
                "endDate", endDate,
                "fields", fields,
                "insightsJobTimeout", insightsJobTimeout,
                "insightsLookbackWindow", insightsLookbackWindow,
                "level", level,
                "name", name,
                "startDate", startDate,
                "timeIncrement", timeIncrement);
    }
    
    public final static class Builder {
 
        private Optional<? extends List<ValidActionBreakdowns>> actionBreakdowns = Optional.empty();
 
        private Optional<? extends SourceFacebookMarketingActionReportTime> actionReportTime;
 
        private Optional<? extends List<ValidBreakdowns>> breakdowns = Optional.empty();
 
        private Optional<OffsetDateTime> endDate = Optional.empty();
 
        private Optional<? extends List<SourceFacebookMarketingValidEnums>> fields = Optional.empty();
 
        private Optional<Long> insightsJobTimeout;
 
        private Optional<Long> insightsLookbackWindow;
 
        private Optional<? extends Level> level;
 
        private String name;
 
        private Optional<OffsetDateTime> startDate = Optional.empty();
 
        private Optional<Long> timeIncrement;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * A list of chosen action_breakdowns for action_breakdowns
         */
        public Builder actionBreakdowns(List<ValidActionBreakdowns> actionBreakdowns) {
            Utils.checkNotNull(actionBreakdowns, "actionBreakdowns");
            this.actionBreakdowns = Optional.ofNullable(actionBreakdowns);
            return this;
        }

        /**
         * A list of chosen action_breakdowns for action_breakdowns
         */
        public Builder actionBreakdowns(Optional<? extends List<ValidActionBreakdowns>> actionBreakdowns) {
            Utils.checkNotNull(actionBreakdowns, "actionBreakdowns");
            this.actionBreakdowns = actionBreakdowns;
            return this;
        }

        /**
         * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd.
         */
        public Builder actionReportTime(SourceFacebookMarketingActionReportTime actionReportTime) {
            Utils.checkNotNull(actionReportTime, "actionReportTime");
            this.actionReportTime = Optional.ofNullable(actionReportTime);
            return this;
        }

        /**
         * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd.
         */
        public Builder actionReportTime(Optional<? extends SourceFacebookMarketingActionReportTime> actionReportTime) {
            Utils.checkNotNull(actionReportTime, "actionReportTime");
            this.actionReportTime = actionReportTime;
            return this;
        }

        /**
         * A list of chosen breakdowns for breakdowns
         */
        public Builder breakdowns(List<ValidBreakdowns> breakdowns) {
            Utils.checkNotNull(breakdowns, "breakdowns");
            this.breakdowns = Optional.ofNullable(breakdowns);
            return this;
        }

        /**
         * A list of chosen breakdowns for breakdowns
         */
        public Builder breakdowns(Optional<? extends List<ValidBreakdowns>> breakdowns) {
            Utils.checkNotNull(breakdowns, "breakdowns");
            this.breakdowns = breakdowns;
            return this;
        }

        /**
         * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
         */
        public Builder endDate(OffsetDateTime endDate) {
            Utils.checkNotNull(endDate, "endDate");
            this.endDate = Optional.ofNullable(endDate);
            return this;
        }

        /**
         * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
         */
        public Builder endDate(Optional<OffsetDateTime> endDate) {
            Utils.checkNotNull(endDate, "endDate");
            this.endDate = endDate;
            return this;
        }

        /**
         * A list of chosen fields for fields parameter
         */
        public Builder fields(List<SourceFacebookMarketingValidEnums> fields) {
            Utils.checkNotNull(fields, "fields");
            this.fields = Optional.ofNullable(fields);
            return this;
        }

        /**
         * A list of chosen fields for fields parameter
         */
        public Builder fields(Optional<? extends List<SourceFacebookMarketingValidEnums>> fields) {
            Utils.checkNotNull(fields, "fields");
            this.fields = fields;
            return this;
        }

        /**
         * The insights job timeout
         */
        public Builder insightsJobTimeout(long insightsJobTimeout) {
            Utils.checkNotNull(insightsJobTimeout, "insightsJobTimeout");
            this.insightsJobTimeout = Optional.ofNullable(insightsJobTimeout);
            return this;
        }

        /**
         * The insights job timeout
         */
        public Builder insightsJobTimeout(Optional<Long> insightsJobTimeout) {
            Utils.checkNotNull(insightsJobTimeout, "insightsJobTimeout");
            this.insightsJobTimeout = insightsJobTimeout;
            return this;
        }

        /**
         * The attribution window
         */
        public Builder insightsLookbackWindow(long insightsLookbackWindow) {
            Utils.checkNotNull(insightsLookbackWindow, "insightsLookbackWindow");
            this.insightsLookbackWindow = Optional.ofNullable(insightsLookbackWindow);
            return this;
        }

        /**
         * The attribution window
         */
        public Builder insightsLookbackWindow(Optional<Long> insightsLookbackWindow) {
            Utils.checkNotNull(insightsLookbackWindow, "insightsLookbackWindow");
            this.insightsLookbackWindow = insightsLookbackWindow;
            return this;
        }

        /**
         * Chosen level for API
         */
        public Builder level(Level level) {
            Utils.checkNotNull(level, "level");
            this.level = Optional.ofNullable(level);
            return this;
        }

        /**
         * Chosen level for API
         */
        public Builder level(Optional<? extends Level> level) {
            Utils.checkNotNull(level, "level");
            this.level = level;
            return this;
        }

        /**
         * The name value of insight
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
         */
        public Builder startDate(Optional<OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89.
         */
        public Builder timeIncrement(long timeIncrement) {
            Utils.checkNotNull(timeIncrement, "timeIncrement");
            this.timeIncrement = Optional.ofNullable(timeIncrement);
            return this;
        }

        /**
         * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89.
         */
        public Builder timeIncrement(Optional<Long> timeIncrement) {
            Utils.checkNotNull(timeIncrement, "timeIncrement");
            this.timeIncrement = timeIncrement;
            return this;
        }
        
        public InsightConfig build() {
            if (actionReportTime == null) {
                actionReportTime = _SINGLETON_VALUE_ActionReportTime.value();
            }
            if (insightsJobTimeout == null) {
                insightsJobTimeout = _SINGLETON_VALUE_InsightsJobTimeout.value();
            }
            if (insightsLookbackWindow == null) {
                insightsLookbackWindow = _SINGLETON_VALUE_InsightsLookbackWindow.value();
            }
            if (level == null) {
                level = _SINGLETON_VALUE_Level.value();
            }
            if (timeIncrement == null) {
                timeIncrement = _SINGLETON_VALUE_TimeIncrement.value();
            }            return new InsightConfig(
                actionBreakdowns,
                actionReportTime,
                breakdowns,
                endDate,
                fields,
                insightsJobTimeout,
                insightsLookbackWindow,
                level,
                name,
                startDate,
                timeIncrement);
        }

        private static final LazySingletonValue<Optional<? extends SourceFacebookMarketingActionReportTime>> _SINGLETON_VALUE_ActionReportTime =
                new LazySingletonValue<>(
                        "action_report_time",
                        "\"mixed\"",
                        new TypeReference<Optional<? extends SourceFacebookMarketingActionReportTime>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_InsightsJobTimeout =
                new LazySingletonValue<>(
                        "insights_job_timeout",
                        "60",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_InsightsLookbackWindow =
                new LazySingletonValue<>(
                        "insights_lookback_window",
                        "28",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<? extends Level>> _SINGLETON_VALUE_Level =
                new LazySingletonValue<>(
                        "level",
                        "\"ad\"",
                        new TypeReference<Optional<? extends Level>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_TimeIncrement =
                new LazySingletonValue<>(
                        "time_increment",
                        "1",
                        new TypeReference<Optional<Long>>() {});
    }
}

