/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * SourceMicrosoftOnedrive - SourceMicrosoftOneDriveSpec class for Microsoft OneDrive Source Specification.
 * This class combines the authentication details with additional configuration for the OneDrive API.
 */

public class SourceMicrosoftOnedrive {

    /**
     * Credentials for connecting to the One Drive API
     */
    @JsonProperty("credentials")
    private SourceMicrosoftOnedriveAuthentication credentials;

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("drive_name")
    private Optional<String> driveName;

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("folder_path")
    private Optional<String> folderPath;

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("search_scope")
    private Optional<? extends SearchScope> searchScope;

    @JsonProperty("sourceType")
    private SourceMicrosoftOnedriveMicrosoftOnedrive sourceType;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<OffsetDateTime> startDate;

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonProperty("streams")
    private List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams;

    @JsonCreator
    public SourceMicrosoftOnedrive(
            @JsonProperty("credentials") SourceMicrosoftOnedriveAuthentication credentials,
            @JsonProperty("drive_name") Optional<String> driveName,
            @JsonProperty("folder_path") Optional<String> folderPath,
            @JsonProperty("search_scope") Optional<? extends SearchScope> searchScope,
            @JsonProperty("start_date") Optional<OffsetDateTime> startDate,
            @JsonProperty("streams") List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
        Utils.checkNotNull(credentials, "credentials");
        Utils.checkNotNull(driveName, "driveName");
        Utils.checkNotNull(folderPath, "folderPath");
        Utils.checkNotNull(searchScope, "searchScope");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(streams, "streams");
        this.credentials = credentials;
        this.driveName = driveName;
        this.folderPath = folderPath;
        this.searchScope = searchScope;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.streams = streams;
    }
    
    public SourceMicrosoftOnedrive(
            SourceMicrosoftOnedriveAuthentication credentials,
            List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
        this(credentials, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), streams);
    }

    /**
     * Credentials for connecting to the One Drive API
     */
    @JsonIgnore
    public SourceMicrosoftOnedriveAuthentication credentials() {
        return credentials;
    }

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    @JsonIgnore
    public Optional<String> driveName() {
        return driveName;
    }

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    @JsonIgnore
    public Optional<String> folderPath() {
        return folderPath;
    }

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SearchScope> searchScope() {
        return (Optional<SearchScope>) searchScope;
    }

    @JsonIgnore
    public SourceMicrosoftOnedriveMicrosoftOnedrive sourceType() {
        return sourceType;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> startDate() {
        return startDate;
    }

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonIgnore
    public List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams() {
        return streams;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Credentials for connecting to the One Drive API
     */
    public SourceMicrosoftOnedrive withCredentials(SourceMicrosoftOnedriveAuthentication credentials) {
        Utils.checkNotNull(credentials, "credentials");
        this.credentials = credentials;
        return this;
    }

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    public SourceMicrosoftOnedrive withDriveName(String driveName) {
        Utils.checkNotNull(driveName, "driveName");
        this.driveName = Optional.ofNullable(driveName);
        return this;
    }

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    public SourceMicrosoftOnedrive withDriveName(Optional<String> driveName) {
        Utils.checkNotNull(driveName, "driveName");
        this.driveName = driveName;
        return this;
    }

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    public SourceMicrosoftOnedrive withFolderPath(String folderPath) {
        Utils.checkNotNull(folderPath, "folderPath");
        this.folderPath = Optional.ofNullable(folderPath);
        return this;
    }

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    public SourceMicrosoftOnedrive withFolderPath(Optional<String> folderPath) {
        Utils.checkNotNull(folderPath, "folderPath");
        this.folderPath = folderPath;
        return this;
    }

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    public SourceMicrosoftOnedrive withSearchScope(SearchScope searchScope) {
        Utils.checkNotNull(searchScope, "searchScope");
        this.searchScope = Optional.ofNullable(searchScope);
        return this;
    }

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    public SourceMicrosoftOnedrive withSearchScope(Optional<? extends SearchScope> searchScope) {
        Utils.checkNotNull(searchScope, "searchScope");
        this.searchScope = searchScope;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceMicrosoftOnedrive withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceMicrosoftOnedrive withStartDate(Optional<OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    public SourceMicrosoftOnedrive withStreams(List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
        Utils.checkNotNull(streams, "streams");
        this.streams = streams;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceMicrosoftOnedrive other = (SourceMicrosoftOnedrive) o;
        return 
            Objects.deepEquals(this.credentials, other.credentials) &&
            Objects.deepEquals(this.driveName, other.driveName) &&
            Objects.deepEquals(this.folderPath, other.folderPath) &&
            Objects.deepEquals(this.searchScope, other.searchScope) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.streams, other.streams);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            credentials,
            driveName,
            folderPath,
            searchScope,
            sourceType,
            startDate,
            streams);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceMicrosoftOnedrive.class,
                "credentials", credentials,
                "driveName", driveName,
                "folderPath", folderPath,
                "searchScope", searchScope,
                "sourceType", sourceType,
                "startDate", startDate,
                "streams", streams);
    }
    
    public final static class Builder {
 
        private SourceMicrosoftOnedriveAuthentication credentials;
 
        private Optional<String> driveName;
 
        private Optional<String> folderPath;
 
        private Optional<? extends SearchScope> searchScope;
 
        private Optional<OffsetDateTime> startDate = Optional.empty();
 
        private List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Credentials for connecting to the One Drive API
         */
        public Builder credentials(SourceMicrosoftOnedriveAuthentication credentials) {
            Utils.checkNotNull(credentials, "credentials");
            this.credentials = credentials;
            return this;
        }

        /**
         * Name of the Microsoft OneDrive drive where the file(s) exist.
         */
        public Builder driveName(String driveName) {
            Utils.checkNotNull(driveName, "driveName");
            this.driveName = Optional.ofNullable(driveName);
            return this;
        }

        /**
         * Name of the Microsoft OneDrive drive where the file(s) exist.
         */
        public Builder driveName(Optional<String> driveName) {
            Utils.checkNotNull(driveName, "driveName");
            this.driveName = driveName;
            return this;
        }

        /**
         * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
         */
        public Builder folderPath(String folderPath) {
            Utils.checkNotNull(folderPath, "folderPath");
            this.folderPath = Optional.ofNullable(folderPath);
            return this;
        }

        /**
         * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
         */
        public Builder folderPath(Optional<String> folderPath) {
            Utils.checkNotNull(folderPath, "folderPath");
            this.folderPath = folderPath;
            return this;
        }

        /**
         * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
         */
        public Builder searchScope(SearchScope searchScope) {
            Utils.checkNotNull(searchScope, "searchScope");
            this.searchScope = Optional.ofNullable(searchScope);
            return this;
        }

        /**
         * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
         */
        public Builder searchScope(Optional<? extends SearchScope> searchScope) {
            Utils.checkNotNull(searchScope, "searchScope");
            this.searchScope = searchScope;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(Optional<OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
         */
        public Builder streams(List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
            Utils.checkNotNull(streams, "streams");
            this.streams = streams;
            return this;
        }
        
        public SourceMicrosoftOnedrive build() {
            if (driveName == null) {
                driveName = _SINGLETON_VALUE_DriveName.value();
            }
            if (folderPath == null) {
                folderPath = _SINGLETON_VALUE_FolderPath.value();
            }
            if (searchScope == null) {
                searchScope = _SINGLETON_VALUE_SearchScope.value();
            }            return new SourceMicrosoftOnedrive(
                credentials,
                driveName,
                folderPath,
                searchScope,
                startDate,
                streams);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_DriveName =
                new LazySingletonValue<>(
                        "drive_name",
                        "\"OneDrive\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_FolderPath =
                new LazySingletonValue<>(
                        "folder_path",
                        "\".\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<? extends SearchScope>> _SINGLETON_VALUE_SearchScope =
                new LazySingletonValue<>(
                        "search_scope",
                        "\"ALL\"",
                        new TypeReference<Optional<? extends SearchScope>>() {});

        private static final LazySingletonValue<SourceMicrosoftOnedriveMicrosoftOnedrive> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"microsoft-onedrive\"",
                        new TypeReference<SourceMicrosoftOnedriveMicrosoftOnedrive>() {});
    }
}

