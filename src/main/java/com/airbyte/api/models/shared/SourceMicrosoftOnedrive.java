/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.OffsetDateTime;
import java.util.Optional;
/**
 * SourceMicrosoftOnedrive - SourceMicrosoftOneDriveSpec class for Microsoft OneDrive Source Specification.
 * This class combines the authentication details with additional configuration for the OneDrive API.
 */

public class SourceMicrosoftOnedrive {

    /**
     * Credentials for connecting to the One Drive API
     */
    @JsonProperty("credentials")
    private SourceMicrosoftOnedriveAuthentication credentials;

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("drive_name")
    private Optional<? extends String> driveName;

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("folder_path")
    private Optional<? extends String> folderPath;

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("search_scope")
    private Optional<? extends SearchScope> searchScope;

    @JsonProperty("sourceType")
    private SourceMicrosoftOnedriveMicrosoftOnedrive sourceType;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<? extends OffsetDateTime> startDate;

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonProperty("streams")
    private java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams;

    @JsonCreator
    public SourceMicrosoftOnedrive(
            @JsonProperty("credentials") SourceMicrosoftOnedriveAuthentication credentials,
            @JsonProperty("drive_name") Optional<? extends String> driveName,
            @JsonProperty("folder_path") Optional<? extends String> folderPath,
            @JsonProperty("search_scope") Optional<? extends SearchScope> searchScope,
            @JsonProperty("start_date") Optional<? extends OffsetDateTime> startDate,
            @JsonProperty("streams") java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
        Utils.checkNotNull(credentials, "credentials");
        Utils.checkNotNull(driveName, "driveName");
        Utils.checkNotNull(folderPath, "folderPath");
        Utils.checkNotNull(searchScope, "searchScope");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(streams, "streams");
        this.credentials = credentials;
        this.driveName = driveName;
        this.folderPath = folderPath;
        this.searchScope = searchScope;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.streams = streams;
    }
    
    public SourceMicrosoftOnedrive(
            SourceMicrosoftOnedriveAuthentication credentials,
            java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
        this(credentials, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), streams);
    }

    /**
     * Credentials for connecting to the One Drive API
     */
    @JsonIgnore
    public SourceMicrosoftOnedriveAuthentication credentials() {
        return credentials;
    }

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> driveName() {
        return (Optional<String>) driveName;
    }

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> folderPath() {
        return (Optional<String>) folderPath;
    }

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SearchScope> searchScope() {
        return (Optional<SearchScope>) searchScope;
    }

    @JsonIgnore
    public SourceMicrosoftOnedriveMicrosoftOnedrive sourceType() {
        return sourceType;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<OffsetDateTime> startDate() {
        return (Optional<OffsetDateTime>) startDate;
    }

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonIgnore
    public java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams() {
        return streams;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Credentials for connecting to the One Drive API
     */
    public SourceMicrosoftOnedrive withCredentials(SourceMicrosoftOnedriveAuthentication credentials) {
        Utils.checkNotNull(credentials, "credentials");
        this.credentials = credentials;
        return this;
    }

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    public SourceMicrosoftOnedrive withDriveName(String driveName) {
        Utils.checkNotNull(driveName, "driveName");
        this.driveName = Optional.ofNullable(driveName);
        return this;
    }

    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist.
     */
    public SourceMicrosoftOnedrive withDriveName(Optional<? extends String> driveName) {
        Utils.checkNotNull(driveName, "driveName");
        this.driveName = driveName;
        return this;
    }

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    public SourceMicrosoftOnedrive withFolderPath(String folderPath) {
        Utils.checkNotNull(folderPath, "folderPath");
        this.folderPath = Optional.ofNullable(folderPath);
        return this;
    }

    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
     */
    public SourceMicrosoftOnedrive withFolderPath(Optional<? extends String> folderPath) {
        Utils.checkNotNull(folderPath, "folderPath");
        this.folderPath = folderPath;
        return this;
    }

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    public SourceMicrosoftOnedrive withSearchScope(SearchScope searchScope) {
        Utils.checkNotNull(searchScope, "searchScope");
        this.searchScope = Optional.ofNullable(searchScope);
        return this;
    }

    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
     */
    public SourceMicrosoftOnedrive withSearchScope(Optional<? extends SearchScope> searchScope) {
        Utils.checkNotNull(searchScope, "searchScope");
        this.searchScope = searchScope;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceMicrosoftOnedrive withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceMicrosoftOnedrive withStartDate(Optional<? extends OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    public SourceMicrosoftOnedrive withStreams(java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
        Utils.checkNotNull(streams, "streams");
        this.streams = streams;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceMicrosoftOnedrive other = (SourceMicrosoftOnedrive) o;
        return 
            java.util.Objects.deepEquals(this.credentials, other.credentials) &&
            java.util.Objects.deepEquals(this.driveName, other.driveName) &&
            java.util.Objects.deepEquals(this.folderPath, other.folderPath) &&
            java.util.Objects.deepEquals(this.searchScope, other.searchScope) &&
            java.util.Objects.deepEquals(this.sourceType, other.sourceType) &&
            java.util.Objects.deepEquals(this.startDate, other.startDate) &&
            java.util.Objects.deepEquals(this.streams, other.streams);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            credentials,
            driveName,
            folderPath,
            searchScope,
            sourceType,
            startDate,
            streams);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceMicrosoftOnedrive.class,
                "credentials", credentials,
                "driveName", driveName,
                "folderPath", folderPath,
                "searchScope", searchScope,
                "sourceType", sourceType,
                "startDate", startDate,
                "streams", streams);
    }
    
    public final static class Builder {
 
        private SourceMicrosoftOnedriveAuthentication credentials;
 
        private Optional<? extends String> driveName;
 
        private Optional<? extends String> folderPath;
 
        private Optional<? extends SearchScope> searchScope;
 
        private Optional<? extends OffsetDateTime> startDate = Optional.empty();
 
        private java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Credentials for connecting to the One Drive API
         */
        public Builder credentials(SourceMicrosoftOnedriveAuthentication credentials) {
            Utils.checkNotNull(credentials, "credentials");
            this.credentials = credentials;
            return this;
        }

        /**
         * Name of the Microsoft OneDrive drive where the file(s) exist.
         */
        public Builder driveName(String driveName) {
            Utils.checkNotNull(driveName, "driveName");
            this.driveName = Optional.ofNullable(driveName);
            return this;
        }

        /**
         * Name of the Microsoft OneDrive drive where the file(s) exist.
         */
        public Builder driveName(Optional<? extends String> driveName) {
            Utils.checkNotNull(driveName, "driveName");
            this.driveName = driveName;
            return this;
        }

        /**
         * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
         */
        public Builder folderPath(String folderPath) {
            Utils.checkNotNull(folderPath, "folderPath");
            this.folderPath = Optional.ofNullable(folderPath);
            return this;
        }

        /**
         * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items.
         */
        public Builder folderPath(Optional<? extends String> folderPath) {
            Utils.checkNotNull(folderPath, "folderPath");
            this.folderPath = folderPath;
            return this;
        }

        /**
         * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
         */
        public Builder searchScope(SearchScope searchScope) {
            Utils.checkNotNull(searchScope, "searchScope");
            this.searchScope = Optional.ofNullable(searchScope);
            return this;
        }

        /**
         * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both.
         */
        public Builder searchScope(Optional<? extends SearchScope> searchScope) {
            Utils.checkNotNull(searchScope, "searchScope");
            this.searchScope = searchScope;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(Optional<? extends OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
         */
        public Builder streams(java.util.List<SourceMicrosoftOnedriveFileBasedStreamConfig> streams) {
            Utils.checkNotNull(streams, "streams");
            this.streams = streams;
            return this;
        }
        
        public SourceMicrosoftOnedrive build() {
            if (driveName == null) {
                driveName = _SINGLETON_VALUE_DriveName.value();
            }
            if (folderPath == null) {
                folderPath = _SINGLETON_VALUE_FolderPath.value();
            }
            if (searchScope == null) {
                searchScope = _SINGLETON_VALUE_SearchScope.value();
            }
            return new SourceMicrosoftOnedrive(
                credentials,
                driveName,
                folderPath,
                searchScope,
                startDate,
                streams);
        }

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_DriveName =
                new LazySingletonValue<>(
                        "drive_name",
                        "\"OneDrive\"",
                        new TypeReference<Optional<? extends String>>() {});

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_FolderPath =
                new LazySingletonValue<>(
                        "folder_path",
                        "\".\"",
                        new TypeReference<Optional<? extends String>>() {});

        private static final LazySingletonValue<Optional<? extends SearchScope>> _SINGLETON_VALUE_SearchScope =
                new LazySingletonValue<>(
                        "search_scope",
                        "\"ALL\"",
                        new TypeReference<Optional<? extends SearchScope>>() {});

        private static final LazySingletonValue<SourceMicrosoftOnedriveMicrosoftOnedrive> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"microsoft-onedrive\"",
                        new TypeReference<SourceMicrosoftOnedriveMicrosoftOnedrive>() {});
    }
}

