/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


public class SourceGCSStreamConfig {

    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("days_to_sync_if_history_is_full")
    private Optional<Long> daysToSyncIfHistoryIsFull;

    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    @JsonProperty("format")
    private SourceGcsFormat format;

    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;here&lt;/a&gt;.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("globs")
    private Optional<? extends List<String>> globs;

    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("input_schema")
    private Optional<String> inputSchema;

    /**
     * The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("legacy_prefix")
    private Optional<String> legacyPrefix;

    /**
     * The name of the stream.
     */
    @JsonProperty("name")
    private String name;

    /**
     * The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("primary_key")
    private Optional<String> primaryKey;

    /**
     * When enabled, syncs will not validate or structure records against the stream's schema.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schemaless")
    private Optional<Boolean> schemaless;

    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("validation_policy")
    private Optional<? extends SourceGcsValidationPolicy> validationPolicy;

    @JsonCreator
    public SourceGCSStreamConfig(
            @JsonProperty("days_to_sync_if_history_is_full") Optional<Long> daysToSyncIfHistoryIsFull,
            @JsonProperty("format") SourceGcsFormat format,
            @JsonProperty("globs") Optional<? extends List<String>> globs,
            @JsonProperty("input_schema") Optional<String> inputSchema,
            @JsonProperty("legacy_prefix") Optional<String> legacyPrefix,
            @JsonProperty("name") String name,
            @JsonProperty("primary_key") Optional<String> primaryKey,
            @JsonProperty("schemaless") Optional<Boolean> schemaless,
            @JsonProperty("validation_policy") Optional<? extends SourceGcsValidationPolicy> validationPolicy) {
        Utils.checkNotNull(daysToSyncIfHistoryIsFull, "daysToSyncIfHistoryIsFull");
        Utils.checkNotNull(format, "format");
        Utils.checkNotNull(globs, "globs");
        Utils.checkNotNull(inputSchema, "inputSchema");
        Utils.checkNotNull(legacyPrefix, "legacyPrefix");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(primaryKey, "primaryKey");
        Utils.checkNotNull(schemaless, "schemaless");
        Utils.checkNotNull(validationPolicy, "validationPolicy");
        this.daysToSyncIfHistoryIsFull = daysToSyncIfHistoryIsFull;
        this.format = format;
        this.globs = globs;
        this.inputSchema = inputSchema;
        this.legacyPrefix = legacyPrefix;
        this.name = name;
        this.primaryKey = primaryKey;
        this.schemaless = schemaless;
        this.validationPolicy = validationPolicy;
    }
    
    public SourceGCSStreamConfig(
            SourceGcsFormat format,
            String name) {
        this(Optional.empty(), format, Optional.empty(), Optional.empty(), Optional.empty(), name, Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range.
     */
    @JsonIgnore
    public Optional<Long> daysToSyncIfHistoryIsFull() {
        return daysToSyncIfHistoryIsFull;
    }

    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    @JsonIgnore
    public SourceGcsFormat format() {
        return format;
    }

    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;here&lt;/a&gt;.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> globs() {
        return (Optional<List<String>>) globs;
    }

    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    @JsonIgnore
    public Optional<String> inputSchema() {
        return inputSchema;
    }

    /**
     * The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
     */
    @JsonIgnore
    public Optional<String> legacyPrefix() {
        return legacyPrefix;
    }

    /**
     * The name of the stream.
     */
    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
     */
    @JsonIgnore
    public Optional<String> primaryKey() {
        return primaryKey;
    }

    /**
     * When enabled, syncs will not validate or structure records against the stream's schema.
     */
    @JsonIgnore
    public Optional<Boolean> schemaless() {
        return schemaless;
    }

    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceGcsValidationPolicy> validationPolicy() {
        return (Optional<SourceGcsValidationPolicy>) validationPolicy;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range.
     */
    public SourceGCSStreamConfig withDaysToSyncIfHistoryIsFull(long daysToSyncIfHistoryIsFull) {
        Utils.checkNotNull(daysToSyncIfHistoryIsFull, "daysToSyncIfHistoryIsFull");
        this.daysToSyncIfHistoryIsFull = Optional.ofNullable(daysToSyncIfHistoryIsFull);
        return this;
    }

    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range.
     */
    public SourceGCSStreamConfig withDaysToSyncIfHistoryIsFull(Optional<Long> daysToSyncIfHistoryIsFull) {
        Utils.checkNotNull(daysToSyncIfHistoryIsFull, "daysToSyncIfHistoryIsFull");
        this.daysToSyncIfHistoryIsFull = daysToSyncIfHistoryIsFull;
        return this;
    }

    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    public SourceGCSStreamConfig withFormat(SourceGcsFormat format) {
        Utils.checkNotNull(format, "format");
        this.format = format;
        return this;
    }

    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;here&lt;/a&gt;.
     */
    public SourceGCSStreamConfig withGlobs(List<String> globs) {
        Utils.checkNotNull(globs, "globs");
        this.globs = Optional.ofNullable(globs);
        return this;
    }

    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;here&lt;/a&gt;.
     */
    public SourceGCSStreamConfig withGlobs(Optional<? extends List<String>> globs) {
        Utils.checkNotNull(globs, "globs");
        this.globs = globs;
        return this;
    }

    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    public SourceGCSStreamConfig withInputSchema(String inputSchema) {
        Utils.checkNotNull(inputSchema, "inputSchema");
        this.inputSchema = Optional.ofNullable(inputSchema);
        return this;
    }

    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    public SourceGCSStreamConfig withInputSchema(Optional<String> inputSchema) {
        Utils.checkNotNull(inputSchema, "inputSchema");
        this.inputSchema = inputSchema;
        return this;
    }

    /**
     * The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
     */
    public SourceGCSStreamConfig withLegacyPrefix(String legacyPrefix) {
        Utils.checkNotNull(legacyPrefix, "legacyPrefix");
        this.legacyPrefix = Optional.ofNullable(legacyPrefix);
        return this;
    }

    /**
     * The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
     */
    public SourceGCSStreamConfig withLegacyPrefix(Optional<String> legacyPrefix) {
        Utils.checkNotNull(legacyPrefix, "legacyPrefix");
        this.legacyPrefix = legacyPrefix;
        return this;
    }

    /**
     * The name of the stream.
     */
    public SourceGCSStreamConfig withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
     */
    public SourceGCSStreamConfig withPrimaryKey(String primaryKey) {
        Utils.checkNotNull(primaryKey, "primaryKey");
        this.primaryKey = Optional.ofNullable(primaryKey);
        return this;
    }

    /**
     * The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
     */
    public SourceGCSStreamConfig withPrimaryKey(Optional<String> primaryKey) {
        Utils.checkNotNull(primaryKey, "primaryKey");
        this.primaryKey = primaryKey;
        return this;
    }

    /**
     * When enabled, syncs will not validate or structure records against the stream's schema.
     */
    public SourceGCSStreamConfig withSchemaless(boolean schemaless) {
        Utils.checkNotNull(schemaless, "schemaless");
        this.schemaless = Optional.ofNullable(schemaless);
        return this;
    }

    /**
     * When enabled, syncs will not validate or structure records against the stream's schema.
     */
    public SourceGCSStreamConfig withSchemaless(Optional<Boolean> schemaless) {
        Utils.checkNotNull(schemaless, "schemaless");
        this.schemaless = schemaless;
        return this;
    }

    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema.
     */
    public SourceGCSStreamConfig withValidationPolicy(SourceGcsValidationPolicy validationPolicy) {
        Utils.checkNotNull(validationPolicy, "validationPolicy");
        this.validationPolicy = Optional.ofNullable(validationPolicy);
        return this;
    }

    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema.
     */
    public SourceGCSStreamConfig withValidationPolicy(Optional<? extends SourceGcsValidationPolicy> validationPolicy) {
        Utils.checkNotNull(validationPolicy, "validationPolicy");
        this.validationPolicy = validationPolicy;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceGCSStreamConfig other = (SourceGCSStreamConfig) o;
        return 
            Objects.deepEquals(this.daysToSyncIfHistoryIsFull, other.daysToSyncIfHistoryIsFull) &&
            Objects.deepEquals(this.format, other.format) &&
            Objects.deepEquals(this.globs, other.globs) &&
            Objects.deepEquals(this.inputSchema, other.inputSchema) &&
            Objects.deepEquals(this.legacyPrefix, other.legacyPrefix) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.primaryKey, other.primaryKey) &&
            Objects.deepEquals(this.schemaless, other.schemaless) &&
            Objects.deepEquals(this.validationPolicy, other.validationPolicy);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            daysToSyncIfHistoryIsFull,
            format,
            globs,
            inputSchema,
            legacyPrefix,
            name,
            primaryKey,
            schemaless,
            validationPolicy);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceGCSStreamConfig.class,
                "daysToSyncIfHistoryIsFull", daysToSyncIfHistoryIsFull,
                "format", format,
                "globs", globs,
                "inputSchema", inputSchema,
                "legacyPrefix", legacyPrefix,
                "name", name,
                "primaryKey", primaryKey,
                "schemaless", schemaless,
                "validationPolicy", validationPolicy);
    }
    
    public final static class Builder {
 
        private Optional<Long> daysToSyncIfHistoryIsFull;
 
        private SourceGcsFormat format;
 
        private Optional<? extends List<String>> globs = Optional.empty();
 
        private Optional<String> inputSchema = Optional.empty();
 
        private Optional<String> legacyPrefix = Optional.empty();
 
        private String name;
 
        private Optional<String> primaryKey = Optional.empty();
 
        private Optional<Boolean> schemaless;
 
        private Optional<? extends SourceGcsValidationPolicy> validationPolicy;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range.
         */
        public Builder daysToSyncIfHistoryIsFull(long daysToSyncIfHistoryIsFull) {
            Utils.checkNotNull(daysToSyncIfHistoryIsFull, "daysToSyncIfHistoryIsFull");
            this.daysToSyncIfHistoryIsFull = Optional.ofNullable(daysToSyncIfHistoryIsFull);
            return this;
        }

        /**
         * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range.
         */
        public Builder daysToSyncIfHistoryIsFull(Optional<Long> daysToSyncIfHistoryIsFull) {
            Utils.checkNotNull(daysToSyncIfHistoryIsFull, "daysToSyncIfHistoryIsFull");
            this.daysToSyncIfHistoryIsFull = daysToSyncIfHistoryIsFull;
            return this;
        }

        /**
         * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
         */
        public Builder format(SourceGcsFormat format) {
            Utils.checkNotNull(format, "format");
            this.format = format;
            return this;
        }

        /**
         * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;here&lt;/a&gt;.
         */
        public Builder globs(List<String> globs) {
            Utils.checkNotNull(globs, "globs");
            this.globs = Optional.ofNullable(globs);
            return this;
        }

        /**
         * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;here&lt;/a&gt;.
         */
        public Builder globs(Optional<? extends List<String>> globs) {
            Utils.checkNotNull(globs, "globs");
            this.globs = globs;
            return this;
        }

        /**
         * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
         */
        public Builder inputSchema(String inputSchema) {
            Utils.checkNotNull(inputSchema, "inputSchema");
            this.inputSchema = Optional.ofNullable(inputSchema);
            return this;
        }

        /**
         * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
         */
        public Builder inputSchema(Optional<String> inputSchema) {
            Utils.checkNotNull(inputSchema, "inputSchema");
            this.inputSchema = inputSchema;
            return this;
        }

        /**
         * The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
         */
        public Builder legacyPrefix(String legacyPrefix) {
            Utils.checkNotNull(legacyPrefix, "legacyPrefix");
            this.legacyPrefix = Optional.ofNullable(legacyPrefix);
            return this;
        }

        /**
         * The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
         */
        public Builder legacyPrefix(Optional<String> legacyPrefix) {
            Utils.checkNotNull(legacyPrefix, "legacyPrefix");
            this.legacyPrefix = legacyPrefix;
            return this;
        }

        /**
         * The name of the stream.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
         */
        public Builder primaryKey(String primaryKey) {
            Utils.checkNotNull(primaryKey, "primaryKey");
            this.primaryKey = Optional.ofNullable(primaryKey);
            return this;
        }

        /**
         * The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
         */
        public Builder primaryKey(Optional<String> primaryKey) {
            Utils.checkNotNull(primaryKey, "primaryKey");
            this.primaryKey = primaryKey;
            return this;
        }

        /**
         * When enabled, syncs will not validate or structure records against the stream's schema.
         */
        public Builder schemaless(boolean schemaless) {
            Utils.checkNotNull(schemaless, "schemaless");
            this.schemaless = Optional.ofNullable(schemaless);
            return this;
        }

        /**
         * When enabled, syncs will not validate or structure records against the stream's schema.
         */
        public Builder schemaless(Optional<Boolean> schemaless) {
            Utils.checkNotNull(schemaless, "schemaless");
            this.schemaless = schemaless;
            return this;
        }

        /**
         * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema.
         */
        public Builder validationPolicy(SourceGcsValidationPolicy validationPolicy) {
            Utils.checkNotNull(validationPolicy, "validationPolicy");
            this.validationPolicy = Optional.ofNullable(validationPolicy);
            return this;
        }

        /**
         * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema.
         */
        public Builder validationPolicy(Optional<? extends SourceGcsValidationPolicy> validationPolicy) {
            Utils.checkNotNull(validationPolicy, "validationPolicy");
            this.validationPolicy = validationPolicy;
            return this;
        }
        
        public SourceGCSStreamConfig build() {
            if (daysToSyncIfHistoryIsFull == null) {
                daysToSyncIfHistoryIsFull = _SINGLETON_VALUE_DaysToSyncIfHistoryIsFull.value();
            }
            if (schemaless == null) {
                schemaless = _SINGLETON_VALUE_Schemaless.value();
            }
            if (validationPolicy == null) {
                validationPolicy = _SINGLETON_VALUE_ValidationPolicy.value();
            }            return new SourceGCSStreamConfig(
                daysToSyncIfHistoryIsFull,
                format,
                globs,
                inputSchema,
                legacyPrefix,
                name,
                primaryKey,
                schemaless,
                validationPolicy);
        }

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_DaysToSyncIfHistoryIsFull =
                new LazySingletonValue<>(
                        "days_to_sync_if_history_is_full",
                        "3",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_Schemaless =
                new LazySingletonValue<>(
                        "schemaless",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends SourceGcsValidationPolicy>> _SINGLETON_VALUE_ValidationPolicy =
                new LazySingletonValue<>(
                        "validation_policy",
                        "\"Emit Record\"",
                        new TypeReference<Optional<? extends SourceGcsValidationPolicy>>() {});
    }
}

