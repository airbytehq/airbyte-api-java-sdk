/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;


public class DestinationElasticsearch {

    /**
     * The type of authentication to be used
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authenticationMethod")
    private Optional<? extends AuthenticationMethod> authenticationMethod;

    /**
     * CA certificate
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ca_certificate")
    private Optional<String> caCertificate;

    @JsonProperty("destinationType")
    private Elasticsearch destinationType;

    /**
     * The full url of the Elasticsearch server
     */
    @JsonProperty("endpoint")
    private String endpoint;

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tunnel_method")
    private Optional<? extends DestinationElasticsearchSSHTunnelMethod> tunnelMethod;

    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("upsert")
    private Optional<Boolean> upsert;

    @JsonCreator
    public DestinationElasticsearch(
            @JsonProperty("authenticationMethod") Optional<? extends AuthenticationMethod> authenticationMethod,
            @JsonProperty("ca_certificate") Optional<String> caCertificate,
            @JsonProperty("endpoint") String endpoint,
            @JsonProperty("tunnel_method") Optional<? extends DestinationElasticsearchSSHTunnelMethod> tunnelMethod,
            @JsonProperty("upsert") Optional<Boolean> upsert) {
        Utils.checkNotNull(authenticationMethod, "authenticationMethod");
        Utils.checkNotNull(caCertificate, "caCertificate");
        Utils.checkNotNull(endpoint, "endpoint");
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        Utils.checkNotNull(upsert, "upsert");
        this.authenticationMethod = authenticationMethod;
        this.caCertificate = caCertificate;
        this.destinationType = Builder._SINGLETON_VALUE_DestinationType.value();
        this.endpoint = endpoint;
        this.tunnelMethod = tunnelMethod;
        this.upsert = upsert;
    }
    
    public DestinationElasticsearch(
            String endpoint) {
        this(Optional.empty(), Optional.empty(), endpoint, Optional.empty(), Optional.empty());
    }

    /**
     * The type of authentication to be used
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AuthenticationMethod> authenticationMethod() {
        return (Optional<AuthenticationMethod>) authenticationMethod;
    }

    /**
     * CA certificate
     */
    @JsonIgnore
    public Optional<String> caCertificate() {
        return caCertificate;
    }

    @JsonIgnore
    public Elasticsearch destinationType() {
        return destinationType;
    }

    /**
     * The full url of the Elasticsearch server
     */
    @JsonIgnore
    public String endpoint() {
        return endpoint;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DestinationElasticsearchSSHTunnelMethod> tunnelMethod() {
        return (Optional<DestinationElasticsearchSSHTunnelMethod>) tunnelMethod;
    }

    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
     */
    @JsonIgnore
    public Optional<Boolean> upsert() {
        return upsert;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The type of authentication to be used
     */
    public DestinationElasticsearch withAuthenticationMethod(AuthenticationMethod authenticationMethod) {
        Utils.checkNotNull(authenticationMethod, "authenticationMethod");
        this.authenticationMethod = Optional.ofNullable(authenticationMethod);
        return this;
    }

    /**
     * The type of authentication to be used
     */
    public DestinationElasticsearch withAuthenticationMethod(Optional<? extends AuthenticationMethod> authenticationMethod) {
        Utils.checkNotNull(authenticationMethod, "authenticationMethod");
        this.authenticationMethod = authenticationMethod;
        return this;
    }

    /**
     * CA certificate
     */
    public DestinationElasticsearch withCaCertificate(String caCertificate) {
        Utils.checkNotNull(caCertificate, "caCertificate");
        this.caCertificate = Optional.ofNullable(caCertificate);
        return this;
    }

    /**
     * CA certificate
     */
    public DestinationElasticsearch withCaCertificate(Optional<String> caCertificate) {
        Utils.checkNotNull(caCertificate, "caCertificate");
        this.caCertificate = caCertificate;
        return this;
    }

    /**
     * The full url of the Elasticsearch server
     */
    public DestinationElasticsearch withEndpoint(String endpoint) {
        Utils.checkNotNull(endpoint, "endpoint");
        this.endpoint = endpoint;
        return this;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    public DestinationElasticsearch withTunnelMethod(DestinationElasticsearchSSHTunnelMethod tunnelMethod) {
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        this.tunnelMethod = Optional.ofNullable(tunnelMethod);
        return this;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    public DestinationElasticsearch withTunnelMethod(Optional<? extends DestinationElasticsearchSSHTunnelMethod> tunnelMethod) {
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        this.tunnelMethod = tunnelMethod;
        return this;
    }

    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
     */
    public DestinationElasticsearch withUpsert(boolean upsert) {
        Utils.checkNotNull(upsert, "upsert");
        this.upsert = Optional.ofNullable(upsert);
        return this;
    }

    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
     */
    public DestinationElasticsearch withUpsert(Optional<Boolean> upsert) {
        Utils.checkNotNull(upsert, "upsert");
        this.upsert = upsert;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DestinationElasticsearch other = (DestinationElasticsearch) o;
        return 
            Objects.deepEquals(this.authenticationMethod, other.authenticationMethod) &&
            Objects.deepEquals(this.caCertificate, other.caCertificate) &&
            Objects.deepEquals(this.destinationType, other.destinationType) &&
            Objects.deepEquals(this.endpoint, other.endpoint) &&
            Objects.deepEquals(this.tunnelMethod, other.tunnelMethod) &&
            Objects.deepEquals(this.upsert, other.upsert);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            authenticationMethod,
            caCertificate,
            destinationType,
            endpoint,
            tunnelMethod,
            upsert);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DestinationElasticsearch.class,
                "authenticationMethod", authenticationMethod,
                "caCertificate", caCertificate,
                "destinationType", destinationType,
                "endpoint", endpoint,
                "tunnelMethod", tunnelMethod,
                "upsert", upsert);
    }
    
    public final static class Builder {
 
        private Optional<? extends AuthenticationMethod> authenticationMethod = Optional.empty();
 
        private Optional<String> caCertificate = Optional.empty();
 
        private String endpoint;
 
        private Optional<? extends DestinationElasticsearchSSHTunnelMethod> tunnelMethod = Optional.empty();
 
        private Optional<Boolean> upsert;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The type of authentication to be used
         */
        public Builder authenticationMethod(AuthenticationMethod authenticationMethod) {
            Utils.checkNotNull(authenticationMethod, "authenticationMethod");
            this.authenticationMethod = Optional.ofNullable(authenticationMethod);
            return this;
        }

        /**
         * The type of authentication to be used
         */
        public Builder authenticationMethod(Optional<? extends AuthenticationMethod> authenticationMethod) {
            Utils.checkNotNull(authenticationMethod, "authenticationMethod");
            this.authenticationMethod = authenticationMethod;
            return this;
        }

        /**
         * CA certificate
         */
        public Builder caCertificate(String caCertificate) {
            Utils.checkNotNull(caCertificate, "caCertificate");
            this.caCertificate = Optional.ofNullable(caCertificate);
            return this;
        }

        /**
         * CA certificate
         */
        public Builder caCertificate(Optional<String> caCertificate) {
            Utils.checkNotNull(caCertificate, "caCertificate");
            this.caCertificate = caCertificate;
            return this;
        }

        /**
         * The full url of the Elasticsearch server
         */
        public Builder endpoint(String endpoint) {
            Utils.checkNotNull(endpoint, "endpoint");
            this.endpoint = endpoint;
            return this;
        }

        /**
         * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
         */
        public Builder tunnelMethod(DestinationElasticsearchSSHTunnelMethod tunnelMethod) {
            Utils.checkNotNull(tunnelMethod, "tunnelMethod");
            this.tunnelMethod = Optional.ofNullable(tunnelMethod);
            return this;
        }

        /**
         * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
         */
        public Builder tunnelMethod(Optional<? extends DestinationElasticsearchSSHTunnelMethod> tunnelMethod) {
            Utils.checkNotNull(tunnelMethod, "tunnelMethod");
            this.tunnelMethod = tunnelMethod;
            return this;
        }

        /**
         * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
         */
        public Builder upsert(boolean upsert) {
            Utils.checkNotNull(upsert, "upsert");
            this.upsert = Optional.ofNullable(upsert);
            return this;
        }

        /**
         * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
         */
        public Builder upsert(Optional<Boolean> upsert) {
            Utils.checkNotNull(upsert, "upsert");
            this.upsert = upsert;
            return this;
        }
        
        public DestinationElasticsearch build() {
            if (upsert == null) {
                upsert = _SINGLETON_VALUE_Upsert.value();
            }            return new DestinationElasticsearch(
                authenticationMethod,
                caCertificate,
                endpoint,
                tunnelMethod,
                upsert);
        }

        private static final LazySingletonValue<Elasticsearch> _SINGLETON_VALUE_DestinationType =
                new LazySingletonValue<>(
                        "destinationType",
                        "\"elasticsearch\"",
                        new TypeReference<Elasticsearch>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_Upsert =
                new LazySingletonValue<>(
                        "upsert",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});
    }
}

