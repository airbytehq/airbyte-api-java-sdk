/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


public class SourceGcsCSVFormat {

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("delimiter")
    private Optional<String> delimiter;

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("double_quote")
    private Optional<Boolean> doubleQuote;

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("encoding")
    private Optional<String> encoding;

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("escape_char")
    private Optional<String> escapeChar;

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("false_values")
    private Optional<? extends List<String>> falseValues;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filetype")
    private Optional<? extends SourceGcsFiletype> filetype;

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("header_definition")
    private Optional<? extends SourceGcsCSVHeaderDefinition> headerDefinition;

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ignore_errors_on_fields_mismatch")
    private Optional<Boolean> ignoreErrorsOnFieldsMismatch;

    /**
     * How to infer the types of the columns. If none, inference default to strings.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("inference_type")
    private Optional<? extends SourceGcsInferenceType> inferenceType;

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("null_values")
    private Optional<? extends List<String>> nullValues;

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("quote_char")
    private Optional<String> quoteChar;

    /**
     * The number of rows to skip after the header row.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_rows_after_header")
    private Optional<Long> skipRowsAfterHeader;

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_rows_before_header")
    private Optional<Long> skipRowsBeforeHeader;

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("strings_can_be_null")
    private Optional<Boolean> stringsCanBeNull;

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("true_values")
    private Optional<? extends List<String>> trueValues;

    @JsonCreator
    public SourceGcsCSVFormat(
            @JsonProperty("delimiter") Optional<String> delimiter,
            @JsonProperty("double_quote") Optional<Boolean> doubleQuote,
            @JsonProperty("encoding") Optional<String> encoding,
            @JsonProperty("escape_char") Optional<String> escapeChar,
            @JsonProperty("false_values") Optional<? extends List<String>> falseValues,
            @JsonProperty("header_definition") Optional<? extends SourceGcsCSVHeaderDefinition> headerDefinition,
            @JsonProperty("ignore_errors_on_fields_mismatch") Optional<Boolean> ignoreErrorsOnFieldsMismatch,
            @JsonProperty("inference_type") Optional<? extends SourceGcsInferenceType> inferenceType,
            @JsonProperty("null_values") Optional<? extends List<String>> nullValues,
            @JsonProperty("quote_char") Optional<String> quoteChar,
            @JsonProperty("skip_rows_after_header") Optional<Long> skipRowsAfterHeader,
            @JsonProperty("skip_rows_before_header") Optional<Long> skipRowsBeforeHeader,
            @JsonProperty("strings_can_be_null") Optional<Boolean> stringsCanBeNull,
            @JsonProperty("true_values") Optional<? extends List<String>> trueValues) {
        Utils.checkNotNull(delimiter, "delimiter");
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        Utils.checkNotNull(encoding, "encoding");
        Utils.checkNotNull(escapeChar, "escapeChar");
        Utils.checkNotNull(falseValues, "falseValues");
        Utils.checkNotNull(headerDefinition, "headerDefinition");
        Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
        Utils.checkNotNull(inferenceType, "inferenceType");
        Utils.checkNotNull(nullValues, "nullValues");
        Utils.checkNotNull(quoteChar, "quoteChar");
        Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
        Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
        Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
        Utils.checkNotNull(trueValues, "trueValues");
        this.delimiter = delimiter;
        this.doubleQuote = doubleQuote;
        this.encoding = encoding;
        this.escapeChar = escapeChar;
        this.falseValues = falseValues;
        this.filetype = Builder._SINGLETON_VALUE_Filetype.value();
        this.headerDefinition = headerDefinition;
        this.ignoreErrorsOnFieldsMismatch = ignoreErrorsOnFieldsMismatch;
        this.inferenceType = inferenceType;
        this.nullValues = nullValues;
        this.quoteChar = quoteChar;
        this.skipRowsAfterHeader = skipRowsAfterHeader;
        this.skipRowsBeforeHeader = skipRowsBeforeHeader;
        this.stringsCanBeNull = stringsCanBeNull;
        this.trueValues = trueValues;
    }
    
    public SourceGcsCSVFormat() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    @JsonIgnore
    public Optional<String> delimiter() {
        return delimiter;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    @JsonIgnore
    public Optional<Boolean> doubleQuote() {
        return doubleQuote;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    @JsonIgnore
    public Optional<String> encoding() {
        return encoding;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    @JsonIgnore
    public Optional<String> escapeChar() {
        return escapeChar;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> falseValues() {
        return (Optional<List<String>>) falseValues;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceGcsFiletype> filetype() {
        return (Optional<SourceGcsFiletype>) filetype;
    }

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceGcsCSVHeaderDefinition> headerDefinition() {
        return (Optional<SourceGcsCSVHeaderDefinition>) headerDefinition;
    }

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    @JsonIgnore
    public Optional<Boolean> ignoreErrorsOnFieldsMismatch() {
        return ignoreErrorsOnFieldsMismatch;
    }

    /**
     * How to infer the types of the columns. If none, inference default to strings.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceGcsInferenceType> inferenceType() {
        return (Optional<SourceGcsInferenceType>) inferenceType;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> nullValues() {
        return (Optional<List<String>>) nullValues;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    @JsonIgnore
    public Optional<String> quoteChar() {
        return quoteChar;
    }

    /**
     * The number of rows to skip after the header row.
     */
    @JsonIgnore
    public Optional<Long> skipRowsAfterHeader() {
        return skipRowsAfterHeader;
    }

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    @JsonIgnore
    public Optional<Long> skipRowsBeforeHeader() {
        return skipRowsBeforeHeader;
    }

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    @JsonIgnore
    public Optional<Boolean> stringsCanBeNull() {
        return stringsCanBeNull;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> trueValues() {
        return (Optional<List<String>>) trueValues;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public SourceGcsCSVFormat withDelimiter(String delimiter) {
        Utils.checkNotNull(delimiter, "delimiter");
        this.delimiter = Optional.ofNullable(delimiter);
        return this;
    }

    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
     */
    public SourceGcsCSVFormat withDelimiter(Optional<String> delimiter) {
        Utils.checkNotNull(delimiter, "delimiter");
        this.delimiter = delimiter;
        return this;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public SourceGcsCSVFormat withDoubleQuote(boolean doubleQuote) {
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        this.doubleQuote = Optional.ofNullable(doubleQuote);
        return this;
    }

    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    public SourceGcsCSVFormat withDoubleQuote(Optional<Boolean> doubleQuote) {
        Utils.checkNotNull(doubleQuote, "doubleQuote");
        this.doubleQuote = doubleQuote;
        return this;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public SourceGcsCSVFormat withEncoding(String encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = Optional.ofNullable(encoding);
        return this;
    }

    /**
     * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
     */
    public SourceGcsCSVFormat withEncoding(Optional<String> encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = encoding;
        return this;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public SourceGcsCSVFormat withEscapeChar(String escapeChar) {
        Utils.checkNotNull(escapeChar, "escapeChar");
        this.escapeChar = Optional.ofNullable(escapeChar);
        return this;
    }

    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    public SourceGcsCSVFormat withEscapeChar(Optional<String> escapeChar) {
        Utils.checkNotNull(escapeChar, "escapeChar");
        this.escapeChar = escapeChar;
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    public SourceGcsCSVFormat withFalseValues(List<String> falseValues) {
        Utils.checkNotNull(falseValues, "falseValues");
        this.falseValues = Optional.ofNullable(falseValues);
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    public SourceGcsCSVFormat withFalseValues(Optional<? extends List<String>> falseValues) {
        Utils.checkNotNull(falseValues, "falseValues");
        this.falseValues = falseValues;
        return this;
    }

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    public SourceGcsCSVFormat withHeaderDefinition(SourceGcsCSVHeaderDefinition headerDefinition) {
        Utils.checkNotNull(headerDefinition, "headerDefinition");
        this.headerDefinition = Optional.ofNullable(headerDefinition);
        return this;
    }

    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    public SourceGcsCSVFormat withHeaderDefinition(Optional<? extends SourceGcsCSVHeaderDefinition> headerDefinition) {
        Utils.checkNotNull(headerDefinition, "headerDefinition");
        this.headerDefinition = headerDefinition;
        return this;
    }

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    public SourceGcsCSVFormat withIgnoreErrorsOnFieldsMismatch(boolean ignoreErrorsOnFieldsMismatch) {
        Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
        this.ignoreErrorsOnFieldsMismatch = Optional.ofNullable(ignoreErrorsOnFieldsMismatch);
        return this;
    }

    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
     */
    public SourceGcsCSVFormat withIgnoreErrorsOnFieldsMismatch(Optional<Boolean> ignoreErrorsOnFieldsMismatch) {
        Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
        this.ignoreErrorsOnFieldsMismatch = ignoreErrorsOnFieldsMismatch;
        return this;
    }

    /**
     * How to infer the types of the columns. If none, inference default to strings.
     */
    public SourceGcsCSVFormat withInferenceType(SourceGcsInferenceType inferenceType) {
        Utils.checkNotNull(inferenceType, "inferenceType");
        this.inferenceType = Optional.ofNullable(inferenceType);
        return this;
    }

    /**
     * How to infer the types of the columns. If none, inference default to strings.
     */
    public SourceGcsCSVFormat withInferenceType(Optional<? extends SourceGcsInferenceType> inferenceType) {
        Utils.checkNotNull(inferenceType, "inferenceType");
        this.inferenceType = inferenceType;
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    public SourceGcsCSVFormat withNullValues(List<String> nullValues) {
        Utils.checkNotNull(nullValues, "nullValues");
        this.nullValues = Optional.ofNullable(nullValues);
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    public SourceGcsCSVFormat withNullValues(Optional<? extends List<String>> nullValues) {
        Utils.checkNotNull(nullValues, "nullValues");
        this.nullValues = nullValues;
        return this;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public SourceGcsCSVFormat withQuoteChar(String quoteChar) {
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.quoteChar = Optional.ofNullable(quoteChar);
        return this;
    }

    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank.
     */
    public SourceGcsCSVFormat withQuoteChar(Optional<String> quoteChar) {
        Utils.checkNotNull(quoteChar, "quoteChar");
        this.quoteChar = quoteChar;
        return this;
    }

    /**
     * The number of rows to skip after the header row.
     */
    public SourceGcsCSVFormat withSkipRowsAfterHeader(long skipRowsAfterHeader) {
        Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
        this.skipRowsAfterHeader = Optional.ofNullable(skipRowsAfterHeader);
        return this;
    }

    /**
     * The number of rows to skip after the header row.
     */
    public SourceGcsCSVFormat withSkipRowsAfterHeader(Optional<Long> skipRowsAfterHeader) {
        Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
        this.skipRowsAfterHeader = skipRowsAfterHeader;
        return this;
    }

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    public SourceGcsCSVFormat withSkipRowsBeforeHeader(long skipRowsBeforeHeader) {
        Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
        this.skipRowsBeforeHeader = Optional.ofNullable(skipRowsBeforeHeader);
        return this;
    }

    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
     */
    public SourceGcsCSVFormat withSkipRowsBeforeHeader(Optional<Long> skipRowsBeforeHeader) {
        Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
        this.skipRowsBeforeHeader = skipRowsBeforeHeader;
        return this;
    }

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    public SourceGcsCSVFormat withStringsCanBeNull(boolean stringsCanBeNull) {
        Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
        this.stringsCanBeNull = Optional.ofNullable(stringsCanBeNull);
        return this;
    }

    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
     */
    public SourceGcsCSVFormat withStringsCanBeNull(Optional<Boolean> stringsCanBeNull) {
        Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
        this.stringsCanBeNull = stringsCanBeNull;
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    public SourceGcsCSVFormat withTrueValues(List<String> trueValues) {
        Utils.checkNotNull(trueValues, "trueValues");
        this.trueValues = Optional.ofNullable(trueValues);
        return this;
    }

    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    public SourceGcsCSVFormat withTrueValues(Optional<? extends List<String>> trueValues) {
        Utils.checkNotNull(trueValues, "trueValues");
        this.trueValues = trueValues;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceGcsCSVFormat other = (SourceGcsCSVFormat) o;
        return 
            Objects.deepEquals(this.delimiter, other.delimiter) &&
            Objects.deepEquals(this.doubleQuote, other.doubleQuote) &&
            Objects.deepEquals(this.encoding, other.encoding) &&
            Objects.deepEquals(this.escapeChar, other.escapeChar) &&
            Objects.deepEquals(this.falseValues, other.falseValues) &&
            Objects.deepEquals(this.filetype, other.filetype) &&
            Objects.deepEquals(this.headerDefinition, other.headerDefinition) &&
            Objects.deepEquals(this.ignoreErrorsOnFieldsMismatch, other.ignoreErrorsOnFieldsMismatch) &&
            Objects.deepEquals(this.inferenceType, other.inferenceType) &&
            Objects.deepEquals(this.nullValues, other.nullValues) &&
            Objects.deepEquals(this.quoteChar, other.quoteChar) &&
            Objects.deepEquals(this.skipRowsAfterHeader, other.skipRowsAfterHeader) &&
            Objects.deepEquals(this.skipRowsBeforeHeader, other.skipRowsBeforeHeader) &&
            Objects.deepEquals(this.stringsCanBeNull, other.stringsCanBeNull) &&
            Objects.deepEquals(this.trueValues, other.trueValues);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            delimiter,
            doubleQuote,
            encoding,
            escapeChar,
            falseValues,
            filetype,
            headerDefinition,
            ignoreErrorsOnFieldsMismatch,
            inferenceType,
            nullValues,
            quoteChar,
            skipRowsAfterHeader,
            skipRowsBeforeHeader,
            stringsCanBeNull,
            trueValues);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceGcsCSVFormat.class,
                "delimiter", delimiter,
                "doubleQuote", doubleQuote,
                "encoding", encoding,
                "escapeChar", escapeChar,
                "falseValues", falseValues,
                "filetype", filetype,
                "headerDefinition", headerDefinition,
                "ignoreErrorsOnFieldsMismatch", ignoreErrorsOnFieldsMismatch,
                "inferenceType", inferenceType,
                "nullValues", nullValues,
                "quoteChar", quoteChar,
                "skipRowsAfterHeader", skipRowsAfterHeader,
                "skipRowsBeforeHeader", skipRowsBeforeHeader,
                "stringsCanBeNull", stringsCanBeNull,
                "trueValues", trueValues);
    }
    
    public final static class Builder {
 
        private Optional<String> delimiter;
 
        private Optional<Boolean> doubleQuote;
 
        private Optional<String> encoding;
 
        private Optional<String> escapeChar = Optional.empty();
 
        private Optional<? extends List<String>> falseValues = Optional.empty();
 
        private Optional<? extends SourceGcsCSVHeaderDefinition> headerDefinition = Optional.empty();
 
        private Optional<Boolean> ignoreErrorsOnFieldsMismatch;
 
        private Optional<? extends SourceGcsInferenceType> inferenceType;
 
        private Optional<? extends List<String>> nullValues = Optional.empty();
 
        private Optional<String> quoteChar;
 
        private Optional<Long> skipRowsAfterHeader;
 
        private Optional<Long> skipRowsBeforeHeader;
 
        private Optional<Boolean> stringsCanBeNull;
 
        private Optional<? extends List<String>> trueValues = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
         */
        public Builder delimiter(String delimiter) {
            Utils.checkNotNull(delimiter, "delimiter");
            this.delimiter = Optional.ofNullable(delimiter);
            return this;
        }

        /**
         * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'.
         */
        public Builder delimiter(Optional<String> delimiter) {
            Utils.checkNotNull(delimiter, "delimiter");
            this.delimiter = delimiter;
            return this;
        }

        /**
         * Whether two quotes in a quoted CSV value denote a single quote in the data.
         */
        public Builder doubleQuote(boolean doubleQuote) {
            Utils.checkNotNull(doubleQuote, "doubleQuote");
            this.doubleQuote = Optional.ofNullable(doubleQuote);
            return this;
        }

        /**
         * Whether two quotes in a quoted CSV value denote a single quote in the data.
         */
        public Builder doubleQuote(Optional<Boolean> doubleQuote) {
            Utils.checkNotNull(doubleQuote, "doubleQuote");
            this.doubleQuote = doubleQuote;
            return this;
        }

        /**
         * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
         */
        public Builder encoding(String encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = Optional.ofNullable(encoding);
            return this;
        }

        /**
         * The character encoding of the CSV data. Leave blank to default to &lt;strong&gt;UTF8&lt;/strong&gt;. See &lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank"&gt;list of python encodings&lt;/a&gt; for allowable options.
         */
        public Builder encoding(Optional<String> encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = encoding;
            return this;
        }

        /**
         * The character used for escaping special characters. To disallow escaping, leave this field blank.
         */
        public Builder escapeChar(String escapeChar) {
            Utils.checkNotNull(escapeChar, "escapeChar");
            this.escapeChar = Optional.ofNullable(escapeChar);
            return this;
        }

        /**
         * The character used for escaping special characters. To disallow escaping, leave this field blank.
         */
        public Builder escapeChar(Optional<String> escapeChar) {
            Utils.checkNotNull(escapeChar, "escapeChar");
            this.escapeChar = escapeChar;
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as false values.
         */
        public Builder falseValues(List<String> falseValues) {
            Utils.checkNotNull(falseValues, "falseValues");
            this.falseValues = Optional.ofNullable(falseValues);
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as false values.
         */
        public Builder falseValues(Optional<? extends List<String>> falseValues) {
            Utils.checkNotNull(falseValues, "falseValues");
            this.falseValues = falseValues;
            return this;
        }

        /**
         * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
         */
        public Builder headerDefinition(SourceGcsCSVHeaderDefinition headerDefinition) {
            Utils.checkNotNull(headerDefinition, "headerDefinition");
            this.headerDefinition = Optional.ofNullable(headerDefinition);
            return this;
        }

        /**
         * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
         */
        public Builder headerDefinition(Optional<? extends SourceGcsCSVHeaderDefinition> headerDefinition) {
            Utils.checkNotNull(headerDefinition, "headerDefinition");
            this.headerDefinition = headerDefinition;
            return this;
        }

        /**
         * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
         */
        public Builder ignoreErrorsOnFieldsMismatch(boolean ignoreErrorsOnFieldsMismatch) {
            Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
            this.ignoreErrorsOnFieldsMismatch = Optional.ofNullable(ignoreErrorsOnFieldsMismatch);
            return this;
        }

        /**
         * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema.
         */
        public Builder ignoreErrorsOnFieldsMismatch(Optional<Boolean> ignoreErrorsOnFieldsMismatch) {
            Utils.checkNotNull(ignoreErrorsOnFieldsMismatch, "ignoreErrorsOnFieldsMismatch");
            this.ignoreErrorsOnFieldsMismatch = ignoreErrorsOnFieldsMismatch;
            return this;
        }

        /**
         * How to infer the types of the columns. If none, inference default to strings.
         */
        public Builder inferenceType(SourceGcsInferenceType inferenceType) {
            Utils.checkNotNull(inferenceType, "inferenceType");
            this.inferenceType = Optional.ofNullable(inferenceType);
            return this;
        }

        /**
         * How to infer the types of the columns. If none, inference default to strings.
         */
        public Builder inferenceType(Optional<? extends SourceGcsInferenceType> inferenceType) {
            Utils.checkNotNull(inferenceType, "inferenceType");
            this.inferenceType = inferenceType;
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
         */
        public Builder nullValues(List<String> nullValues) {
            Utils.checkNotNull(nullValues, "nullValues");
            this.nullValues = Optional.ofNullable(nullValues);
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
         */
        public Builder nullValues(Optional<? extends List<String>> nullValues) {
            Utils.checkNotNull(nullValues, "nullValues");
            this.nullValues = nullValues;
            return this;
        }

        /**
         * The character used for quoting CSV values. To disallow quoting, make this field blank.
         */
        public Builder quoteChar(String quoteChar) {
            Utils.checkNotNull(quoteChar, "quoteChar");
            this.quoteChar = Optional.ofNullable(quoteChar);
            return this;
        }

        /**
         * The character used for quoting CSV values. To disallow quoting, make this field blank.
         */
        public Builder quoteChar(Optional<String> quoteChar) {
            Utils.checkNotNull(quoteChar, "quoteChar");
            this.quoteChar = quoteChar;
            return this;
        }

        /**
         * The number of rows to skip after the header row.
         */
        public Builder skipRowsAfterHeader(long skipRowsAfterHeader) {
            Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
            this.skipRowsAfterHeader = Optional.ofNullable(skipRowsAfterHeader);
            return this;
        }

        /**
         * The number of rows to skip after the header row.
         */
        public Builder skipRowsAfterHeader(Optional<Long> skipRowsAfterHeader) {
            Utils.checkNotNull(skipRowsAfterHeader, "skipRowsAfterHeader");
            this.skipRowsAfterHeader = skipRowsAfterHeader;
            return this;
        }

        /**
         * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
         */
        public Builder skipRowsBeforeHeader(long skipRowsBeforeHeader) {
            Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
            this.skipRowsBeforeHeader = Optional.ofNullable(skipRowsBeforeHeader);
            return this;
        }

        /**
         * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field.
         */
        public Builder skipRowsBeforeHeader(Optional<Long> skipRowsBeforeHeader) {
            Utils.checkNotNull(skipRowsBeforeHeader, "skipRowsBeforeHeader");
            this.skipRowsBeforeHeader = skipRowsBeforeHeader;
            return this;
        }

        /**
         * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
         */
        public Builder stringsCanBeNull(boolean stringsCanBeNull) {
            Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
            this.stringsCanBeNull = Optional.ofNullable(stringsCanBeNull);
            return this;
        }

        /**
         * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself.
         */
        public Builder stringsCanBeNull(Optional<Boolean> stringsCanBeNull) {
            Utils.checkNotNull(stringsCanBeNull, "stringsCanBeNull");
            this.stringsCanBeNull = stringsCanBeNull;
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as true values.
         */
        public Builder trueValues(List<String> trueValues) {
            Utils.checkNotNull(trueValues, "trueValues");
            this.trueValues = Optional.ofNullable(trueValues);
            return this;
        }

        /**
         * A set of case-sensitive strings that should be interpreted as true values.
         */
        public Builder trueValues(Optional<? extends List<String>> trueValues) {
            Utils.checkNotNull(trueValues, "trueValues");
            this.trueValues = trueValues;
            return this;
        }
        
        public SourceGcsCSVFormat build() {
            if (delimiter == null) {
                delimiter = _SINGLETON_VALUE_Delimiter.value();
            }
            if (doubleQuote == null) {
                doubleQuote = _SINGLETON_VALUE_DoubleQuote.value();
            }
            if (encoding == null) {
                encoding = _SINGLETON_VALUE_Encoding.value();
            }
            if (ignoreErrorsOnFieldsMismatch == null) {
                ignoreErrorsOnFieldsMismatch = _SINGLETON_VALUE_IgnoreErrorsOnFieldsMismatch.value();
            }
            if (inferenceType == null) {
                inferenceType = _SINGLETON_VALUE_InferenceType.value();
            }
            if (quoteChar == null) {
                quoteChar = _SINGLETON_VALUE_QuoteChar.value();
            }
            if (skipRowsAfterHeader == null) {
                skipRowsAfterHeader = _SINGLETON_VALUE_SkipRowsAfterHeader.value();
            }
            if (skipRowsBeforeHeader == null) {
                skipRowsBeforeHeader = _SINGLETON_VALUE_SkipRowsBeforeHeader.value();
            }
            if (stringsCanBeNull == null) {
                stringsCanBeNull = _SINGLETON_VALUE_StringsCanBeNull.value();
            }            return new SourceGcsCSVFormat(
                delimiter,
                doubleQuote,
                encoding,
                escapeChar,
                falseValues,
                headerDefinition,
                ignoreErrorsOnFieldsMismatch,
                inferenceType,
                nullValues,
                quoteChar,
                skipRowsAfterHeader,
                skipRowsBeforeHeader,
                stringsCanBeNull,
                trueValues);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Delimiter =
                new LazySingletonValue<>(
                        "delimiter",
                        "\",\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_DoubleQuote =
                new LazySingletonValue<>(
                        "double_quote",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Encoding =
                new LazySingletonValue<>(
                        "encoding",
                        "\"utf8\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<? extends SourceGcsFiletype>> _SINGLETON_VALUE_Filetype =
                new LazySingletonValue<>(
                        "filetype",
                        "\"csv\"",
                        new TypeReference<Optional<? extends SourceGcsFiletype>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_IgnoreErrorsOnFieldsMismatch =
                new LazySingletonValue<>(
                        "ignore_errors_on_fields_mismatch",
                        "false",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends SourceGcsInferenceType>> _SINGLETON_VALUE_InferenceType =
                new LazySingletonValue<>(
                        "inference_type",
                        "\"None\"",
                        new TypeReference<Optional<? extends SourceGcsInferenceType>>() {});

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_QuoteChar =
                new LazySingletonValue<>(
                        "quote_char",
                        "\"\\\"\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_SkipRowsAfterHeader =
                new LazySingletonValue<>(
                        "skip_rows_after_header",
                        "0",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_SkipRowsBeforeHeader =
                new LazySingletonValue<>(
                        "skip_rows_before_header",
                        "0",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_StringsCanBeNull =
                new LazySingletonValue<>(
                        "strings_can_be_null",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});
    }
}

