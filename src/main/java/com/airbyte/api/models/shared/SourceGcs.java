/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * SourceGcs
 * 
 * <p>NOTE: When this Spec is changed, legacy_config_transformer.py must also be
 * modified to uptake the changes because it is responsible for converting
 * legacy GCS configs into file based configs using the File-Based CDK.
 */
public class SourceGcs {

    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    @JsonProperty("bucket")
    private String bucket;

    /**
     * Credentials for connecting to the Google Cloud Storage API
     */
    @JsonProperty("credentials")
    private SourceGcsAuthentication credentials;

    @JsonProperty("sourceType")
    private SourceGcsGcs sourceType;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<OffsetDateTime> startDate;

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonProperty("streams")
    private List<SourceGcsFileBasedStreamConfig> streams;

    @JsonCreator
    public SourceGcs(
            @JsonProperty("bucket") String bucket,
            @JsonProperty("credentials") SourceGcsAuthentication credentials,
            @JsonProperty("start_date") Optional<OffsetDateTime> startDate,
            @JsonProperty("streams") List<SourceGcsFileBasedStreamConfig> streams) {
        Utils.checkNotNull(bucket, "bucket");
        Utils.checkNotNull(credentials, "credentials");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(streams, "streams");
        this.bucket = bucket;
        this.credentials = credentials;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.streams = streams;
    }
    
    public SourceGcs(
            String bucket,
            SourceGcsAuthentication credentials,
            List<SourceGcsFileBasedStreamConfig> streams) {
        this(bucket, credentials, Optional.empty(), streams);
    }

    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    @JsonIgnore
    public String bucket() {
        return bucket;
    }

    /**
     * Credentials for connecting to the Google Cloud Storage API
     */
    @JsonIgnore
    public SourceGcsAuthentication credentials() {
        return credentials;
    }

    @JsonIgnore
    public SourceGcsGcs sourceType() {
        return sourceType;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> startDate() {
        return startDate;
    }

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonIgnore
    public List<SourceGcsFileBasedStreamConfig> streams() {
        return streams;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    public SourceGcs withBucket(String bucket) {
        Utils.checkNotNull(bucket, "bucket");
        this.bucket = bucket;
        return this;
    }

    /**
     * Credentials for connecting to the Google Cloud Storage API
     */
    public SourceGcs withCredentials(SourceGcsAuthentication credentials) {
        Utils.checkNotNull(credentials, "credentials");
        this.credentials = credentials;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceGcs withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceGcs withStartDate(Optional<OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    public SourceGcs withStreams(List<SourceGcsFileBasedStreamConfig> streams) {
        Utils.checkNotNull(streams, "streams");
        this.streams = streams;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceGcs other = (SourceGcs) o;
        return 
            Objects.deepEquals(this.bucket, other.bucket) &&
            Objects.deepEquals(this.credentials, other.credentials) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.streams, other.streams);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            bucket,
            credentials,
            sourceType,
            startDate,
            streams);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceGcs.class,
                "bucket", bucket,
                "credentials", credentials,
                "sourceType", sourceType,
                "startDate", startDate,
                "streams", streams);
    }
    
    public final static class Builder {
 
        private String bucket;
 
        private SourceGcsAuthentication credentials;
 
        private Optional<OffsetDateTime> startDate = Optional.empty();
 
        private List<SourceGcsFileBasedStreamConfig> streams;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Name of the GCS bucket where the file(s) exist.
         */
        public Builder bucket(String bucket) {
            Utils.checkNotNull(bucket, "bucket");
            this.bucket = bucket;
            return this;
        }

        /**
         * Credentials for connecting to the Google Cloud Storage API
         */
        public Builder credentials(SourceGcsAuthentication credentials) {
            Utils.checkNotNull(credentials, "credentials");
            this.credentials = credentials;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(Optional<OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * Each instance of this configuration defines a &lt;a href="https://docs.airbyte.com/cloud/core-concepts#stream"&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
         */
        public Builder streams(List<SourceGcsFileBasedStreamConfig> streams) {
            Utils.checkNotNull(streams, "streams");
            this.streams = streams;
            return this;
        }
        
        public SourceGcs build() {
            return new SourceGcs(
                bucket,
                credentials,
                startDate,
                streams);
        }

        private static final LazySingletonValue<SourceGcsGcs> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"gcs\"",
                        new TypeReference<SourceGcsGcs>() {});
    }
}
