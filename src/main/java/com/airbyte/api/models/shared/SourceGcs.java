/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * SourceGcs - NOTE: When this Spec is changed, legacy_config_transformer.py must also be
 * modified to uptake the changes because it is responsible for converting
 * legacy GCS configs into file based configs using the File-Based CDK.
 */

public class SourceGcs {

    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    @JsonProperty("bucket")
    private String bucket;

    /**
     * Enter your Google Cloud &lt;a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys"&gt;service account key&lt;/a&gt; in JSON format
     */
    @JsonProperty("service_account")
    private String serviceAccount;

    @JsonProperty("sourceType")
    private SourceGcsGcs sourceType;

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("start_date")
    private Optional<OffsetDateTime> startDate;

    /**
     * Each instance of this configuration defines a &lt;a href=https://docs.airbyte.com/cloud/core-concepts#stream&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonProperty("streams")
    private List<SourceGCSStreamConfig> streams;

    @JsonCreator
    public SourceGcs(
            @JsonProperty("bucket") String bucket,
            @JsonProperty("service_account") String serviceAccount,
            @JsonProperty("start_date") Optional<OffsetDateTime> startDate,
            @JsonProperty("streams") List<SourceGCSStreamConfig> streams) {
        Utils.checkNotNull(bucket, "bucket");
        Utils.checkNotNull(serviceAccount, "serviceAccount");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(streams, "streams");
        this.bucket = bucket;
        this.serviceAccount = serviceAccount;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.streams = streams;
    }
    
    public SourceGcs(
            String bucket,
            String serviceAccount,
            List<SourceGCSStreamConfig> streams) {
        this(bucket, serviceAccount, Optional.empty(), streams);
    }

    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    @JsonIgnore
    public String bucket() {
        return bucket;
    }

    /**
     * Enter your Google Cloud &lt;a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys"&gt;service account key&lt;/a&gt; in JSON format
     */
    @JsonIgnore
    public String serviceAccount() {
        return serviceAccount;
    }

    @JsonIgnore
    public SourceGcsGcs sourceType() {
        return sourceType;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> startDate() {
        return startDate;
    }

    /**
     * Each instance of this configuration defines a &lt;a href=https://docs.airbyte.com/cloud/core-concepts#stream&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    @JsonIgnore
    public List<SourceGCSStreamConfig> streams() {
        return streams;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    public SourceGcs withBucket(String bucket) {
        Utils.checkNotNull(bucket, "bucket");
        this.bucket = bucket;
        return this;
    }

    /**
     * Enter your Google Cloud &lt;a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys"&gt;service account key&lt;/a&gt; in JSON format
     */
    public SourceGcs withServiceAccount(String serviceAccount) {
        Utils.checkNotNull(serviceAccount, "serviceAccount");
        this.serviceAccount = serviceAccount;
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceGcs withStartDate(OffsetDateTime startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    public SourceGcs withStartDate(Optional<OffsetDateTime> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * Each instance of this configuration defines a &lt;a href=https://docs.airbyte.com/cloud/core-concepts#stream&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    public SourceGcs withStreams(List<SourceGCSStreamConfig> streams) {
        Utils.checkNotNull(streams, "streams");
        this.streams = streams;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceGcs other = (SourceGcs) o;
        return 
            Objects.deepEquals(this.bucket, other.bucket) &&
            Objects.deepEquals(this.serviceAccount, other.serviceAccount) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.streams, other.streams);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            bucket,
            serviceAccount,
            sourceType,
            startDate,
            streams);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceGcs.class,
                "bucket", bucket,
                "serviceAccount", serviceAccount,
                "sourceType", sourceType,
                "startDate", startDate,
                "streams", streams);
    }
    
    public final static class Builder {
 
        private String bucket;
 
        private String serviceAccount;
 
        private Optional<OffsetDateTime> startDate = Optional.empty();
 
        private List<SourceGCSStreamConfig> streams;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Name of the GCS bucket where the file(s) exist.
         */
        public Builder bucket(String bucket) {
            Utils.checkNotNull(bucket, "bucket");
            this.bucket = bucket;
            return this;
        }

        /**
         * Enter your Google Cloud &lt;a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys"&gt;service account key&lt;/a&gt; in JSON format
         */
        public Builder serviceAccount(String serviceAccount) {
            Utils.checkNotNull(serviceAccount, "serviceAccount");
            this.serviceAccount = serviceAccount;
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(OffsetDateTime startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
         */
        public Builder startDate(Optional<OffsetDateTime> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * Each instance of this configuration defines a &lt;a href=https://docs.airbyte.com/cloud/core-concepts#stream&gt;stream&lt;/a&gt;. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
         */
        public Builder streams(List<SourceGCSStreamConfig> streams) {
            Utils.checkNotNull(streams, "streams");
            this.streams = streams;
            return this;
        }
        
        public SourceGcs build() {
            return new SourceGcs(
                bucket,
                serviceAccount,
                startDate,
                streams);
        }

        private static final LazySingletonValue<SourceGcsGcs> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"gcs\"",
                        new TypeReference<SourceGcsGcs>() {});
    }
}

