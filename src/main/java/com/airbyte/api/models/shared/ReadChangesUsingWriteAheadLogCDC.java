/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

/**
 * ReadChangesUsingWriteAheadLogCDC - &lt;i&gt;Recommended&lt;/i&gt; - Incrementally reads new inserts, updates, and deletes using the Postgres &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc"&gt;write-ahead log (WAL)&lt;/a&gt;. This needs to be configured on the source database itself. Recommended for tables of any size.
 */

public class ReadChangesUsingWriteAheadLogCDC {

    @JsonIgnore
    private Map<String, Object> additionalProperties;

    /**
     * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query"&gt;setup guide&lt;/a&gt; for how and when to configure this setting.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("heartbeat_action_query")
    private Optional<String> heartbeatActionQuery;

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initial_load_timeout_hours")
    private Optional<Long> initialLoadTimeoutHours;

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time"&gt;initial waiting time&lt;/a&gt;.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initial_waiting_seconds")
    private Optional<Long> initialWaitingSeconds;

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invalid_cdc_cursor_position_behavior")
    private Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior;

    /**
     * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lsn_commit_behaviour")
    private Optional<? extends LSNCommitBehaviour> lsnCommitBehaviour;

    @JsonProperty("method")
    private SourcePostgresMethod method;

    /**
     * A logical decoding plugin installed on the PostgreSQL server.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("plugin")
    private Optional<? extends Plugin> plugin;

    /**
     * A Postgres publication used for consuming changes. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables"&gt;publications and replication identities&lt;/a&gt;.
     */
    @JsonProperty("publication")
    private String publication;

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("queue_size")
    private Optional<Long> queueSize;

    /**
     * A plugin logical replication slot. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot"&gt;replication slots&lt;/a&gt;.
     */
    @JsonProperty("replication_slot")
    private String replicationSlot;

    @JsonCreator
    public ReadChangesUsingWriteAheadLogCDC(
            @JsonProperty("heartbeat_action_query") Optional<String> heartbeatActionQuery,
            @JsonProperty("initial_load_timeout_hours") Optional<Long> initialLoadTimeoutHours,
            @JsonProperty("initial_waiting_seconds") Optional<Long> initialWaitingSeconds,
            @JsonProperty("invalid_cdc_cursor_position_behavior") Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior,
            @JsonProperty("lsn_commit_behaviour") Optional<? extends LSNCommitBehaviour> lsnCommitBehaviour,
            @JsonProperty("plugin") Optional<? extends Plugin> plugin,
            @JsonProperty("publication") String publication,
            @JsonProperty("queue_size") Optional<Long> queueSize,
            @JsonProperty("replication_slot") String replicationSlot) {
        Utils.checkNotNull(heartbeatActionQuery, "heartbeatActionQuery");
        Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        Utils.checkNotNull(lsnCommitBehaviour, "lsnCommitBehaviour");
        Utils.checkNotNull(plugin, "plugin");
        Utils.checkNotNull(publication, "publication");
        Utils.checkNotNull(queueSize, "queueSize");
        Utils.checkNotNull(replicationSlot, "replicationSlot");
        this.additionalProperties = new HashMap<>();
        this.heartbeatActionQuery = heartbeatActionQuery;
        this.initialLoadTimeoutHours = initialLoadTimeoutHours;
        this.initialWaitingSeconds = initialWaitingSeconds;
        this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
        this.lsnCommitBehaviour = lsnCommitBehaviour;
        this.method = Builder._SINGLETON_VALUE_Method.value();
        this.plugin = plugin;
        this.publication = publication;
        this.queueSize = queueSize;
        this.replicationSlot = replicationSlot;
    }
    
    public ReadChangesUsingWriteAheadLogCDC(
            String publication,
            String replicationSlot) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), publication, Optional.empty(), replicationSlot);
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    /**
     * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query"&gt;setup guide&lt;/a&gt; for how and when to configure this setting.
     */
    @JsonIgnore
    public Optional<String> heartbeatActionQuery() {
        return heartbeatActionQuery;
    }

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    @JsonIgnore
    public Optional<Long> initialLoadTimeoutHours() {
        return initialLoadTimeoutHours;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time"&gt;initial waiting time&lt;/a&gt;.
     */
    @JsonIgnore
    public Optional<Long> initialWaitingSeconds() {
        return initialWaitingSeconds;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourcePostgresInvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior() {
        return (Optional<SourcePostgresInvalidCDCPositionBehaviorAdvanced>) invalidCdcCursorPositionBehavior;
    }

    /**
     * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<LSNCommitBehaviour> lsnCommitBehaviour() {
        return (Optional<LSNCommitBehaviour>) lsnCommitBehaviour;
    }

    @JsonIgnore
    public SourcePostgresMethod method() {
        return method;
    }

    /**
     * A logical decoding plugin installed on the PostgreSQL server.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Plugin> plugin() {
        return (Optional<Plugin>) plugin;
    }

    /**
     * A Postgres publication used for consuming changes. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables"&gt;publications and replication identities&lt;/a&gt;.
     */
    @JsonIgnore
    public String publication() {
        return publication;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    @JsonIgnore
    public Optional<Long> queueSize() {
        return queueSize;
    }

    /**
     * A plugin logical replication slot. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot"&gt;replication slots&lt;/a&gt;.
     */
    @JsonIgnore
    public String replicationSlot() {
        return replicationSlot;
    }

    public final static Builder builder() {
        return new Builder();
    }

    @JsonAnySetter
    public ReadChangesUsingWriteAheadLogCDC withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    
    public ReadChangesUsingWriteAheadLogCDC withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    /**
     * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query"&gt;setup guide&lt;/a&gt; for how and when to configure this setting.
     */
    public ReadChangesUsingWriteAheadLogCDC withHeartbeatActionQuery(String heartbeatActionQuery) {
        Utils.checkNotNull(heartbeatActionQuery, "heartbeatActionQuery");
        this.heartbeatActionQuery = Optional.ofNullable(heartbeatActionQuery);
        return this;
    }

    /**
     * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query"&gt;setup guide&lt;/a&gt; for how and when to configure this setting.
     */
    public ReadChangesUsingWriteAheadLogCDC withHeartbeatActionQuery(Optional<String> heartbeatActionQuery) {
        Utils.checkNotNull(heartbeatActionQuery, "heartbeatActionQuery");
        this.heartbeatActionQuery = heartbeatActionQuery;
        return this;
    }

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    public ReadChangesUsingWriteAheadLogCDC withInitialLoadTimeoutHours(long initialLoadTimeoutHours) {
        Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
        this.initialLoadTimeoutHours = Optional.ofNullable(initialLoadTimeoutHours);
        return this;
    }

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    public ReadChangesUsingWriteAheadLogCDC withInitialLoadTimeoutHours(Optional<Long> initialLoadTimeoutHours) {
        Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
        this.initialLoadTimeoutHours = initialLoadTimeoutHours;
        return this;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time"&gt;initial waiting time&lt;/a&gt;.
     */
    public ReadChangesUsingWriteAheadLogCDC withInitialWaitingSeconds(long initialWaitingSeconds) {
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        this.initialWaitingSeconds = Optional.ofNullable(initialWaitingSeconds);
        return this;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time"&gt;initial waiting time&lt;/a&gt;.
     */
    public ReadChangesUsingWriteAheadLogCDC withInitialWaitingSeconds(Optional<Long> initialWaitingSeconds) {
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        this.initialWaitingSeconds = initialWaitingSeconds;
        return this;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    public ReadChangesUsingWriteAheadLogCDC withInvalidCdcCursorPositionBehavior(SourcePostgresInvalidCDCPositionBehaviorAdvanced invalidCdcCursorPositionBehavior) {
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        this.invalidCdcCursorPositionBehavior = Optional.ofNullable(invalidCdcCursorPositionBehavior);
        return this;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    public ReadChangesUsingWriteAheadLogCDC withInvalidCdcCursorPositionBehavior(Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior) {
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
        return this;
    }

    /**
     * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
     */
    public ReadChangesUsingWriteAheadLogCDC withLsnCommitBehaviour(LSNCommitBehaviour lsnCommitBehaviour) {
        Utils.checkNotNull(lsnCommitBehaviour, "lsnCommitBehaviour");
        this.lsnCommitBehaviour = Optional.ofNullable(lsnCommitBehaviour);
        return this;
    }

    /**
     * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
     */
    public ReadChangesUsingWriteAheadLogCDC withLsnCommitBehaviour(Optional<? extends LSNCommitBehaviour> lsnCommitBehaviour) {
        Utils.checkNotNull(lsnCommitBehaviour, "lsnCommitBehaviour");
        this.lsnCommitBehaviour = lsnCommitBehaviour;
        return this;
    }

    /**
     * A logical decoding plugin installed on the PostgreSQL server.
     */
    public ReadChangesUsingWriteAheadLogCDC withPlugin(Plugin plugin) {
        Utils.checkNotNull(plugin, "plugin");
        this.plugin = Optional.ofNullable(plugin);
        return this;
    }

    /**
     * A logical decoding plugin installed on the PostgreSQL server.
     */
    public ReadChangesUsingWriteAheadLogCDC withPlugin(Optional<? extends Plugin> plugin) {
        Utils.checkNotNull(plugin, "plugin");
        this.plugin = plugin;
        return this;
    }

    /**
     * A Postgres publication used for consuming changes. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables"&gt;publications and replication identities&lt;/a&gt;.
     */
    public ReadChangesUsingWriteAheadLogCDC withPublication(String publication) {
        Utils.checkNotNull(publication, "publication");
        this.publication = publication;
        return this;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    public ReadChangesUsingWriteAheadLogCDC withQueueSize(long queueSize) {
        Utils.checkNotNull(queueSize, "queueSize");
        this.queueSize = Optional.ofNullable(queueSize);
        return this;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    public ReadChangesUsingWriteAheadLogCDC withQueueSize(Optional<Long> queueSize) {
        Utils.checkNotNull(queueSize, "queueSize");
        this.queueSize = queueSize;
        return this;
    }

    /**
     * A plugin logical replication slot. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot"&gt;replication slots&lt;/a&gt;.
     */
    public ReadChangesUsingWriteAheadLogCDC withReplicationSlot(String replicationSlot) {
        Utils.checkNotNull(replicationSlot, "replicationSlot");
        this.replicationSlot = replicationSlot;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ReadChangesUsingWriteAheadLogCDC other = (ReadChangesUsingWriteAheadLogCDC) o;
        return 
            Objects.deepEquals(this.additionalProperties, other.additionalProperties) &&
            Objects.deepEquals(this.heartbeatActionQuery, other.heartbeatActionQuery) &&
            Objects.deepEquals(this.initialLoadTimeoutHours, other.initialLoadTimeoutHours) &&
            Objects.deepEquals(this.initialWaitingSeconds, other.initialWaitingSeconds) &&
            Objects.deepEquals(this.invalidCdcCursorPositionBehavior, other.invalidCdcCursorPositionBehavior) &&
            Objects.deepEquals(this.lsnCommitBehaviour, other.lsnCommitBehaviour) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.plugin, other.plugin) &&
            Objects.deepEquals(this.publication, other.publication) &&
            Objects.deepEquals(this.queueSize, other.queueSize) &&
            Objects.deepEquals(this.replicationSlot, other.replicationSlot);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            additionalProperties,
            heartbeatActionQuery,
            initialLoadTimeoutHours,
            initialWaitingSeconds,
            invalidCdcCursorPositionBehavior,
            lsnCommitBehaviour,
            method,
            plugin,
            publication,
            queueSize,
            replicationSlot);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ReadChangesUsingWriteAheadLogCDC.class,
                "additionalProperties", additionalProperties,
                "heartbeatActionQuery", heartbeatActionQuery,
                "initialLoadTimeoutHours", initialLoadTimeoutHours,
                "initialWaitingSeconds", initialWaitingSeconds,
                "invalidCdcCursorPositionBehavior", invalidCdcCursorPositionBehavior,
                "lsnCommitBehaviour", lsnCommitBehaviour,
                "method", method,
                "plugin", plugin,
                "publication", publication,
                "queueSize", queueSize,
                "replicationSlot", replicationSlot);
    }
    
    public final static class Builder {
 
        private Map<String, Object> additionalProperties = new HashMap<>();
 
        private Optional<String> heartbeatActionQuery;
 
        private Optional<Long> initialLoadTimeoutHours;
 
        private Optional<Long> initialWaitingSeconds;
 
        private Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior;
 
        private Optional<? extends LSNCommitBehaviour> lsnCommitBehaviour;
 
        private Optional<? extends Plugin> plugin;
 
        private String publication;
 
        private Optional<Long> queueSize;
 
        private String replicationSlot;  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        /**
         * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query"&gt;setup guide&lt;/a&gt; for how and when to configure this setting.
         */
        public Builder heartbeatActionQuery(String heartbeatActionQuery) {
            Utils.checkNotNull(heartbeatActionQuery, "heartbeatActionQuery");
            this.heartbeatActionQuery = Optional.ofNullable(heartbeatActionQuery);
            return this;
        }

        /**
         * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query"&gt;setup guide&lt;/a&gt; for how and when to configure this setting.
         */
        public Builder heartbeatActionQuery(Optional<String> heartbeatActionQuery) {
            Utils.checkNotNull(heartbeatActionQuery, "heartbeatActionQuery");
            this.heartbeatActionQuery = heartbeatActionQuery;
            return this;
        }

        /**
         * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
         */
        public Builder initialLoadTimeoutHours(long initialLoadTimeoutHours) {
            Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
            this.initialLoadTimeoutHours = Optional.ofNullable(initialLoadTimeoutHours);
            return this;
        }

        /**
         * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
         */
        public Builder initialLoadTimeoutHours(Optional<Long> initialLoadTimeoutHours) {
            Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
            this.initialLoadTimeoutHours = initialLoadTimeoutHours;
            return this;
        }

        /**
         * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time"&gt;initial waiting time&lt;/a&gt;.
         */
        public Builder initialWaitingSeconds(long initialWaitingSeconds) {
            Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
            this.initialWaitingSeconds = Optional.ofNullable(initialWaitingSeconds);
            return this;
        }

        /**
         * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time"&gt;initial waiting time&lt;/a&gt;.
         */
        public Builder initialWaitingSeconds(Optional<Long> initialWaitingSeconds) {
            Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
            this.initialWaitingSeconds = initialWaitingSeconds;
            return this;
        }

        /**
         * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
         */
        public Builder invalidCdcCursorPositionBehavior(SourcePostgresInvalidCDCPositionBehaviorAdvanced invalidCdcCursorPositionBehavior) {
            Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
            this.invalidCdcCursorPositionBehavior = Optional.ofNullable(invalidCdcCursorPositionBehavior);
            return this;
        }

        /**
         * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
         */
        public Builder invalidCdcCursorPositionBehavior(Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior) {
            Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
            this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
            return this;
        }

        /**
         * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
         */
        public Builder lsnCommitBehaviour(LSNCommitBehaviour lsnCommitBehaviour) {
            Utils.checkNotNull(lsnCommitBehaviour, "lsnCommitBehaviour");
            this.lsnCommitBehaviour = Optional.ofNullable(lsnCommitBehaviour);
            return this;
        }

        /**
         * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
         */
        public Builder lsnCommitBehaviour(Optional<? extends LSNCommitBehaviour> lsnCommitBehaviour) {
            Utils.checkNotNull(lsnCommitBehaviour, "lsnCommitBehaviour");
            this.lsnCommitBehaviour = lsnCommitBehaviour;
            return this;
        }

        /**
         * A logical decoding plugin installed on the PostgreSQL server.
         */
        public Builder plugin(Plugin plugin) {
            Utils.checkNotNull(plugin, "plugin");
            this.plugin = Optional.ofNullable(plugin);
            return this;
        }

        /**
         * A logical decoding plugin installed on the PostgreSQL server.
         */
        public Builder plugin(Optional<? extends Plugin> plugin) {
            Utils.checkNotNull(plugin, "plugin");
            this.plugin = plugin;
            return this;
        }

        /**
         * A Postgres publication used for consuming changes. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables"&gt;publications and replication identities&lt;/a&gt;.
         */
        public Builder publication(String publication) {
            Utils.checkNotNull(publication, "publication");
            this.publication = publication;
            return this;
        }

        /**
         * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
         */
        public Builder queueSize(long queueSize) {
            Utils.checkNotNull(queueSize, "queueSize");
            this.queueSize = Optional.ofNullable(queueSize);
            return this;
        }

        /**
         * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
         */
        public Builder queueSize(Optional<Long> queueSize) {
            Utils.checkNotNull(queueSize, "queueSize");
            this.queueSize = queueSize;
            return this;
        }

        /**
         * A plugin logical replication slot. Read about &lt;a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot"&gt;replication slots&lt;/a&gt;.
         */
        public Builder replicationSlot(String replicationSlot) {
            Utils.checkNotNull(replicationSlot, "replicationSlot");
            this.replicationSlot = replicationSlot;
            return this;
        }
        
        public ReadChangesUsingWriteAheadLogCDC build() {
            if (heartbeatActionQuery == null) {
                heartbeatActionQuery = _SINGLETON_VALUE_HeartbeatActionQuery.value();
            }
            if (initialLoadTimeoutHours == null) {
                initialLoadTimeoutHours = _SINGLETON_VALUE_InitialLoadTimeoutHours.value();
            }
            if (initialWaitingSeconds == null) {
                initialWaitingSeconds = _SINGLETON_VALUE_InitialWaitingSeconds.value();
            }
            if (invalidCdcCursorPositionBehavior == null) {
                invalidCdcCursorPositionBehavior = _SINGLETON_VALUE_InvalidCdcCursorPositionBehavior.value();
            }
            if (lsnCommitBehaviour == null) {
                lsnCommitBehaviour = _SINGLETON_VALUE_LsnCommitBehaviour.value();
            }
            if (plugin == null) {
                plugin = _SINGLETON_VALUE_Plugin.value();
            }
            if (queueSize == null) {
                queueSize = _SINGLETON_VALUE_QueueSize.value();
            }            return new ReadChangesUsingWriteAheadLogCDC(
                heartbeatActionQuery,
                initialLoadTimeoutHours,
                initialWaitingSeconds,
                invalidCdcCursorPositionBehavior,
                lsnCommitBehaviour,
                plugin,
                publication,
                queueSize,
                replicationSlot)
                .withAdditionalProperties(additionalProperties);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_HeartbeatActionQuery =
                new LazySingletonValue<>(
                        "heartbeat_action_query",
                        "\"\"",
                        new TypeReference<Optional<String>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_InitialLoadTimeoutHours =
                new LazySingletonValue<>(
                        "initial_load_timeout_hours",
                        "8",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_InitialWaitingSeconds =
                new LazySingletonValue<>(
                        "initial_waiting_seconds",
                        "1200",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced>> _SINGLETON_VALUE_InvalidCdcCursorPositionBehavior =
                new LazySingletonValue<>(
                        "invalid_cdc_cursor_position_behavior",
                        "\"Fail sync\"",
                        new TypeReference<Optional<? extends SourcePostgresInvalidCDCPositionBehaviorAdvanced>>() {});

        private static final LazySingletonValue<Optional<? extends LSNCommitBehaviour>> _SINGLETON_VALUE_LsnCommitBehaviour =
                new LazySingletonValue<>(
                        "lsn_commit_behaviour",
                        "\"After loading Data in the destination\"",
                        new TypeReference<Optional<? extends LSNCommitBehaviour>>() {});

        private static final LazySingletonValue<SourcePostgresMethod> _SINGLETON_VALUE_Method =
                new LazySingletonValue<>(
                        "method",
                        "\"CDC\"",
                        new TypeReference<SourcePostgresMethod>() {});

        private static final LazySingletonValue<Optional<? extends Plugin>> _SINGLETON_VALUE_Plugin =
                new LazySingletonValue<>(
                        "plugin",
                        "\"pgoutput\"",
                        new TypeReference<Optional<? extends Plugin>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_QueueSize =
                new LazySingletonValue<>(
                        "queue_size",
                        "10000",
                        new TypeReference<Optional<Long>>() {});
    }
}

