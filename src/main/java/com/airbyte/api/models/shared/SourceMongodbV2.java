/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;

public class SourceMongodbV2 {

    /**
     * Configures the MongoDB cluster type.
     */
    @JsonProperty("database_config")
    private ClusterType databaseConfig;

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discover_sample_size")
    private Optional<Long> discoverSampleSize;

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initial_load_timeout_hours")
    private Optional<Long> initialLoadTimeoutHours;

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initial_waiting_seconds")
    private Optional<Long> initialWaitingSeconds;

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invalid_cdc_cursor_position_behavior")
    private Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior;

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("queue_size")
    private Optional<Long> queueSize;

    @JsonProperty("sourceType")
    private MongodbV2 sourceType;

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("update_capture_mode")
    private Optional<? extends CaptureModeAdvanced> updateCaptureMode;

    @JsonCreator
    public SourceMongodbV2(
            @JsonProperty("database_config") ClusterType databaseConfig,
            @JsonProperty("discover_sample_size") Optional<Long> discoverSampleSize,
            @JsonProperty("initial_load_timeout_hours") Optional<Long> initialLoadTimeoutHours,
            @JsonProperty("initial_waiting_seconds") Optional<Long> initialWaitingSeconds,
            @JsonProperty("invalid_cdc_cursor_position_behavior") Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior,
            @JsonProperty("queue_size") Optional<Long> queueSize,
            @JsonProperty("update_capture_mode") Optional<? extends CaptureModeAdvanced> updateCaptureMode) {
        Utils.checkNotNull(databaseConfig, "databaseConfig");
        Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
        Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        Utils.checkNotNull(queueSize, "queueSize");
        Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
        this.databaseConfig = databaseConfig;
        this.discoverSampleSize = discoverSampleSize;
        this.initialLoadTimeoutHours = initialLoadTimeoutHours;
        this.initialWaitingSeconds = initialWaitingSeconds;
        this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
        this.queueSize = queueSize;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.updateCaptureMode = updateCaptureMode;
    }
    
    public SourceMongodbV2(
            ClusterType databaseConfig) {
        this(databaseConfig, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Configures the MongoDB cluster type.
     */
    @JsonIgnore
    public ClusterType databaseConfig() {
        return databaseConfig;
    }

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    @JsonIgnore
    public Optional<Long> discoverSampleSize() {
        return discoverSampleSize;
    }

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    @JsonIgnore
    public Optional<Long> initialLoadTimeoutHours() {
        return initialLoadTimeoutHours;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    @JsonIgnore
    public Optional<Long> initialWaitingSeconds() {
        return initialWaitingSeconds;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior() {
        return (Optional<InvalidCDCPositionBehaviorAdvanced>) invalidCdcCursorPositionBehavior;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    @JsonIgnore
    public Optional<Long> queueSize() {
        return queueSize;
    }

    @JsonIgnore
    public MongodbV2 sourceType() {
        return sourceType;
    }

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CaptureModeAdvanced> updateCaptureMode() {
        return (Optional<CaptureModeAdvanced>) updateCaptureMode;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Configures the MongoDB cluster type.
     */
    public SourceMongodbV2 withDatabaseConfig(ClusterType databaseConfig) {
        Utils.checkNotNull(databaseConfig, "databaseConfig");
        this.databaseConfig = databaseConfig;
        return this;
    }

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    public SourceMongodbV2 withDiscoverSampleSize(long discoverSampleSize) {
        Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
        this.discoverSampleSize = Optional.ofNullable(discoverSampleSize);
        return this;
    }

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    public SourceMongodbV2 withDiscoverSampleSize(Optional<Long> discoverSampleSize) {
        Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
        this.discoverSampleSize = discoverSampleSize;
        return this;
    }

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    public SourceMongodbV2 withInitialLoadTimeoutHours(long initialLoadTimeoutHours) {
        Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
        this.initialLoadTimeoutHours = Optional.ofNullable(initialLoadTimeoutHours);
        return this;
    }

    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
     */
    public SourceMongodbV2 withInitialLoadTimeoutHours(Optional<Long> initialLoadTimeoutHours) {
        Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
        this.initialLoadTimeoutHours = initialLoadTimeoutHours;
        return this;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    public SourceMongodbV2 withInitialWaitingSeconds(long initialWaitingSeconds) {
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        this.initialWaitingSeconds = Optional.ofNullable(initialWaitingSeconds);
        return this;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    public SourceMongodbV2 withInitialWaitingSeconds(Optional<Long> initialWaitingSeconds) {
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        this.initialWaitingSeconds = initialWaitingSeconds;
        return this;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    public SourceMongodbV2 withInvalidCdcCursorPositionBehavior(InvalidCDCPositionBehaviorAdvanced invalidCdcCursorPositionBehavior) {
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        this.invalidCdcCursorPositionBehavior = Optional.ofNullable(invalidCdcCursorPositionBehavior);
        return this;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    public SourceMongodbV2 withInvalidCdcCursorPositionBehavior(Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior) {
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
        return this;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    public SourceMongodbV2 withQueueSize(long queueSize) {
        Utils.checkNotNull(queueSize, "queueSize");
        this.queueSize = Optional.ofNullable(queueSize);
        return this;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    public SourceMongodbV2 withQueueSize(Optional<Long> queueSize) {
        Utils.checkNotNull(queueSize, "queueSize");
        this.queueSize = queueSize;
        return this;
    }

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    public SourceMongodbV2 withUpdateCaptureMode(CaptureModeAdvanced updateCaptureMode) {
        Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
        this.updateCaptureMode = Optional.ofNullable(updateCaptureMode);
        return this;
    }

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    public SourceMongodbV2 withUpdateCaptureMode(Optional<? extends CaptureModeAdvanced> updateCaptureMode) {
        Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
        this.updateCaptureMode = updateCaptureMode;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceMongodbV2 other = (SourceMongodbV2) o;
        return 
            Objects.deepEquals(this.databaseConfig, other.databaseConfig) &&
            Objects.deepEquals(this.discoverSampleSize, other.discoverSampleSize) &&
            Objects.deepEquals(this.initialLoadTimeoutHours, other.initialLoadTimeoutHours) &&
            Objects.deepEquals(this.initialWaitingSeconds, other.initialWaitingSeconds) &&
            Objects.deepEquals(this.invalidCdcCursorPositionBehavior, other.invalidCdcCursorPositionBehavior) &&
            Objects.deepEquals(this.queueSize, other.queueSize) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.updateCaptureMode, other.updateCaptureMode);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            databaseConfig,
            discoverSampleSize,
            initialLoadTimeoutHours,
            initialWaitingSeconds,
            invalidCdcCursorPositionBehavior,
            queueSize,
            sourceType,
            updateCaptureMode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceMongodbV2.class,
                "databaseConfig", databaseConfig,
                "discoverSampleSize", discoverSampleSize,
                "initialLoadTimeoutHours", initialLoadTimeoutHours,
                "initialWaitingSeconds", initialWaitingSeconds,
                "invalidCdcCursorPositionBehavior", invalidCdcCursorPositionBehavior,
                "queueSize", queueSize,
                "sourceType", sourceType,
                "updateCaptureMode", updateCaptureMode);
    }
    
    public final static class Builder {
 
        private ClusterType databaseConfig;
 
        private Optional<Long> discoverSampleSize;
 
        private Optional<Long> initialLoadTimeoutHours;
 
        private Optional<Long> initialWaitingSeconds;
 
        private Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior;
 
        private Optional<Long> queueSize;
 
        private Optional<? extends CaptureModeAdvanced> updateCaptureMode;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Configures the MongoDB cluster type.
         */
        public Builder databaseConfig(ClusterType databaseConfig) {
            Utils.checkNotNull(databaseConfig, "databaseConfig");
            this.databaseConfig = databaseConfig;
            return this;
        }

        /**
         * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
         */
        public Builder discoverSampleSize(long discoverSampleSize) {
            Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
            this.discoverSampleSize = Optional.ofNullable(discoverSampleSize);
            return this;
        }

        /**
         * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
         */
        public Builder discoverSampleSize(Optional<Long> discoverSampleSize) {
            Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
            this.discoverSampleSize = discoverSampleSize;
            return this;
        }

        /**
         * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
         */
        public Builder initialLoadTimeoutHours(long initialLoadTimeoutHours) {
            Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
            this.initialLoadTimeoutHours = Optional.ofNullable(initialLoadTimeoutHours);
            return this;
        }

        /**
         * The amount of time an initial load is allowed to continue for before catching up on CDC logs.
         */
        public Builder initialLoadTimeoutHours(Optional<Long> initialLoadTimeoutHours) {
            Utils.checkNotNull(initialLoadTimeoutHours, "initialLoadTimeoutHours");
            this.initialLoadTimeoutHours = initialLoadTimeoutHours;
            return this;
        }

        /**
         * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
         */
        public Builder initialWaitingSeconds(long initialWaitingSeconds) {
            Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
            this.initialWaitingSeconds = Optional.ofNullable(initialWaitingSeconds);
            return this;
        }

        /**
         * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
         */
        public Builder initialWaitingSeconds(Optional<Long> initialWaitingSeconds) {
            Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
            this.initialWaitingSeconds = initialWaitingSeconds;
            return this;
        }

        /**
         * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
         */
        public Builder invalidCdcCursorPositionBehavior(InvalidCDCPositionBehaviorAdvanced invalidCdcCursorPositionBehavior) {
            Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
            this.invalidCdcCursorPositionBehavior = Optional.ofNullable(invalidCdcCursorPositionBehavior);
            return this;
        }

        /**
         * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
         */
        public Builder invalidCdcCursorPositionBehavior(Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior) {
            Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
            this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
            return this;
        }

        /**
         * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
         */
        public Builder queueSize(long queueSize) {
            Utils.checkNotNull(queueSize, "queueSize");
            this.queueSize = Optional.ofNullable(queueSize);
            return this;
        }

        /**
         * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
         */
        public Builder queueSize(Optional<Long> queueSize) {
            Utils.checkNotNull(queueSize, "queueSize");
            this.queueSize = queueSize;
            return this;
        }

        /**
         * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
         */
        public Builder updateCaptureMode(CaptureModeAdvanced updateCaptureMode) {
            Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
            this.updateCaptureMode = Optional.ofNullable(updateCaptureMode);
            return this;
        }

        /**
         * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
         */
        public Builder updateCaptureMode(Optional<? extends CaptureModeAdvanced> updateCaptureMode) {
            Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
            this.updateCaptureMode = updateCaptureMode;
            return this;
        }
        
        public SourceMongodbV2 build() {
            if (discoverSampleSize == null) {
                discoverSampleSize = _SINGLETON_VALUE_DiscoverSampleSize.value();
            }
            if (initialLoadTimeoutHours == null) {
                initialLoadTimeoutHours = _SINGLETON_VALUE_InitialLoadTimeoutHours.value();
            }
            if (initialWaitingSeconds == null) {
                initialWaitingSeconds = _SINGLETON_VALUE_InitialWaitingSeconds.value();
            }
            if (invalidCdcCursorPositionBehavior == null) {
                invalidCdcCursorPositionBehavior = _SINGLETON_VALUE_InvalidCdcCursorPositionBehavior.value();
            }
            if (queueSize == null) {
                queueSize = _SINGLETON_VALUE_QueueSize.value();
            }
            if (updateCaptureMode == null) {
                updateCaptureMode = _SINGLETON_VALUE_UpdateCaptureMode.value();
            }
            return new SourceMongodbV2(
                databaseConfig,
                discoverSampleSize,
                initialLoadTimeoutHours,
                initialWaitingSeconds,
                invalidCdcCursorPositionBehavior,
                queueSize,
                updateCaptureMode);
        }

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_DiscoverSampleSize =
                new LazySingletonValue<>(
                        "discover_sample_size",
                        "10000",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_InitialLoadTimeoutHours =
                new LazySingletonValue<>(
                        "initial_load_timeout_hours",
                        "8",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_InitialWaitingSeconds =
                new LazySingletonValue<>(
                        "initial_waiting_seconds",
                        "300",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<? extends InvalidCDCPositionBehaviorAdvanced>> _SINGLETON_VALUE_InvalidCdcCursorPositionBehavior =
                new LazySingletonValue<>(
                        "invalid_cdc_cursor_position_behavior",
                        "\"Fail sync\"",
                        new TypeReference<Optional<? extends InvalidCDCPositionBehaviorAdvanced>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_QueueSize =
                new LazySingletonValue<>(
                        "queue_size",
                        "10000",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<MongodbV2> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"mongodb-v2\"",
                        new TypeReference<MongodbV2>() {});

        private static final LazySingletonValue<Optional<? extends CaptureModeAdvanced>> _SINGLETON_VALUE_UpdateCaptureMode =
                new LazySingletonValue<>(
                        "update_capture_mode",
                        "\"Lookup\"",
                        new TypeReference<Optional<? extends CaptureModeAdvanced>>() {});
    }
}
