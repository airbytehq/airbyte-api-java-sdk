/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

public class SourceMongodbV2 {

    /**
     * Configures the MongoDB cluster type.
     */
    @JsonProperty("database_config")
    private java.lang.Object databaseConfig;

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discover_sample_size")
    private Optional<? extends Long> discoverSampleSize;

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initial_waiting_seconds")
    private Optional<? extends Long> initialWaitingSeconds;

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invalid_cdc_cursor_position_behavior")
    private Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior;

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("queue_size")
    private Optional<? extends Long> queueSize;

    @JsonProperty("sourceType")
    private MongodbV2 sourceType;

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("update_capture_mode")
    private Optional<? extends CaptureModeAdvanced> updateCaptureMode;

    @JsonCreator
    public SourceMongodbV2(
            @JsonProperty("database_config") java.lang.Object databaseConfig,
            @JsonProperty("discover_sample_size") Optional<? extends Long> discoverSampleSize,
            @JsonProperty("initial_waiting_seconds") Optional<? extends Long> initialWaitingSeconds,
            @JsonProperty("invalid_cdc_cursor_position_behavior") Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior,
            @JsonProperty("queue_size") Optional<? extends Long> queueSize,
            @JsonProperty("update_capture_mode") Optional<? extends CaptureModeAdvanced> updateCaptureMode) {
        Utils.checkNotNull(databaseConfig, "databaseConfig");
        Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        Utils.checkNotNull(queueSize, "queueSize");
        Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
        this.databaseConfig = databaseConfig;
        this.discoverSampleSize = discoverSampleSize;
        this.initialWaitingSeconds = initialWaitingSeconds;
        this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
        this.queueSize = queueSize;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.updateCaptureMode = updateCaptureMode;
    }
    
    public SourceMongodbV2(
            java.lang.Object databaseConfig) {
        this(databaseConfig, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Configures the MongoDB cluster type.
     */
    @JsonIgnore
    public java.lang.Object databaseConfig() {
        return databaseConfig;
    }

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Long> discoverSampleSize() {
        return (Optional<Long>) discoverSampleSize;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Long> initialWaitingSeconds() {
        return (Optional<Long>) initialWaitingSeconds;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior() {
        return (Optional<InvalidCDCPositionBehaviorAdvanced>) invalidCdcCursorPositionBehavior;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Long> queueSize() {
        return (Optional<Long>) queueSize;
    }

    @JsonIgnore
    public MongodbV2 sourceType() {
        return sourceType;
    }

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CaptureModeAdvanced> updateCaptureMode() {
        return (Optional<CaptureModeAdvanced>) updateCaptureMode;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Configures the MongoDB cluster type.
     */
    public SourceMongodbV2 withDatabaseConfig(java.lang.Object databaseConfig) {
        Utils.checkNotNull(databaseConfig, "databaseConfig");
        this.databaseConfig = databaseConfig;
        return this;
    }

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    public SourceMongodbV2 withDiscoverSampleSize(long discoverSampleSize) {
        Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
        this.discoverSampleSize = Optional.ofNullable(discoverSampleSize);
        return this;
    }

    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
     */
    public SourceMongodbV2 withDiscoverSampleSize(Optional<? extends Long> discoverSampleSize) {
        Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
        this.discoverSampleSize = discoverSampleSize;
        return this;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    public SourceMongodbV2 withInitialWaitingSeconds(long initialWaitingSeconds) {
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        this.initialWaitingSeconds = Optional.ofNullable(initialWaitingSeconds);
        return this;
    }

    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
     */
    public SourceMongodbV2 withInitialWaitingSeconds(Optional<? extends Long> initialWaitingSeconds) {
        Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
        this.initialWaitingSeconds = initialWaitingSeconds;
        return this;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    public SourceMongodbV2 withInvalidCdcCursorPositionBehavior(InvalidCDCPositionBehaviorAdvanced invalidCdcCursorPositionBehavior) {
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        this.invalidCdcCursorPositionBehavior = Optional.ofNullable(invalidCdcCursorPositionBehavior);
        return this;
    }

    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
     */
    public SourceMongodbV2 withInvalidCdcCursorPositionBehavior(Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior) {
        Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
        this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
        return this;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    public SourceMongodbV2 withQueueSize(long queueSize) {
        Utils.checkNotNull(queueSize, "queueSize");
        this.queueSize = Optional.ofNullable(queueSize);
        return this;
    }

    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
     */
    public SourceMongodbV2 withQueueSize(Optional<? extends Long> queueSize) {
        Utils.checkNotNull(queueSize, "queueSize");
        this.queueSize = queueSize;
        return this;
    }

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    public SourceMongodbV2 withUpdateCaptureMode(CaptureModeAdvanced updateCaptureMode) {
        Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
        this.updateCaptureMode = Optional.ofNullable(updateCaptureMode);
        return this;
    }

    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
     */
    public SourceMongodbV2 withUpdateCaptureMode(Optional<? extends CaptureModeAdvanced> updateCaptureMode) {
        Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
        this.updateCaptureMode = updateCaptureMode;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceMongodbV2 other = (SourceMongodbV2) o;
        return 
            java.util.Objects.deepEquals(this.databaseConfig, other.databaseConfig) &&
            java.util.Objects.deepEquals(this.discoverSampleSize, other.discoverSampleSize) &&
            java.util.Objects.deepEquals(this.initialWaitingSeconds, other.initialWaitingSeconds) &&
            java.util.Objects.deepEquals(this.invalidCdcCursorPositionBehavior, other.invalidCdcCursorPositionBehavior) &&
            java.util.Objects.deepEquals(this.queueSize, other.queueSize) &&
            java.util.Objects.deepEquals(this.sourceType, other.sourceType) &&
            java.util.Objects.deepEquals(this.updateCaptureMode, other.updateCaptureMode);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            databaseConfig,
            discoverSampleSize,
            initialWaitingSeconds,
            invalidCdcCursorPositionBehavior,
            queueSize,
            sourceType,
            updateCaptureMode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceMongodbV2.class,
                "databaseConfig", databaseConfig,
                "discoverSampleSize", discoverSampleSize,
                "initialWaitingSeconds", initialWaitingSeconds,
                "invalidCdcCursorPositionBehavior", invalidCdcCursorPositionBehavior,
                "queueSize", queueSize,
                "sourceType", sourceType,
                "updateCaptureMode", updateCaptureMode);
    }
    
    public final static class Builder {
 
        private java.lang.Object databaseConfig;
 
        private Optional<? extends Long> discoverSampleSize;
 
        private Optional<? extends Long> initialWaitingSeconds;
 
        private Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior;
 
        private Optional<? extends Long> queueSize;
 
        private Optional<? extends CaptureModeAdvanced> updateCaptureMode;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Configures the MongoDB cluster type.
         */
        public Builder databaseConfig(java.lang.Object databaseConfig) {
            Utils.checkNotNull(databaseConfig, "databaseConfig");
            this.databaseConfig = databaseConfig;
            return this;
        }

        /**
         * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
         */
        public Builder discoverSampleSize(long discoverSampleSize) {
            Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
            this.discoverSampleSize = Optional.ofNullable(discoverSampleSize);
            return this;
        }

        /**
         * The maximum number of documents to sample when attempting to discover the unique fields for a collection.
         */
        public Builder discoverSampleSize(Optional<? extends Long> discoverSampleSize) {
            Utils.checkNotNull(discoverSampleSize, "discoverSampleSize");
            this.discoverSampleSize = discoverSampleSize;
            return this;
        }

        /**
         * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
         */
        public Builder initialWaitingSeconds(long initialWaitingSeconds) {
            Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
            this.initialWaitingSeconds = Optional.ofNullable(initialWaitingSeconds);
            return this;
        }

        /**
         * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
         */
        public Builder initialWaitingSeconds(Optional<? extends Long> initialWaitingSeconds) {
            Utils.checkNotNull(initialWaitingSeconds, "initialWaitingSeconds");
            this.initialWaitingSeconds = initialWaitingSeconds;
            return this;
        }

        /**
         * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
         */
        public Builder invalidCdcCursorPositionBehavior(InvalidCDCPositionBehaviorAdvanced invalidCdcCursorPositionBehavior) {
            Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
            this.invalidCdcCursorPositionBehavior = Optional.ofNullable(invalidCdcCursorPositionBehavior);
            return this;
        }

        /**
         * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
         */
        public Builder invalidCdcCursorPositionBehavior(Optional<? extends InvalidCDCPositionBehaviorAdvanced> invalidCdcCursorPositionBehavior) {
            Utils.checkNotNull(invalidCdcCursorPositionBehavior, "invalidCdcCursorPositionBehavior");
            this.invalidCdcCursorPositionBehavior = invalidCdcCursorPositionBehavior;
            return this;
        }

        /**
         * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
         */
        public Builder queueSize(long queueSize) {
            Utils.checkNotNull(queueSize, "queueSize");
            this.queueSize = Optional.ofNullable(queueSize);
            return this;
        }

        /**
         * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
         */
        public Builder queueSize(Optional<? extends Long> queueSize) {
            Utils.checkNotNull(queueSize, "queueSize");
            this.queueSize = queueSize;
            return this;
        }

        /**
         * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
         */
        public Builder updateCaptureMode(CaptureModeAdvanced updateCaptureMode) {
            Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
            this.updateCaptureMode = Optional.ofNullable(updateCaptureMode);
            return this;
        }

        /**
         * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
         */
        public Builder updateCaptureMode(Optional<? extends CaptureModeAdvanced> updateCaptureMode) {
            Utils.checkNotNull(updateCaptureMode, "updateCaptureMode");
            this.updateCaptureMode = updateCaptureMode;
            return this;
        }
        
        public SourceMongodbV2 build() {
            if (discoverSampleSize == null) {
                discoverSampleSize = _SINGLETON_VALUE_DiscoverSampleSize.value();
            }
            if (initialWaitingSeconds == null) {
                initialWaitingSeconds = _SINGLETON_VALUE_InitialWaitingSeconds.value();
            }
            if (invalidCdcCursorPositionBehavior == null) {
                invalidCdcCursorPositionBehavior = _SINGLETON_VALUE_InvalidCdcCursorPositionBehavior.value();
            }
            if (queueSize == null) {
                queueSize = _SINGLETON_VALUE_QueueSize.value();
            }
            if (updateCaptureMode == null) {
                updateCaptureMode = _SINGLETON_VALUE_UpdateCaptureMode.value();
            }
            return new SourceMongodbV2(
                databaseConfig,
                discoverSampleSize,
                initialWaitingSeconds,
                invalidCdcCursorPositionBehavior,
                queueSize,
                updateCaptureMode);
        }

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_DiscoverSampleSize =
                new LazySingletonValue<>(
                        "discover_sample_size",
                        "10000",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_InitialWaitingSeconds =
                new LazySingletonValue<>(
                        "initial_waiting_seconds",
                        "300",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<Optional<? extends InvalidCDCPositionBehaviorAdvanced>> _SINGLETON_VALUE_InvalidCdcCursorPositionBehavior =
                new LazySingletonValue<>(
                        "invalid_cdc_cursor_position_behavior",
                        "\"Fail sync\"",
                        new TypeReference<Optional<? extends InvalidCDCPositionBehaviorAdvanced>>() {});

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_QueueSize =
                new LazySingletonValue<>(
                        "queue_size",
                        "10000",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<MongodbV2> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"mongodb-v2\"",
                        new TypeReference<MongodbV2>() {});

        private static final LazySingletonValue<Optional<? extends CaptureModeAdvanced>> _SINGLETON_VALUE_UpdateCaptureMode =
                new LazySingletonValue<>(
                        "update_capture_mode",
                        "\"Lookup\"",
                        new TypeReference<Optional<? extends CaptureModeAdvanced>>() {});
    }
}

