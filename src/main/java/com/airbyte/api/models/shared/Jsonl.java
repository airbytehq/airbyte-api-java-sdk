/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

/**
 * Jsonl - This connector uses &lt;a href="https://arrow.apache.org/docs/python/json.html" target="_blank"&gt;PyArrow&lt;/a&gt; for JSON Lines (jsonl) file parsing.
 */

public class Jsonl {

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("block_size")
    private Optional<? extends Long> blockSize;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filetype")
    private Optional<? extends SourceS3SchemasFormatFiletype> filetype;

    /**
     * Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("newlines_in_values")
    private Optional<? extends Boolean> newlinesInValues;

    /**
     * How JSON fields outside of explicit_schema (if given) are treated. Check &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank"&gt;PyArrow documentation&lt;/a&gt; for details
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unexpected_field_behavior")
    private Optional<? extends UnexpectedFieldBehavior> unexpectedFieldBehavior;

    public Jsonl(
            @JsonProperty("block_size") Optional<? extends Long> blockSize,
            @JsonProperty("newlines_in_values") Optional<? extends Boolean> newlinesInValues,
            @JsonProperty("unexpected_field_behavior") Optional<? extends UnexpectedFieldBehavior> unexpectedFieldBehavior) {
        Utils.checkNotNull(blockSize, "blockSize");
        Utils.checkNotNull(newlinesInValues, "newlinesInValues");
        Utils.checkNotNull(unexpectedFieldBehavior, "unexpectedFieldBehavior");
        this.blockSize = blockSize;
        this.filetype = Builder._SINGLETON_VALUE_Filetype.value();
        this.newlinesInValues = newlinesInValues;
        this.unexpectedFieldBehavior = unexpectedFieldBehavior;
    }

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    public Optional<? extends Long> blockSize() {
        return blockSize;
    }

    public Optional<? extends SourceS3SchemasFormatFiletype> filetype() {
        return filetype;
    }

    /**
     * Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False.
     */
    public Optional<? extends Boolean> newlinesInValues() {
        return newlinesInValues;
    }

    /**
     * How JSON fields outside of explicit_schema (if given) are treated. Check &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank"&gt;PyArrow documentation&lt;/a&gt; for details
     */
    public Optional<? extends UnexpectedFieldBehavior> unexpectedFieldBehavior() {
        return unexpectedFieldBehavior;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    public Jsonl withBlockSize(long blockSize) {
        Utils.checkNotNull(blockSize, "blockSize");
        this.blockSize = Optional.ofNullable(blockSize);
        return this;
    }

    /**
     * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
     */
    public Jsonl withBlockSize(Optional<? extends Long> blockSize) {
        Utils.checkNotNull(blockSize, "blockSize");
        this.blockSize = blockSize;
        return this;
    }

    /**
     * Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False.
     */
    public Jsonl withNewlinesInValues(boolean newlinesInValues) {
        Utils.checkNotNull(newlinesInValues, "newlinesInValues");
        this.newlinesInValues = Optional.ofNullable(newlinesInValues);
        return this;
    }

    /**
     * Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False.
     */
    public Jsonl withNewlinesInValues(Optional<? extends Boolean> newlinesInValues) {
        Utils.checkNotNull(newlinesInValues, "newlinesInValues");
        this.newlinesInValues = newlinesInValues;
        return this;
    }

    /**
     * How JSON fields outside of explicit_schema (if given) are treated. Check &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank"&gt;PyArrow documentation&lt;/a&gt; for details
     */
    public Jsonl withUnexpectedFieldBehavior(UnexpectedFieldBehavior unexpectedFieldBehavior) {
        Utils.checkNotNull(unexpectedFieldBehavior, "unexpectedFieldBehavior");
        this.unexpectedFieldBehavior = Optional.ofNullable(unexpectedFieldBehavior);
        return this;
    }

    /**
     * How JSON fields outside of explicit_schema (if given) are treated. Check &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank"&gt;PyArrow documentation&lt;/a&gt; for details
     */
    public Jsonl withUnexpectedFieldBehavior(Optional<? extends UnexpectedFieldBehavior> unexpectedFieldBehavior) {
        Utils.checkNotNull(unexpectedFieldBehavior, "unexpectedFieldBehavior");
        this.unexpectedFieldBehavior = unexpectedFieldBehavior;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Jsonl other = (Jsonl) o;
        return 
            java.util.Objects.deepEquals(this.blockSize, other.blockSize) &&
            java.util.Objects.deepEquals(this.filetype, other.filetype) &&
            java.util.Objects.deepEquals(this.newlinesInValues, other.newlinesInValues) &&
            java.util.Objects.deepEquals(this.unexpectedFieldBehavior, other.unexpectedFieldBehavior);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            blockSize,
            filetype,
            newlinesInValues,
            unexpectedFieldBehavior);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Jsonl.class,
                "blockSize", blockSize,
                "filetype", filetype,
                "newlinesInValues", newlinesInValues,
                "unexpectedFieldBehavior", unexpectedFieldBehavior);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> blockSize;
 
        private Optional<? extends Boolean> newlinesInValues;
 
        private Optional<? extends UnexpectedFieldBehavior> unexpectedFieldBehavior;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
         */
        public Builder blockSize(long blockSize) {
            Utils.checkNotNull(blockSize, "blockSize");
            this.blockSize = Optional.ofNullable(blockSize);
            return this;
        }

        /**
         * The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors.
         */
        public Builder blockSize(Optional<? extends Long> blockSize) {
            Utils.checkNotNull(blockSize, "blockSize");
            this.blockSize = blockSize;
            return this;
        }

        /**
         * Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False.
         */
        public Builder newlinesInValues(boolean newlinesInValues) {
            Utils.checkNotNull(newlinesInValues, "newlinesInValues");
            this.newlinesInValues = Optional.ofNullable(newlinesInValues);
            return this;
        }

        /**
         * Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False.
         */
        public Builder newlinesInValues(Optional<? extends Boolean> newlinesInValues) {
            Utils.checkNotNull(newlinesInValues, "newlinesInValues");
            this.newlinesInValues = newlinesInValues;
            return this;
        }

        /**
         * How JSON fields outside of explicit_schema (if given) are treated. Check &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank"&gt;PyArrow documentation&lt;/a&gt; for details
         */
        public Builder unexpectedFieldBehavior(UnexpectedFieldBehavior unexpectedFieldBehavior) {
            Utils.checkNotNull(unexpectedFieldBehavior, "unexpectedFieldBehavior");
            this.unexpectedFieldBehavior = Optional.ofNullable(unexpectedFieldBehavior);
            return this;
        }

        /**
         * How JSON fields outside of explicit_schema (if given) are treated. Check &lt;a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank"&gt;PyArrow documentation&lt;/a&gt; for details
         */
        public Builder unexpectedFieldBehavior(Optional<? extends UnexpectedFieldBehavior> unexpectedFieldBehavior) {
            Utils.checkNotNull(unexpectedFieldBehavior, "unexpectedFieldBehavior");
            this.unexpectedFieldBehavior = unexpectedFieldBehavior;
            return this;
        }
        
        public Jsonl build() {
            if (blockSize == null) {
                blockSize = _SINGLETON_VALUE_BlockSize.value();
            }
            if (newlinesInValues == null) {
                newlinesInValues = _SINGLETON_VALUE_NewlinesInValues.value();
            }
            if (unexpectedFieldBehavior == null) {
                unexpectedFieldBehavior = _SINGLETON_VALUE_UnexpectedFieldBehavior.value();
            }
            return new Jsonl(
                blockSize,
                newlinesInValues,
                unexpectedFieldBehavior);
        }

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_BlockSize =
                new LazySingletonValue<>(
                        "block_size",
                        "0",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<Optional<? extends SourceS3SchemasFormatFiletype>> _SINGLETON_VALUE_Filetype =
                new LazySingletonValue<>(
                        "filetype",
                        "\"jsonl\"",
                        new TypeReference<Optional<? extends SourceS3SchemasFormatFiletype>>() {});

        private static final LazySingletonValue<Optional<? extends Boolean>> _SINGLETON_VALUE_NewlinesInValues =
                new LazySingletonValue<>(
                        "newlines_in_values",
                        "false",
                        new TypeReference<Optional<? extends Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends UnexpectedFieldBehavior>> _SINGLETON_VALUE_UnexpectedFieldBehavior =
                new LazySingletonValue<>(
                        "unexpected_field_behavior",
                        "\"infer\"",
                        new TypeReference<Optional<? extends UnexpectedFieldBehavior>>() {});
    }
}

