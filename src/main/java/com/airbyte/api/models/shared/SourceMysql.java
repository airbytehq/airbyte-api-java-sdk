/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;

public class SourceMysql {

    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("check_privileges")
    private Optional<Boolean> checkPrivileges;

    /**
     * How often (in seconds) a stream should checkpoint, when possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("checkpoint_target_interval_seconds")
    private Optional<Long> checkpointTargetIntervalSeconds;

    /**
     * Maximum number of concurrent queries to the database.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("concurrency")
    private Optional<Long> concurrency;

    /**
     * The database name.
     */
    @JsonProperty("database")
    private String database;

    /**
     * Hostname of the database.
     */
    @JsonProperty("host")
    private String host;

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jdbc_url_params")
    private Optional<String> jdbcUrlParams;

    /**
     * The password associated with the username.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("password")
    private Optional<String> password;

    /**
     * Port of the database.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("port")
    private Optional<Long> port;

    /**
     * Configures how data is extracted from the database.
     */
    @JsonProperty("replication_method")
    private SourceMysqlUpdateMethod replicationMethod;

    @JsonProperty("sourceType")
    private SourceMysqlMysql sourceType;

    /**
     * The encryption method which is used when communicating with the database.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ssl_mode")
    private Optional<? extends SourceMysqlEncryption> sslMode;

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tunnel_method")
    private Optional<? extends SourceMysqlSSHTunnelMethod> tunnelMethod;

    /**
     * The username which is used to access the database.
     */
    @JsonProperty("username")
    private String username;

    @JsonCreator
    public SourceMysql(
            @JsonProperty("check_privileges") Optional<Boolean> checkPrivileges,
            @JsonProperty("checkpoint_target_interval_seconds") Optional<Long> checkpointTargetIntervalSeconds,
            @JsonProperty("concurrency") Optional<Long> concurrency,
            @JsonProperty("database") String database,
            @JsonProperty("host") String host,
            @JsonProperty("jdbc_url_params") Optional<String> jdbcUrlParams,
            @JsonProperty("password") Optional<String> password,
            @JsonProperty("port") Optional<Long> port,
            @JsonProperty("replication_method") SourceMysqlUpdateMethod replicationMethod,
            @JsonProperty("ssl_mode") Optional<? extends SourceMysqlEncryption> sslMode,
            @JsonProperty("tunnel_method") Optional<? extends SourceMysqlSSHTunnelMethod> tunnelMethod,
            @JsonProperty("username") String username) {
        Utils.checkNotNull(checkPrivileges, "checkPrivileges");
        Utils.checkNotNull(checkpointTargetIntervalSeconds, "checkpointTargetIntervalSeconds");
        Utils.checkNotNull(concurrency, "concurrency");
        Utils.checkNotNull(database, "database");
        Utils.checkNotNull(host, "host");
        Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
        Utils.checkNotNull(password, "password");
        Utils.checkNotNull(port, "port");
        Utils.checkNotNull(replicationMethod, "replicationMethod");
        Utils.checkNotNull(sslMode, "sslMode");
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        Utils.checkNotNull(username, "username");
        this.checkPrivileges = checkPrivileges;
        this.checkpointTargetIntervalSeconds = checkpointTargetIntervalSeconds;
        this.concurrency = concurrency;
        this.database = database;
        this.host = host;
        this.jdbcUrlParams = jdbcUrlParams;
        this.password = password;
        this.port = port;
        this.replicationMethod = replicationMethod;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.sslMode = sslMode;
        this.tunnelMethod = tunnelMethod;
        this.username = username;
    }
    
    public SourceMysql(
            String database,
            String host,
            SourceMysqlUpdateMethod replicationMethod,
            String username) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), database, host, Optional.empty(), Optional.empty(), Optional.empty(), replicationMethod, Optional.empty(), Optional.empty(), username);
    }

    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
     */
    @JsonIgnore
    public Optional<Boolean> checkPrivileges() {
        return checkPrivileges;
    }

    /**
     * How often (in seconds) a stream should checkpoint, when possible.
     */
    @JsonIgnore
    public Optional<Long> checkpointTargetIntervalSeconds() {
        return checkpointTargetIntervalSeconds;
    }

    /**
     * Maximum number of concurrent queries to the database.
     */
    @JsonIgnore
    public Optional<Long> concurrency() {
        return concurrency;
    }

    /**
     * The database name.
     */
    @JsonIgnore
    public String database() {
        return database;
    }

    /**
     * Hostname of the database.
     */
    @JsonIgnore
    public String host() {
        return host;
    }

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    @JsonIgnore
    public Optional<String> jdbcUrlParams() {
        return jdbcUrlParams;
    }

    /**
     * The password associated with the username.
     */
    @JsonIgnore
    public Optional<String> password() {
        return password;
    }

    /**
     * Port of the database.
     */
    @JsonIgnore
    public Optional<Long> port() {
        return port;
    }

    /**
     * Configures how data is extracted from the database.
     */
    @JsonIgnore
    public SourceMysqlUpdateMethod replicationMethod() {
        return replicationMethod;
    }

    @JsonIgnore
    public SourceMysqlMysql sourceType() {
        return sourceType;
    }

    /**
     * The encryption method which is used when communicating with the database.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceMysqlEncryption> sslMode() {
        return (Optional<SourceMysqlEncryption>) sslMode;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceMysqlSSHTunnelMethod> tunnelMethod() {
        return (Optional<SourceMysqlSSHTunnelMethod>) tunnelMethod;
    }

    /**
     * The username which is used to access the database.
     */
    @JsonIgnore
    public String username() {
        return username;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
     */
    public SourceMysql withCheckPrivileges(boolean checkPrivileges) {
        Utils.checkNotNull(checkPrivileges, "checkPrivileges");
        this.checkPrivileges = Optional.ofNullable(checkPrivileges);
        return this;
    }

    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
     */
    public SourceMysql withCheckPrivileges(Optional<Boolean> checkPrivileges) {
        Utils.checkNotNull(checkPrivileges, "checkPrivileges");
        this.checkPrivileges = checkPrivileges;
        return this;
    }

    /**
     * How often (in seconds) a stream should checkpoint, when possible.
     */
    public SourceMysql withCheckpointTargetIntervalSeconds(long checkpointTargetIntervalSeconds) {
        Utils.checkNotNull(checkpointTargetIntervalSeconds, "checkpointTargetIntervalSeconds");
        this.checkpointTargetIntervalSeconds = Optional.ofNullable(checkpointTargetIntervalSeconds);
        return this;
    }

    /**
     * How often (in seconds) a stream should checkpoint, when possible.
     */
    public SourceMysql withCheckpointTargetIntervalSeconds(Optional<Long> checkpointTargetIntervalSeconds) {
        Utils.checkNotNull(checkpointTargetIntervalSeconds, "checkpointTargetIntervalSeconds");
        this.checkpointTargetIntervalSeconds = checkpointTargetIntervalSeconds;
        return this;
    }

    /**
     * Maximum number of concurrent queries to the database.
     */
    public SourceMysql withConcurrency(long concurrency) {
        Utils.checkNotNull(concurrency, "concurrency");
        this.concurrency = Optional.ofNullable(concurrency);
        return this;
    }

    /**
     * Maximum number of concurrent queries to the database.
     */
    public SourceMysql withConcurrency(Optional<Long> concurrency) {
        Utils.checkNotNull(concurrency, "concurrency");
        this.concurrency = concurrency;
        return this;
    }

    /**
     * The database name.
     */
    public SourceMysql withDatabase(String database) {
        Utils.checkNotNull(database, "database");
        this.database = database;
        return this;
    }

    /**
     * Hostname of the database.
     */
    public SourceMysql withHost(String host) {
        Utils.checkNotNull(host, "host");
        this.host = host;
        return this;
    }

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    public SourceMysql withJdbcUrlParams(String jdbcUrlParams) {
        Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
        this.jdbcUrlParams = Optional.ofNullable(jdbcUrlParams);
        return this;
    }

    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
     */
    public SourceMysql withJdbcUrlParams(Optional<String> jdbcUrlParams) {
        Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
        this.jdbcUrlParams = jdbcUrlParams;
        return this;
    }

    /**
     * The password associated with the username.
     */
    public SourceMysql withPassword(String password) {
        Utils.checkNotNull(password, "password");
        this.password = Optional.ofNullable(password);
        return this;
    }

    /**
     * The password associated with the username.
     */
    public SourceMysql withPassword(Optional<String> password) {
        Utils.checkNotNull(password, "password");
        this.password = password;
        return this;
    }

    /**
     * Port of the database.
     */
    public SourceMysql withPort(long port) {
        Utils.checkNotNull(port, "port");
        this.port = Optional.ofNullable(port);
        return this;
    }

    /**
     * Port of the database.
     */
    public SourceMysql withPort(Optional<Long> port) {
        Utils.checkNotNull(port, "port");
        this.port = port;
        return this;
    }

    /**
     * Configures how data is extracted from the database.
     */
    public SourceMysql withReplicationMethod(SourceMysqlUpdateMethod replicationMethod) {
        Utils.checkNotNull(replicationMethod, "replicationMethod");
        this.replicationMethod = replicationMethod;
        return this;
    }

    /**
     * The encryption method which is used when communicating with the database.
     */
    public SourceMysql withSslMode(SourceMysqlEncryption sslMode) {
        Utils.checkNotNull(sslMode, "sslMode");
        this.sslMode = Optional.ofNullable(sslMode);
        return this;
    }

    /**
     * The encryption method which is used when communicating with the database.
     */
    public SourceMysql withSslMode(Optional<? extends SourceMysqlEncryption> sslMode) {
        Utils.checkNotNull(sslMode, "sslMode");
        this.sslMode = sslMode;
        return this;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    public SourceMysql withTunnelMethod(SourceMysqlSSHTunnelMethod tunnelMethod) {
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        this.tunnelMethod = Optional.ofNullable(tunnelMethod);
        return this;
    }

    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    public SourceMysql withTunnelMethod(Optional<? extends SourceMysqlSSHTunnelMethod> tunnelMethod) {
        Utils.checkNotNull(tunnelMethod, "tunnelMethod");
        this.tunnelMethod = tunnelMethod;
        return this;
    }

    /**
     * The username which is used to access the database.
     */
    public SourceMysql withUsername(String username) {
        Utils.checkNotNull(username, "username");
        this.username = username;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceMysql other = (SourceMysql) o;
        return 
            Objects.deepEquals(this.checkPrivileges, other.checkPrivileges) &&
            Objects.deepEquals(this.checkpointTargetIntervalSeconds, other.checkpointTargetIntervalSeconds) &&
            Objects.deepEquals(this.concurrency, other.concurrency) &&
            Objects.deepEquals(this.database, other.database) &&
            Objects.deepEquals(this.host, other.host) &&
            Objects.deepEquals(this.jdbcUrlParams, other.jdbcUrlParams) &&
            Objects.deepEquals(this.password, other.password) &&
            Objects.deepEquals(this.port, other.port) &&
            Objects.deepEquals(this.replicationMethod, other.replicationMethod) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.sslMode, other.sslMode) &&
            Objects.deepEquals(this.tunnelMethod, other.tunnelMethod) &&
            Objects.deepEquals(this.username, other.username);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            checkPrivileges,
            checkpointTargetIntervalSeconds,
            concurrency,
            database,
            host,
            jdbcUrlParams,
            password,
            port,
            replicationMethod,
            sourceType,
            sslMode,
            tunnelMethod,
            username);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceMysql.class,
                "checkPrivileges", checkPrivileges,
                "checkpointTargetIntervalSeconds", checkpointTargetIntervalSeconds,
                "concurrency", concurrency,
                "database", database,
                "host", host,
                "jdbcUrlParams", jdbcUrlParams,
                "password", password,
                "port", port,
                "replicationMethod", replicationMethod,
                "sourceType", sourceType,
                "sslMode", sslMode,
                "tunnelMethod", tunnelMethod,
                "username", username);
    }
    
    public final static class Builder {
 
        private Optional<Boolean> checkPrivileges;
 
        private Optional<Long> checkpointTargetIntervalSeconds;
 
        private Optional<Long> concurrency;
 
        private String database;
 
        private String host;
 
        private Optional<String> jdbcUrlParams = Optional.empty();
 
        private Optional<String> password = Optional.empty();
 
        private Optional<Long> port;
 
        private SourceMysqlUpdateMethod replicationMethod;
 
        private Optional<? extends SourceMysqlEncryption> sslMode = Optional.empty();
 
        private Optional<? extends SourceMysqlSSHTunnelMethod> tunnelMethod = Optional.empty();
 
        private String username;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
         */
        public Builder checkPrivileges(boolean checkPrivileges) {
            Utils.checkNotNull(checkPrivileges, "checkPrivileges");
            this.checkPrivileges = Optional.ofNullable(checkPrivileges);
            return this;
        }

        /**
         * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
         */
        public Builder checkPrivileges(Optional<Boolean> checkPrivileges) {
            Utils.checkNotNull(checkPrivileges, "checkPrivileges");
            this.checkPrivileges = checkPrivileges;
            return this;
        }

        /**
         * How often (in seconds) a stream should checkpoint, when possible.
         */
        public Builder checkpointTargetIntervalSeconds(long checkpointTargetIntervalSeconds) {
            Utils.checkNotNull(checkpointTargetIntervalSeconds, "checkpointTargetIntervalSeconds");
            this.checkpointTargetIntervalSeconds = Optional.ofNullable(checkpointTargetIntervalSeconds);
            return this;
        }

        /**
         * How often (in seconds) a stream should checkpoint, when possible.
         */
        public Builder checkpointTargetIntervalSeconds(Optional<Long> checkpointTargetIntervalSeconds) {
            Utils.checkNotNull(checkpointTargetIntervalSeconds, "checkpointTargetIntervalSeconds");
            this.checkpointTargetIntervalSeconds = checkpointTargetIntervalSeconds;
            return this;
        }

        /**
         * Maximum number of concurrent queries to the database.
         */
        public Builder concurrency(long concurrency) {
            Utils.checkNotNull(concurrency, "concurrency");
            this.concurrency = Optional.ofNullable(concurrency);
            return this;
        }

        /**
         * Maximum number of concurrent queries to the database.
         */
        public Builder concurrency(Optional<Long> concurrency) {
            Utils.checkNotNull(concurrency, "concurrency");
            this.concurrency = concurrency;
            return this;
        }

        /**
         * The database name.
         */
        public Builder database(String database) {
            Utils.checkNotNull(database, "database");
            this.database = database;
            return this;
        }

        /**
         * Hostname of the database.
         */
        public Builder host(String host) {
            Utils.checkNotNull(host, "host");
            this.host = host;
            return this;
        }

        /**
         * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
         */
        public Builder jdbcUrlParams(String jdbcUrlParams) {
            Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
            this.jdbcUrlParams = Optional.ofNullable(jdbcUrlParams);
            return this;
        }

        /**
         * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&amp;'. (example: key1=value1&amp;key2=value2&amp;key3=value3).
         */
        public Builder jdbcUrlParams(Optional<String> jdbcUrlParams) {
            Utils.checkNotNull(jdbcUrlParams, "jdbcUrlParams");
            this.jdbcUrlParams = jdbcUrlParams;
            return this;
        }

        /**
         * The password associated with the username.
         */
        public Builder password(String password) {
            Utils.checkNotNull(password, "password");
            this.password = Optional.ofNullable(password);
            return this;
        }

        /**
         * The password associated with the username.
         */
        public Builder password(Optional<String> password) {
            Utils.checkNotNull(password, "password");
            this.password = password;
            return this;
        }

        /**
         * Port of the database.
         */
        public Builder port(long port) {
            Utils.checkNotNull(port, "port");
            this.port = Optional.ofNullable(port);
            return this;
        }

        /**
         * Port of the database.
         */
        public Builder port(Optional<Long> port) {
            Utils.checkNotNull(port, "port");
            this.port = port;
            return this;
        }

        /**
         * Configures how data is extracted from the database.
         */
        public Builder replicationMethod(SourceMysqlUpdateMethod replicationMethod) {
            Utils.checkNotNull(replicationMethod, "replicationMethod");
            this.replicationMethod = replicationMethod;
            return this;
        }

        /**
         * The encryption method which is used when communicating with the database.
         */
        public Builder sslMode(SourceMysqlEncryption sslMode) {
            Utils.checkNotNull(sslMode, "sslMode");
            this.sslMode = Optional.ofNullable(sslMode);
            return this;
        }

        /**
         * The encryption method which is used when communicating with the database.
         */
        public Builder sslMode(Optional<? extends SourceMysqlEncryption> sslMode) {
            Utils.checkNotNull(sslMode, "sslMode");
            this.sslMode = sslMode;
            return this;
        }

        /**
         * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
         */
        public Builder tunnelMethod(SourceMysqlSSHTunnelMethod tunnelMethod) {
            Utils.checkNotNull(tunnelMethod, "tunnelMethod");
            this.tunnelMethod = Optional.ofNullable(tunnelMethod);
            return this;
        }

        /**
         * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
         */
        public Builder tunnelMethod(Optional<? extends SourceMysqlSSHTunnelMethod> tunnelMethod) {
            Utils.checkNotNull(tunnelMethod, "tunnelMethod");
            this.tunnelMethod = tunnelMethod;
            return this;
        }

        /**
         * The username which is used to access the database.
         */
        public Builder username(String username) {
            Utils.checkNotNull(username, "username");
            this.username = username;
            return this;
        }
        
        public SourceMysql build() {
            if (checkPrivileges == null) {
                checkPrivileges = _SINGLETON_VALUE_CheckPrivileges.value();
            }
            if (checkpointTargetIntervalSeconds == null) {
                checkpointTargetIntervalSeconds = _SINGLETON_VALUE_CheckpointTargetIntervalSeconds.value();
            }
            if (concurrency == null) {
                concurrency = _SINGLETON_VALUE_Concurrency.value();
            }
            if (port == null) {
                port = _SINGLETON_VALUE_Port.value();
            }
            return new SourceMysql(
                checkPrivileges,
                checkpointTargetIntervalSeconds,
                concurrency,
                database,
                host,
                jdbcUrlParams,
                password,
                port,
                replicationMethod,
                sslMode,
                tunnelMethod,
                username);
        }

        private static final LazySingletonValue<Optional<Boolean>> _SINGLETON_VALUE_CheckPrivileges =
                new LazySingletonValue<>(
                        "check_privileges",
                        "true",
                        new TypeReference<Optional<Boolean>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_CheckpointTargetIntervalSeconds =
                new LazySingletonValue<>(
                        "checkpoint_target_interval_seconds",
                        "300",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_Concurrency =
                new LazySingletonValue<>(
                        "concurrency",
                        "1",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<Optional<Long>> _SINGLETON_VALUE_Port =
                new LazySingletonValue<>(
                        "port",
                        "3306",
                        new TypeReference<Optional<Long>>() {});

        private static final LazySingletonValue<SourceMysqlMysql> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"mysql\"",
                        new TypeReference<SourceMysqlMysql>() {});
    }
}
