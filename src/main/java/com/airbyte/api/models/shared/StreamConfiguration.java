/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.airbyte.api.models.shared;

import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * StreamConfiguration
 * 
 * <p>Configurations for a single stream.
 */
public class StreamConfiguration {

    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cursorField")
    private Optional<? extends List<String>> cursorField;

    /**
     * The name of the destination object that this stream will be written to, used for data activation destinations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("destinationObjectName")
    private Optional<String> destinationObjectName;

    /**
     * Whether to move raw files from the source to the destination during the sync.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("includeFiles")
    private Optional<Boolean> includeFiles;

    /**
     * Mappers that should be applied to the stream before writing to the destination.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mappers")
    private Optional<? extends List<ConfiguredStreamMapper>> mappers;

    @JsonProperty("name")
    private String name;

    /**
     * Namespace of the stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("namespace")
    private Optional<String> namespace;

    /**
     * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("primaryKey")
    private Optional<? extends List<List<String>>> primaryKey;

    /**
     * Paths to the fields that will be included in the configured catalog.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("selectedFields")
    private Optional<? extends List<SelectedFieldInfo>> selectedFields;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("syncMode")
    private Optional<? extends ConnectionSyncModeEnum> syncMode;

    @JsonCreator
    public StreamConfiguration(
            @JsonProperty("cursorField") Optional<? extends List<String>> cursorField,
            @JsonProperty("destinationObjectName") Optional<String> destinationObjectName,
            @JsonProperty("includeFiles") Optional<Boolean> includeFiles,
            @JsonProperty("mappers") Optional<? extends List<ConfiguredStreamMapper>> mappers,
            @JsonProperty("name") String name,
            @JsonProperty("namespace") Optional<String> namespace,
            @JsonProperty("primaryKey") Optional<? extends List<List<String>>> primaryKey,
            @JsonProperty("selectedFields") Optional<? extends List<SelectedFieldInfo>> selectedFields,
            @JsonProperty("syncMode") Optional<? extends ConnectionSyncModeEnum> syncMode) {
        Utils.checkNotNull(cursorField, "cursorField");
        Utils.checkNotNull(destinationObjectName, "destinationObjectName");
        Utils.checkNotNull(includeFiles, "includeFiles");
        Utils.checkNotNull(mappers, "mappers");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(namespace, "namespace");
        Utils.checkNotNull(primaryKey, "primaryKey");
        Utils.checkNotNull(selectedFields, "selectedFields");
        Utils.checkNotNull(syncMode, "syncMode");
        this.cursorField = cursorField;
        this.destinationObjectName = destinationObjectName;
        this.includeFiles = includeFiles;
        this.mappers = mappers;
        this.name = name;
        this.namespace = namespace;
        this.primaryKey = primaryKey;
        this.selectedFields = selectedFields;
        this.syncMode = syncMode;
    }
    
    public StreamConfiguration(
            String name) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), name, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> cursorField() {
        return (Optional<List<String>>) cursorField;
    }

    /**
     * The name of the destination object that this stream will be written to, used for data activation destinations.
     */
    @JsonIgnore
    public Optional<String> destinationObjectName() {
        return destinationObjectName;
    }

    /**
     * Whether to move raw files from the source to the destination during the sync.
     */
    @JsonIgnore
    public Optional<Boolean> includeFiles() {
        return includeFiles;
    }

    /**
     * Mappers that should be applied to the stream before writing to the destination.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ConfiguredStreamMapper>> mappers() {
        return (Optional<List<ConfiguredStreamMapper>>) mappers;
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    /**
     * Namespace of the stream.
     */
    @JsonIgnore
    public Optional<String> namespace() {
        return namespace;
    }

    /**
     * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<List<String>>> primaryKey() {
        return (Optional<List<List<String>>>) primaryKey;
    }

    /**
     * Paths to the fields that will be included in the configured catalog.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SelectedFieldInfo>> selectedFields() {
        return (Optional<List<SelectedFieldInfo>>) selectedFields;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ConnectionSyncModeEnum> syncMode() {
        return (Optional<ConnectionSyncModeEnum>) syncMode;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
     */
    public StreamConfiguration withCursorField(List<String> cursorField) {
        Utils.checkNotNull(cursorField, "cursorField");
        this.cursorField = Optional.ofNullable(cursorField);
        return this;
    }

    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
     */
    public StreamConfiguration withCursorField(Optional<? extends List<String>> cursorField) {
        Utils.checkNotNull(cursorField, "cursorField");
        this.cursorField = cursorField;
        return this;
    }

    /**
     * The name of the destination object that this stream will be written to, used for data activation destinations.
     */
    public StreamConfiguration withDestinationObjectName(String destinationObjectName) {
        Utils.checkNotNull(destinationObjectName, "destinationObjectName");
        this.destinationObjectName = Optional.ofNullable(destinationObjectName);
        return this;
    }

    /**
     * The name of the destination object that this stream will be written to, used for data activation destinations.
     */
    public StreamConfiguration withDestinationObjectName(Optional<String> destinationObjectName) {
        Utils.checkNotNull(destinationObjectName, "destinationObjectName");
        this.destinationObjectName = destinationObjectName;
        return this;
    }

    /**
     * Whether to move raw files from the source to the destination during the sync.
     */
    public StreamConfiguration withIncludeFiles(boolean includeFiles) {
        Utils.checkNotNull(includeFiles, "includeFiles");
        this.includeFiles = Optional.ofNullable(includeFiles);
        return this;
    }

    /**
     * Whether to move raw files from the source to the destination during the sync.
     */
    public StreamConfiguration withIncludeFiles(Optional<Boolean> includeFiles) {
        Utils.checkNotNull(includeFiles, "includeFiles");
        this.includeFiles = includeFiles;
        return this;
    }

    /**
     * Mappers that should be applied to the stream before writing to the destination.
     */
    public StreamConfiguration withMappers(List<ConfiguredStreamMapper> mappers) {
        Utils.checkNotNull(mappers, "mappers");
        this.mappers = Optional.ofNullable(mappers);
        return this;
    }

    /**
     * Mappers that should be applied to the stream before writing to the destination.
     */
    public StreamConfiguration withMappers(Optional<? extends List<ConfiguredStreamMapper>> mappers) {
        Utils.checkNotNull(mappers, "mappers");
        this.mappers = mappers;
        return this;
    }

    public StreamConfiguration withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Namespace of the stream.
     */
    public StreamConfiguration withNamespace(String namespace) {
        Utils.checkNotNull(namespace, "namespace");
        this.namespace = Optional.ofNullable(namespace);
        return this;
    }

    /**
     * Namespace of the stream.
     */
    public StreamConfiguration withNamespace(Optional<String> namespace) {
        Utils.checkNotNull(namespace, "namespace");
        this.namespace = namespace;
        return this;
    }

    /**
     * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
     */
    public StreamConfiguration withPrimaryKey(List<List<String>> primaryKey) {
        Utils.checkNotNull(primaryKey, "primaryKey");
        this.primaryKey = Optional.ofNullable(primaryKey);
        return this;
    }

    /**
     * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
     */
    public StreamConfiguration withPrimaryKey(Optional<? extends List<List<String>>> primaryKey) {
        Utils.checkNotNull(primaryKey, "primaryKey");
        this.primaryKey = primaryKey;
        return this;
    }

    /**
     * Paths to the fields that will be included in the configured catalog.
     */
    public StreamConfiguration withSelectedFields(List<SelectedFieldInfo> selectedFields) {
        Utils.checkNotNull(selectedFields, "selectedFields");
        this.selectedFields = Optional.ofNullable(selectedFields);
        return this;
    }

    /**
     * Paths to the fields that will be included in the configured catalog.
     */
    public StreamConfiguration withSelectedFields(Optional<? extends List<SelectedFieldInfo>> selectedFields) {
        Utils.checkNotNull(selectedFields, "selectedFields");
        this.selectedFields = selectedFields;
        return this;
    }

    public StreamConfiguration withSyncMode(ConnectionSyncModeEnum syncMode) {
        Utils.checkNotNull(syncMode, "syncMode");
        this.syncMode = Optional.ofNullable(syncMode);
        return this;
    }

    public StreamConfiguration withSyncMode(Optional<? extends ConnectionSyncModeEnum> syncMode) {
        Utils.checkNotNull(syncMode, "syncMode");
        this.syncMode = syncMode;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        StreamConfiguration other = (StreamConfiguration) o;
        return 
            Objects.deepEquals(this.cursorField, other.cursorField) &&
            Objects.deepEquals(this.destinationObjectName, other.destinationObjectName) &&
            Objects.deepEquals(this.includeFiles, other.includeFiles) &&
            Objects.deepEquals(this.mappers, other.mappers) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.namespace, other.namespace) &&
            Objects.deepEquals(this.primaryKey, other.primaryKey) &&
            Objects.deepEquals(this.selectedFields, other.selectedFields) &&
            Objects.deepEquals(this.syncMode, other.syncMode);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            cursorField,
            destinationObjectName,
            includeFiles,
            mappers,
            name,
            namespace,
            primaryKey,
            selectedFields,
            syncMode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(StreamConfiguration.class,
                "cursorField", cursorField,
                "destinationObjectName", destinationObjectName,
                "includeFiles", includeFiles,
                "mappers", mappers,
                "name", name,
                "namespace", namespace,
                "primaryKey", primaryKey,
                "selectedFields", selectedFields,
                "syncMode", syncMode);
    }
    
    public final static class Builder {
 
        private Optional<? extends List<String>> cursorField = Optional.empty();
 
        private Optional<String> destinationObjectName = Optional.empty();
 
        private Optional<Boolean> includeFiles = Optional.empty();
 
        private Optional<? extends List<ConfiguredStreamMapper>> mappers = Optional.empty();
 
        private String name;
 
        private Optional<String> namespace = Optional.empty();
 
        private Optional<? extends List<List<String>>> primaryKey = Optional.empty();
 
        private Optional<? extends List<SelectedFieldInfo>> selectedFields = Optional.empty();
 
        private Optional<? extends ConnectionSyncModeEnum> syncMode = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
         */
        public Builder cursorField(List<String> cursorField) {
            Utils.checkNotNull(cursorField, "cursorField");
            this.cursorField = Optional.ofNullable(cursorField);
            return this;
        }

        /**
         * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
         */
        public Builder cursorField(Optional<? extends List<String>> cursorField) {
            Utils.checkNotNull(cursorField, "cursorField");
            this.cursorField = cursorField;
            return this;
        }

        /**
         * The name of the destination object that this stream will be written to, used for data activation destinations.
         */
        public Builder destinationObjectName(String destinationObjectName) {
            Utils.checkNotNull(destinationObjectName, "destinationObjectName");
            this.destinationObjectName = Optional.ofNullable(destinationObjectName);
            return this;
        }

        /**
         * The name of the destination object that this stream will be written to, used for data activation destinations.
         */
        public Builder destinationObjectName(Optional<String> destinationObjectName) {
            Utils.checkNotNull(destinationObjectName, "destinationObjectName");
            this.destinationObjectName = destinationObjectName;
            return this;
        }

        /**
         * Whether to move raw files from the source to the destination during the sync.
         */
        public Builder includeFiles(boolean includeFiles) {
            Utils.checkNotNull(includeFiles, "includeFiles");
            this.includeFiles = Optional.ofNullable(includeFiles);
            return this;
        }

        /**
         * Whether to move raw files from the source to the destination during the sync.
         */
        public Builder includeFiles(Optional<Boolean> includeFiles) {
            Utils.checkNotNull(includeFiles, "includeFiles");
            this.includeFiles = includeFiles;
            return this;
        }

        /**
         * Mappers that should be applied to the stream before writing to the destination.
         */
        public Builder mappers(List<ConfiguredStreamMapper> mappers) {
            Utils.checkNotNull(mappers, "mappers");
            this.mappers = Optional.ofNullable(mappers);
            return this;
        }

        /**
         * Mappers that should be applied to the stream before writing to the destination.
         */
        public Builder mappers(Optional<? extends List<ConfiguredStreamMapper>> mappers) {
            Utils.checkNotNull(mappers, "mappers");
            this.mappers = mappers;
            return this;
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Namespace of the stream.
         */
        public Builder namespace(String namespace) {
            Utils.checkNotNull(namespace, "namespace");
            this.namespace = Optional.ofNullable(namespace);
            return this;
        }

        /**
         * Namespace of the stream.
         */
        public Builder namespace(Optional<String> namespace) {
            Utils.checkNotNull(namespace, "namespace");
            this.namespace = namespace;
            return this;
        }

        /**
         * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
         */
        public Builder primaryKey(List<List<String>> primaryKey) {
            Utils.checkNotNull(primaryKey, "primaryKey");
            this.primaryKey = Optional.ofNullable(primaryKey);
            return this;
        }

        /**
         * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
         */
        public Builder primaryKey(Optional<? extends List<List<String>>> primaryKey) {
            Utils.checkNotNull(primaryKey, "primaryKey");
            this.primaryKey = primaryKey;
            return this;
        }

        /**
         * Paths to the fields that will be included in the configured catalog.
         */
        public Builder selectedFields(List<SelectedFieldInfo> selectedFields) {
            Utils.checkNotNull(selectedFields, "selectedFields");
            this.selectedFields = Optional.ofNullable(selectedFields);
            return this;
        }

        /**
         * Paths to the fields that will be included in the configured catalog.
         */
        public Builder selectedFields(Optional<? extends List<SelectedFieldInfo>> selectedFields) {
            Utils.checkNotNull(selectedFields, "selectedFields");
            this.selectedFields = selectedFields;
            return this;
        }

        public Builder syncMode(ConnectionSyncModeEnum syncMode) {
            Utils.checkNotNull(syncMode, "syncMode");
            this.syncMode = Optional.ofNullable(syncMode);
            return this;
        }

        public Builder syncMode(Optional<? extends ConnectionSyncModeEnum> syncMode) {
            Utils.checkNotNull(syncMode, "syncMode");
            this.syncMode = syncMode;
            return this;
        }
        
        public StreamConfiguration build() {
            return new StreamConfiguration(
                cursorField,
                destinationObjectName,
                includeFiles,
                mappers,
                name,
                namespace,
                primaryKey,
                selectedFields,
                syncMode);
        }
    }
}
