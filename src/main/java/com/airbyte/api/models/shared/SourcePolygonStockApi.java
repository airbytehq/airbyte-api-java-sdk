/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;

import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.LocalDate;
import java.util.Optional;


public class SourcePolygonStockApi {

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("adjusted")
    private Optional<? extends String> adjusted;

    /**
     * Your API ACCESS Key
     */
    @JsonProperty("apiKey")
    private String apiKey;

    /**
     * The target date for the aggregate window.
     */
    @JsonProperty("end_date")
    private LocalDate endDate;

    /**
     * The target date for the aggregate window.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("limit")
    private Optional<? extends Long> limit;

    /**
     * The size of the timespan multiplier.
     */
    @JsonProperty("multiplier")
    private long multiplier;

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort")
    private Optional<? extends String> sort;

    @JsonProperty("sourceType")
    private PolygonStockApi sourceType;

    /**
     * The beginning date for the aggregate window.
     */
    @JsonProperty("start_date")
    private LocalDate startDate;

    /**
     * The exchange symbol that this item is traded under.
     */
    @JsonProperty("stocksTicker")
    private String stocksTicker;

    /**
     * The size of the time window.
     */
    @JsonProperty("timespan")
    private String timespan;

    public SourcePolygonStockApi(
            @JsonProperty("adjusted") Optional<? extends String> adjusted,
            @JsonProperty("apiKey") String apiKey,
            @JsonProperty("end_date") LocalDate endDate,
            @JsonProperty("limit") Optional<? extends Long> limit,
            @JsonProperty("multiplier") long multiplier,
            @JsonProperty("sort") Optional<? extends String> sort,
            @JsonProperty("start_date") LocalDate startDate,
            @JsonProperty("stocksTicker") String stocksTicker,
            @JsonProperty("timespan") String timespan) {
        Utils.checkNotNull(adjusted, "adjusted");
        Utils.checkNotNull(apiKey, "apiKey");
        Utils.checkNotNull(endDate, "endDate");
        Utils.checkNotNull(limit, "limit");
        Utils.checkNotNull(multiplier, "multiplier");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(stocksTicker, "stocksTicker");
        Utils.checkNotNull(timespan, "timespan");
        this.adjusted = adjusted;
        this.apiKey = apiKey;
        this.endDate = endDate;
        this.limit = limit;
        this.multiplier = multiplier;
        this.sort = sort;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.stocksTicker = stocksTicker;
        this.timespan = timespan;
    }

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    public Optional<? extends String> adjusted() {
        return adjusted;
    }

    /**
     * Your API ACCESS Key
     */
    public String apiKey() {
        return apiKey;
    }

    /**
     * The target date for the aggregate window.
     */
    public LocalDate endDate() {
        return endDate;
    }

    /**
     * The target date for the aggregate window.
     */
    public Optional<? extends Long> limit() {
        return limit;
    }

    /**
     * The size of the timespan multiplier.
     */
    public long multiplier() {
        return multiplier;
    }

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    public Optional<? extends String> sort() {
        return sort;
    }

    public PolygonStockApi sourceType() {
        return sourceType;
    }

    /**
     * The beginning date for the aggregate window.
     */
    public LocalDate startDate() {
        return startDate;
    }

    /**
     * The exchange symbol that this item is traded under.
     */
    public String stocksTicker() {
        return stocksTicker;
    }

    /**
     * The size of the time window.
     */
    public String timespan() {
        return timespan;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    public SourcePolygonStockApi withAdjusted(String adjusted) {
        Utils.checkNotNull(adjusted, "adjusted");
        this.adjusted = Optional.ofNullable(adjusted);
        return this;
    }

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    public SourcePolygonStockApi withAdjusted(Optional<? extends String> adjusted) {
        Utils.checkNotNull(adjusted, "adjusted");
        this.adjusted = adjusted;
        return this;
    }

    /**
     * Your API ACCESS Key
     */
    public SourcePolygonStockApi withApiKey(String apiKey) {
        Utils.checkNotNull(apiKey, "apiKey");
        this.apiKey = apiKey;
        return this;
    }

    /**
     * The target date for the aggregate window.
     */
    public SourcePolygonStockApi withEndDate(LocalDate endDate) {
        Utils.checkNotNull(endDate, "endDate");
        this.endDate = endDate;
        return this;
    }

    /**
     * The target date for the aggregate window.
     */
    public SourcePolygonStockApi withLimit(long limit) {
        Utils.checkNotNull(limit, "limit");
        this.limit = Optional.ofNullable(limit);
        return this;
    }

    /**
     * The target date for the aggregate window.
     */
    public SourcePolygonStockApi withLimit(Optional<? extends Long> limit) {
        Utils.checkNotNull(limit, "limit");
        this.limit = limit;
        return this;
    }

    /**
     * The size of the timespan multiplier.
     */
    public SourcePolygonStockApi withMultiplier(long multiplier) {
        Utils.checkNotNull(multiplier, "multiplier");
        this.multiplier = multiplier;
        return this;
    }

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    public SourcePolygonStockApi withSort(String sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    public SourcePolygonStockApi withSort(Optional<? extends String> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * The beginning date for the aggregate window.
     */
    public SourcePolygonStockApi withStartDate(LocalDate startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The exchange symbol that this item is traded under.
     */
    public SourcePolygonStockApi withStocksTicker(String stocksTicker) {
        Utils.checkNotNull(stocksTicker, "stocksTicker");
        this.stocksTicker = stocksTicker;
        return this;
    }

    /**
     * The size of the time window.
     */
    public SourcePolygonStockApi withTimespan(String timespan) {
        Utils.checkNotNull(timespan, "timespan");
        this.timespan = timespan;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourcePolygonStockApi other = (SourcePolygonStockApi) o;
        return 
            java.util.Objects.deepEquals(this.adjusted, other.adjusted) &&
            java.util.Objects.deepEquals(this.apiKey, other.apiKey) &&
            java.util.Objects.deepEquals(this.endDate, other.endDate) &&
            java.util.Objects.deepEquals(this.limit, other.limit) &&
            java.util.Objects.deepEquals(this.multiplier, other.multiplier) &&
            java.util.Objects.deepEquals(this.sort, other.sort) &&
            java.util.Objects.deepEquals(this.sourceType, other.sourceType) &&
            java.util.Objects.deepEquals(this.startDate, other.startDate) &&
            java.util.Objects.deepEquals(this.stocksTicker, other.stocksTicker) &&
            java.util.Objects.deepEquals(this.timespan, other.timespan);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            adjusted,
            apiKey,
            endDate,
            limit,
            multiplier,
            sort,
            sourceType,
            startDate,
            stocksTicker,
            timespan);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourcePolygonStockApi.class,
                "adjusted", adjusted,
                "apiKey", apiKey,
                "endDate", endDate,
                "limit", limit,
                "multiplier", multiplier,
                "sort", sort,
                "sourceType", sourceType,
                "startDate", startDate,
                "stocksTicker", stocksTicker,
                "timespan", timespan);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> adjusted = Optional.empty();
 
        private String apiKey;
 
        private LocalDate endDate;
 
        private Optional<? extends Long> limit = Optional.empty();
 
        private Long multiplier;
 
        private Optional<? extends String> sort = Optional.empty();
 
        private LocalDate startDate;
 
        private String stocksTicker;
 
        private String timespan;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
         */
        public Builder adjusted(String adjusted) {
            Utils.checkNotNull(adjusted, "adjusted");
            this.adjusted = Optional.ofNullable(adjusted);
            return this;
        }

        /**
         * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
         */
        public Builder adjusted(Optional<? extends String> adjusted) {
            Utils.checkNotNull(adjusted, "adjusted");
            this.adjusted = adjusted;
            return this;
        }

        /**
         * Your API ACCESS Key
         */
        public Builder apiKey(String apiKey) {
            Utils.checkNotNull(apiKey, "apiKey");
            this.apiKey = apiKey;
            return this;
        }

        /**
         * The target date for the aggregate window.
         */
        public Builder endDate(LocalDate endDate) {
            Utils.checkNotNull(endDate, "endDate");
            this.endDate = endDate;
            return this;
        }

        /**
         * The target date for the aggregate window.
         */
        public Builder limit(long limit) {
            Utils.checkNotNull(limit, "limit");
            this.limit = Optional.ofNullable(limit);
            return this;
        }

        /**
         * The target date for the aggregate window.
         */
        public Builder limit(Optional<? extends Long> limit) {
            Utils.checkNotNull(limit, "limit");
            this.limit = limit;
            return this;
        }

        /**
         * The size of the timespan multiplier.
         */
        public Builder multiplier(long multiplier) {
            Utils.checkNotNull(multiplier, "multiplier");
            this.multiplier = multiplier;
            return this;
        }

        /**
         * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
         */
        public Builder sort(String sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
         */
        public Builder sort(Optional<? extends String> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }

        /**
         * The beginning date for the aggregate window.
         */
        public Builder startDate(LocalDate startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * The exchange symbol that this item is traded under.
         */
        public Builder stocksTicker(String stocksTicker) {
            Utils.checkNotNull(stocksTicker, "stocksTicker");
            this.stocksTicker = stocksTicker;
            return this;
        }

        /**
         * The size of the time window.
         */
        public Builder timespan(String timespan) {
            Utils.checkNotNull(timespan, "timespan");
            this.timespan = timespan;
            return this;
        }
        
        public SourcePolygonStockApi build() {
            return new SourcePolygonStockApi(
                adjusted,
                apiKey,
                endDate,
                limit,
                multiplier,
                sort,
                startDate,
                stocksTicker,
                timespan);
        }

        private static final LazySingletonValue<PolygonStockApi> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"polygon-stock-api\"",
                        new TypeReference<PolygonStockApi>() {});
    }
}

