/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.airbyte.api.models.shared;


import com.airbyte.api.utils.LazySingletonValue;
import com.airbyte.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.time.LocalDate;
import java.util.Objects;
import java.util.Optional;


public class SourcePolygonStockApi {

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("adjusted")
    private Optional<String> adjusted;

    /**
     * Your API ACCESS Key
     */
    @JsonProperty("apiKey")
    private String apiKey;

    /**
     * The target date for the aggregate window.
     */
    @JsonProperty("end_date")
    private LocalDate endDate;

    /**
     * The target date for the aggregate window.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("limit")
    private Optional<Long> limit;

    /**
     * The size of the timespan multiplier.
     */
    @JsonProperty("multiplier")
    private long multiplier;

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort")
    private Optional<String> sort;

    @JsonProperty("sourceType")
    private PolygonStockApi sourceType;

    /**
     * The beginning date for the aggregate window.
     */
    @JsonProperty("start_date")
    private LocalDate startDate;

    /**
     * The exchange symbol that this item is traded under.
     */
    @JsonProperty("stocksTicker")
    private String stocksTicker;

    /**
     * The size of the time window.
     */
    @JsonProperty("timespan")
    private String timespan;

    @JsonCreator
    public SourcePolygonStockApi(
            @JsonProperty("adjusted") Optional<String> adjusted,
            @JsonProperty("apiKey") String apiKey,
            @JsonProperty("end_date") LocalDate endDate,
            @JsonProperty("limit") Optional<Long> limit,
            @JsonProperty("multiplier") long multiplier,
            @JsonProperty("sort") Optional<String> sort,
            @JsonProperty("start_date") LocalDate startDate,
            @JsonProperty("stocksTicker") String stocksTicker,
            @JsonProperty("timespan") String timespan) {
        Utils.checkNotNull(adjusted, "adjusted");
        Utils.checkNotNull(apiKey, "apiKey");
        Utils.checkNotNull(endDate, "endDate");
        Utils.checkNotNull(limit, "limit");
        Utils.checkNotNull(multiplier, "multiplier");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(stocksTicker, "stocksTicker");
        Utils.checkNotNull(timespan, "timespan");
        this.adjusted = adjusted;
        this.apiKey = apiKey;
        this.endDate = endDate;
        this.limit = limit;
        this.multiplier = multiplier;
        this.sort = sort;
        this.sourceType = Builder._SINGLETON_VALUE_SourceType.value();
        this.startDate = startDate;
        this.stocksTicker = stocksTicker;
        this.timespan = timespan;
    }
    
    public SourcePolygonStockApi(
            String apiKey,
            LocalDate endDate,
            long multiplier,
            LocalDate startDate,
            String stocksTicker,
            String timespan) {
        this(Optional.empty(), apiKey, endDate, Optional.empty(), multiplier, Optional.empty(), startDate, stocksTicker, timespan);
    }

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    @JsonIgnore
    public Optional<String> adjusted() {
        return adjusted;
    }

    /**
     * Your API ACCESS Key
     */
    @JsonIgnore
    public String apiKey() {
        return apiKey;
    }

    /**
     * The target date for the aggregate window.
     */
    @JsonIgnore
    public LocalDate endDate() {
        return endDate;
    }

    /**
     * The target date for the aggregate window.
     */
    @JsonIgnore
    public Optional<Long> limit() {
        return limit;
    }

    /**
     * The size of the timespan multiplier.
     */
    @JsonIgnore
    public long multiplier() {
        return multiplier;
    }

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    @JsonIgnore
    public Optional<String> sort() {
        return sort;
    }

    @JsonIgnore
    public PolygonStockApi sourceType() {
        return sourceType;
    }

    /**
     * The beginning date for the aggregate window.
     */
    @JsonIgnore
    public LocalDate startDate() {
        return startDate;
    }

    /**
     * The exchange symbol that this item is traded under.
     */
    @JsonIgnore
    public String stocksTicker() {
        return stocksTicker;
    }

    /**
     * The size of the time window.
     */
    @JsonIgnore
    public String timespan() {
        return timespan;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    public SourcePolygonStockApi withAdjusted(String adjusted) {
        Utils.checkNotNull(adjusted, "adjusted");
        this.adjusted = Optional.ofNullable(adjusted);
        return this;
    }

    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    public SourcePolygonStockApi withAdjusted(Optional<String> adjusted) {
        Utils.checkNotNull(adjusted, "adjusted");
        this.adjusted = adjusted;
        return this;
    }

    /**
     * Your API ACCESS Key
     */
    public SourcePolygonStockApi withApiKey(String apiKey) {
        Utils.checkNotNull(apiKey, "apiKey");
        this.apiKey = apiKey;
        return this;
    }

    /**
     * The target date for the aggregate window.
     */
    public SourcePolygonStockApi withEndDate(LocalDate endDate) {
        Utils.checkNotNull(endDate, "endDate");
        this.endDate = endDate;
        return this;
    }

    /**
     * The target date for the aggregate window.
     */
    public SourcePolygonStockApi withLimit(long limit) {
        Utils.checkNotNull(limit, "limit");
        this.limit = Optional.ofNullable(limit);
        return this;
    }

    /**
     * The target date for the aggregate window.
     */
    public SourcePolygonStockApi withLimit(Optional<Long> limit) {
        Utils.checkNotNull(limit, "limit");
        this.limit = limit;
        return this;
    }

    /**
     * The size of the timespan multiplier.
     */
    public SourcePolygonStockApi withMultiplier(long multiplier) {
        Utils.checkNotNull(multiplier, "multiplier");
        this.multiplier = multiplier;
        return this;
    }

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    public SourcePolygonStockApi withSort(String sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }

    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    public SourcePolygonStockApi withSort(Optional<String> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * The beginning date for the aggregate window.
     */
    public SourcePolygonStockApi withStartDate(LocalDate startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The exchange symbol that this item is traded under.
     */
    public SourcePolygonStockApi withStocksTicker(String stocksTicker) {
        Utils.checkNotNull(stocksTicker, "stocksTicker");
        this.stocksTicker = stocksTicker;
        return this;
    }

    /**
     * The size of the time window.
     */
    public SourcePolygonStockApi withTimespan(String timespan) {
        Utils.checkNotNull(timespan, "timespan");
        this.timespan = timespan;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourcePolygonStockApi other = (SourcePolygonStockApi) o;
        return 
            Objects.deepEquals(this.adjusted, other.adjusted) &&
            Objects.deepEquals(this.apiKey, other.apiKey) &&
            Objects.deepEquals(this.endDate, other.endDate) &&
            Objects.deepEquals(this.limit, other.limit) &&
            Objects.deepEquals(this.multiplier, other.multiplier) &&
            Objects.deepEquals(this.sort, other.sort) &&
            Objects.deepEquals(this.sourceType, other.sourceType) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.stocksTicker, other.stocksTicker) &&
            Objects.deepEquals(this.timespan, other.timespan);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            adjusted,
            apiKey,
            endDate,
            limit,
            multiplier,
            sort,
            sourceType,
            startDate,
            stocksTicker,
            timespan);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourcePolygonStockApi.class,
                "adjusted", adjusted,
                "apiKey", apiKey,
                "endDate", endDate,
                "limit", limit,
                "multiplier", multiplier,
                "sort", sort,
                "sourceType", sourceType,
                "startDate", startDate,
                "stocksTicker", stocksTicker,
                "timespan", timespan);
    }
    
    public final static class Builder {
 
        private Optional<String> adjusted = Optional.empty();
 
        private String apiKey;
 
        private LocalDate endDate;
 
        private Optional<Long> limit = Optional.empty();
 
        private Long multiplier;
 
        private Optional<String> sort = Optional.empty();
 
        private LocalDate startDate;
 
        private String stocksTicker;
 
        private String timespan;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
         */
        public Builder adjusted(String adjusted) {
            Utils.checkNotNull(adjusted, "adjusted");
            this.adjusted = Optional.ofNullable(adjusted);
            return this;
        }

        /**
         * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
         */
        public Builder adjusted(Optional<String> adjusted) {
            Utils.checkNotNull(adjusted, "adjusted");
            this.adjusted = adjusted;
            return this;
        }

        /**
         * Your API ACCESS Key
         */
        public Builder apiKey(String apiKey) {
            Utils.checkNotNull(apiKey, "apiKey");
            this.apiKey = apiKey;
            return this;
        }

        /**
         * The target date for the aggregate window.
         */
        public Builder endDate(LocalDate endDate) {
            Utils.checkNotNull(endDate, "endDate");
            this.endDate = endDate;
            return this;
        }

        /**
         * The target date for the aggregate window.
         */
        public Builder limit(long limit) {
            Utils.checkNotNull(limit, "limit");
            this.limit = Optional.ofNullable(limit);
            return this;
        }

        /**
         * The target date for the aggregate window.
         */
        public Builder limit(Optional<Long> limit) {
            Utils.checkNotNull(limit, "limit");
            this.limit = limit;
            return this;
        }

        /**
         * The size of the timespan multiplier.
         */
        public Builder multiplier(long multiplier) {
            Utils.checkNotNull(multiplier, "multiplier");
            this.multiplier = multiplier;
            return this;
        }

        /**
         * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
         */
        public Builder sort(String sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
         */
        public Builder sort(Optional<String> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }

        /**
         * The beginning date for the aggregate window.
         */
        public Builder startDate(LocalDate startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * The exchange symbol that this item is traded under.
         */
        public Builder stocksTicker(String stocksTicker) {
            Utils.checkNotNull(stocksTicker, "stocksTicker");
            this.stocksTicker = stocksTicker;
            return this;
        }

        /**
         * The size of the time window.
         */
        public Builder timespan(String timespan) {
            Utils.checkNotNull(timespan, "timespan");
            this.timespan = timespan;
            return this;
        }
        
        public SourcePolygonStockApi build() {
            return new SourcePolygonStockApi(
                adjusted,
                apiKey,
                endDate,
                limit,
                multiplier,
                sort,
                startDate,
                stocksTicker,
                timespan);
        }

        private static final LazySingletonValue<PolygonStockApi> _SINGLETON_VALUE_SourceType =
                new LazySingletonValue<>(
                        "sourceType",
                        "\"polygon-stock-api\"",
                        new TypeReference<PolygonStockApi>() {});
    }
}

